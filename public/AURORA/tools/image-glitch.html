<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ•…éšœè‰ºæœ¯ç”Ÿæˆå™¨</title>
    <link rel="stylesheet" href="../css/style.css">
    <script src="../js/app.js"></script>
    <script src="../js/loader.js"></script>
    <style>
        /* Tool-specific overrides only */
        .slider-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }
        .slider-row label { flex: 1; font-size: 0.85rem; color: var(--text-dim); margin-bottom: 0; }
        .slider-row span { font-size: 0.85rem; color: var(--secondary); width: 30px; text-align: right; }
        
        .control-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            color: var(--primary);
            font-weight: 600;
            font-size: 0.95rem;
        }

        .frame-item {
            position: relative;
            border: 2px solid var(--border);
            border-radius: 4px;
            overflow: hidden;
            aspect-ratio: 1;
            background: #000;
            cursor: pointer;
            transition: all 0.2s;
        }
        .frame-item:hover {
            border-color: var(--text-dim);
        }
        .frame-item.active {
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(var(--primary-rgb), 0.3);
        }
        .frame-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: space-between;
            padding: 2px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .frame-item:hover .frame-overlay, .frame-item.active .frame-overlay {
            opacity: 1;
        }
        
        /* Fix for scrolling issue */
        .layout-sidebar .controls {
            max-height: 100%;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="layout-sidebar">
        <!-- Controls -->
        <div class="controls panel">
            <h2 style="margin:0 0 15px 0; color:var(--primary); font-size:1.5rem;">æ•…éšœè‰ºæœ¯</h2>
            
            <div class="control-group">
                <div class="upload-area" id="uploadArea">
                    <i class="fas fa-cloud-upload-alt" style="font-size: 1.5rem; margin-bottom: 0.5rem; color: var(--text-dim);"></i>
                    <div style="font-size: 0.8rem;">ç‚¹å‡» or æ‹–æ”¾å›¾ç‰‡</div>
                    <input type="file" id="input-file" accept="image/*" hidden>
                </div>
            </div>

            <div class="sub-tab-group">
                <div class="sub-tab active" onclick="setMode('layer')">å›¾å±‚æ•…éšœ</div>
                <div class="sub-tab" onclick="setMode('data')">æ•°æ®ç ´å</div>
                <div class="sub-tab" onclick="setMode('gif')">GIF åŠ¨å›¾</div>
            </div>

            <!-- MODE: Layer Glitch (Canvas) -->
            <div id="controls-layer">
                <div class="control-group">
                    <div class="control-title">
                        <span>RGB é€šé“åç§»</span>
                        <input type="checkbox" id="chk-rgb" checked>
                    </div>
                    <div class="slider-row">
                        <label>æ°´å¹³åç§» X</label>
                        <input type="range" id="rgb-amount" min="-50" max="50" value="10">
                        <span id="val-rgb">10</span>
                    </div>
                    <div class="slider-row">
                        <label>å‚ç›´åç§» Y</label>
                        <input type="range" id="rgb-angle" min="-50" max="50" value="0">
                        <span id="val-rgb-y">0</span>
                    </div>
                </div>

                <div class="control-group">
                    <div class="control-title">
                        <span>åˆ‡ç‰‡ä¸é”™ä½</span>
                        <input type="checkbox" id="chk-slice" checked>
                    </div>
                    <div class="slider-row">
                        <label>åˆ‡ç‰‡æ•°é‡</label>
                        <input type="range" id="slice-amount" min="0" max="20" value="5">
                        <span id="val-slice">5</span>
                    </div>
                    <div class="slider-row">
                        <label>åˆ‡ç‰‡é«˜åº¦</label>
                        <input type="range" id="slice-height" min="1" max="50" value="5">
                        <span id="val-slice-h">5</span>
                    </div>
                    <div class="slider-row">
                        <label>æœ€å¤§åç§»</label>
                        <input type="range" id="slice-offset" min="0" max="100" value="20">
                        <span id="val-slice-o">20</span>
                    </div>
                </div>

                <div class="control-group">
                    <div class="control-title">
                        <span>æ‰«æçº¿çº¹ç†</span>
                        <input type="checkbox" id="chk-scan">
                    </div>
                    <div class="slider-row">
                        <label>çº¿æ¡å¯†åº¦</label>
                        <input type="range" id="scan-density" min="2" max="10" value="3">
                        <span id="val-scan">3</span>
                    </div>
                    <div class="slider-row">
                        <label>é€æ˜åº¦</label>
                        <input type="range" id="scan-opacity" min="0" max="100" value="50">
                        <span id="val-scan-o">50</span>
                    </div>
                </div>
                
                <button class="btn btn-primary" id="btn-render" style="width: 100%; margin-bottom: 10px;">âš¡ é‡æ–°æ¸²æŸ“</button>
                <button class="btn btn-secondary" id="btn-random" style="width: 100%;">ğŸ² éšæœºå‚æ•°</button>
            </div>

            <!-- MODE: Data Glitch (Binary) -->
            <div id="controls-data" style="display: none;">
                <p style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 15px; padding: 10px; background: rgba(244, 63, 94, 0.1); border-radius: 4px; border: 1px solid rgba(244, 63, 94, 0.2);">
                    âš ï¸ è­¦å‘Šï¼šè¿™æ˜¯å¯¹ JPEG äºŒè¿›åˆ¶æ•°æ®çš„ç ´åæ€§ç¼–è¾‘ï¼Œç»“æœä¸å¯é¢„æµ‹ä¸”å¯èƒ½å¯¼è‡´å›¾ç‰‡æ— æ³•æ˜¾ç¤ºã€‚
                </p>
                
                <div class="control-group">
                    <div class="control-title">äºŒè¿›åˆ¶æ•°æ®è…èš€</div>
                    <div class="slider-row">
                        <label>éšæœºç§å­</label>
                        <input type="range" id="data-seed" min="0" max="100" value="50">
                        <span id="val-data-seed">50</span>
                    </div>
                    <div class="slider-row">
                        <label>ç ´åæ•°é‡</label>
                        <input type="range" id="data-amount" min="1" max="100" value="10">
                        <span id="val-data-amt">10</span>
                    </div>
                    <div class="slider-row">
                        <label>è¿­ä»£æ¬¡æ•°</label>
                        <input type="range" id="data-iter" min="1" max="20" value="5">
                        <span id="val-data-iter">5</span>
                    </div>
                </div>

                <button class="btn btn-danger" id="btn-mosh" style="width: 100%;">â˜ ï¸ ç ´åæ•°æ® (MOSH)</button>
            </div>
            
            <!-- MODE: GIF Glitch -->
            <div id="controls-gif" style="display: none;">
                 <p style="font-size: 0.85rem; color: var(--text-dim); margin-bottom: 15px;">
                    ç”ŸæˆåŒ…å«å¤šä¸ªéšæœºç ´åæ•ˆæœå¸§çš„ GIF åŠ¨ç”»ã€‚
                </p>
                <div class="control-group">
                    <div class="control-title">åŠ¨ç”»è®¾ç½®</div>
                    <div class="slider-row">
                        <label>å¸§æ•° (Frames)</label>
                        <input type="range" id="gif-frames" min="2" max="50" value="10">
                        <span id="val-gif-frames">10</span>
                    </div>
                    <div class="slider-row">
                        <label>å¸§é—´éš” (ms)</label>
                        <input type="range" id="gif-delay" min="20" max="500" value="100" step="10">
                        <span id="val-gif-delay">100</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-title">æ•°æ®ç ´åå‚æ•°</div>
                    <div class="slider-row">
                        <label>ç ´åæ•°é‡</label>
                        <input type="range" id="gif-amount" min="1" max="100" value="10">
                        <span id="val-gif-amt">10</span>
                    </div>
                    <div class="slider-row">
                        <label>è¿­ä»£æ¬¡æ•°</label>
                        <input type="range" id="gif-iter" min="1" max="20" value="5">
                        <span id="val-gif-iter">5</span>
                    </div>
                    <div class="slider-row">
                        <label>éšæœºç§å­å˜åŒ–</label>
                        <input type="checkbox" id="gif-seed-random" checked>
                    </div>
                </div>

                <div style="display:flex; gap:10px; margin-bottom:15px;">
                    <button class="btn btn-primary" id="btn-gen-frames" style="flex:1;">ğŸ“¸ ç”Ÿæˆå¸§åºåˆ—</button>
                    <button class="btn btn-success" id="btn-render-gif" style="flex:1;" disabled>ğŸ¬ å¯¼å‡º GIF</button>
                </div>

                <!-- Frame Editor -->
                <div id="frame-editor" style="display:none; margin-bottom:15px;">
                    <div class="control-title">
                        <span>å¸§ç¼–è¾‘ (<span id="frame-count-display">0</span>)</span>
                        <button class="btn btn-sm btn-secondary" onclick="clearFrames()" style="font-size:0.7rem; padding:2px 6px;">æ¸…ç©º</button>
                    </div>
                    <div id="frame-list" style="display:grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap:8px; max-height:300px; overflow-y:auto; padding:5px; background:rgba(0,0,0,0.2); border-radius:4px; overscroll-behavior: contain;">
                        <!-- Frames injected here -->
                    </div>
                </div>
                
                <!-- Progress Bar -->
                <div id="gif-progress-container" style="display:none; margin-top:10px;">
                    <div style="height:6px; background:rgba(255,255,255,0.1); border-radius:3px; overflow:hidden;">
                        <div id="gif-progress-bar" style="width:0%; height:100%; background:var(--primary); transition:width 0.2s;"></div>
                    </div>
                    <div id="gif-progress-text" style="font-size:0.8rem; color:var(--text-dim); text-align:center; margin-top:4px;">0%</div>
                </div>

                <div id="gif-status" style="font-size:0.8rem; color:var(--text-dim); text-align:center; margin-top:5px;"></div>
            </div>

            <a id="btn-download" class="btn btn-success" style="text-align:center; text-decoration:none; margin-top: auto; display: none; justify-content: center;">ğŸ’¾ ä¿å­˜å›¾ç‰‡</a>
        </div>

        <!-- Preview -->
        <div class="preview-area">
            <div id="placeholder-text" style="color:var(--text-dim);">è¯·å…ˆä¸Šä¼ å›¾ç‰‡</div>
            <canvas id="cvs-main" class="canvas-responsive" style="display:none; border-radius: var(--radius-md); box-shadow: var(--shadow);"></canvas>
            <img id="img-mosh" class="canvas-responsive" style="display: none; border-radius: var(--radius-md); box-shadow: var(--shadow);">
            <img id="img-gif" class="canvas-responsive" style="display: none; border-radius: var(--radius-md); box-shadow: var(--shadow);">
        </div>

    </div>

    <script>
        // --- Core Variables ---
        let srcImg = new Image();
        let srcLoaded = false;
        const cvs = document.getElementById('cvs-main');
        const ctx = cvs.getContext('2d', { willReadFrequently: true });
        let currentMode = 'layer';
        let gifLibLoaded = false;
        
        // Load GIF Library
        ResourceLoader.loadDeps('@gif').then(() => {
            gifLibLoaded = true;
            console.log('GIF Library Loaded');
        });

        // Worker Init
        let glitchWorker = null;
        if(window.Worker) {
            glitchWorker = (window.app && app.getWorker) ? app.getWorker('../js/workers/glitch.worker.js') : new Worker('../js/workers/glitch.worker.js');
            glitchWorker.onmessage = (e) => {
                const { type, imageData, error } = e.data;
                if(type === 'complete') {
                    ctx.putImageData(imageData, 0, 0);
                    updateDownload(cvs.toDataURL('image/jpeg', 0.9));
                    document.getElementById('btn-render').innerText = "âš¡ é‡æ–°æ¸²æŸ“";
                    document.getElementById('btn-render').disabled = false;
                } else if(type === 'error') {
                    console.error(error);
                    alert('Worker Error: ' + error);
                    document.getElementById('btn-render').disabled = false;
                }
            };
        }

        // --- UI Utils ---
        function updateVal(id, val) { document.getElementById(id).innerText = val; }
        
        const idMap = {
            'rgb-amount': 'val-rgb',
            'rgb-angle': 'val-rgb-y',
            'slice-amount': 'val-slice',
            'slice-height': 'val-slice-h',
            'slice-offset': 'val-slice-o',
            'scan-density': 'val-scan',
            'scan-opacity': 'val-scan-o',
            'data-seed': 'val-data-seed',
            'data-amount': 'val-data-amt',
            'data-iter': 'val-data-iter',
            'gif-frames': 'val-gif-frames',
            'gif-delay': 'val-gif-delay',
            'gif-amount': 'val-gif-amt',
            'gif-iter': 'val-gif-iter'
        };

        Object.keys(idMap).forEach(id => {
            const el = document.getElementById(id);
            const span = document.getElementById(idMap[id]);
            if(el && span) {
                el.oninput = () => { span.innerText = el.value; if(currentMode === 'layer') requestAnimationFrame(renderLayerGlitch); };
            }
        });
        
        document.querySelectorAll('input[type=checkbox]').forEach(el => {
            el.onchange = () => { if(currentMode === 'layer') renderLayerGlitch(); };
        });

        // --- Mode Switching ---
        window.setMode = (mode) => {
            currentMode = mode;
            document.querySelectorAll('.sub-tab').forEach(el => el.classList.remove('active'));
            event.target.classList.add('active');
            
            document.getElementById('controls-layer').style.display = mode === 'layer' ? 'block' : 'none';
            document.getElementById('controls-data').style.display = mode === 'data' ? 'block' : 'none';
            document.getElementById('controls-gif').style.display = mode === 'gif' ? 'block' : 'none';
            
            // Reset Preview Visibility
            cvs.style.display = 'none';
            document.getElementById('img-mosh').style.display = 'none';
            document.getElementById('img-gif').style.display = 'none';

            if(mode === 'layer') {
                if(srcLoaded) {
                    cvs.style.display = 'block';
                    renderLayerGlitch();
                }
            } else if (mode === 'data') {
                if(srcLoaded && document.getElementById('img-mosh').src) {
                    document.getElementById('img-mosh').style.display = 'block';
                } else if (srcLoaded) {
                    // Show original if no result yet
                    document.getElementById('img-mosh').src = srcImg.src;
                    document.getElementById('img-mosh').style.display = 'block';
                }
            } else if (mode === 'gif') {
                if(srcLoaded && document.getElementById('img-gif').src) {
                    document.getElementById('img-gif').style.display = 'block';
                } else if (srcLoaded) {
                     document.getElementById('img-gif').src = srcImg.src;
                     document.getElementById('img-gif').style.display = 'block';
                }
            }
        };

        // --- File Loading ---
        const uploadArea = document.getElementById('uploadArea');
        const inputFile = document.getElementById('input-file');

        uploadArea.addEventListener('click', () => inputFile.click());
        uploadArea.addEventListener('dragover', (e) => { e.preventDefault(); uploadArea.style.borderColor = 'var(--primary)'; });
        uploadArea.addEventListener('dragleave', () => { uploadArea.style.borderColor = 'var(--border)'; });
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.style.borderColor = 'var(--border)';
            if(e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
        });

        inputFile.onchange = (e) => {
            if(e.target.files[0]) handleFile(e.target.files[0]);
        };

        function handleFile(file) {
            if(!file) return;
            
            document.getElementById('placeholder-text').style.display = 'none';
            
            const reader = new FileReader();
            reader.onload = (ev) => {
                srcImg.onload = () => {
                    srcLoaded = true;
                    // Reset Canvas size
                    const maxW = 800; // Limit size for performance
                    const scale = Math.min(1, maxW / srcImg.width);
                    cvs.width = srcImg.width * scale;
                    cvs.height = srcImg.height * scale;
                    
                    // Always draw initial image to canvas to ensure data exists for other modes
                    ctx.drawImage(srcImg, 0, 0, cvs.width, cvs.height);
                    
                    if(currentMode === 'layer') {
                        cvs.style.display = 'block';
                        renderLayerGlitch();
                    } else if (currentMode === 'data') {
                        document.getElementById('img-mosh').src = srcImg.src;
                        document.getElementById('img-mosh').style.display = 'block';
                    } else if (currentMode === 'gif') {
                        document.getElementById('img-gif').src = srcImg.src;
                        document.getElementById('img-gif').style.display = 'block';
                    }
                };
                srcImg.src = ev.target.result;
            };
            reader.readAsDataURL(file);
        }

        // --- Layer Glitch Logic ---
        function renderLayerGlitch() {
            if(!srcLoaded) return;
            
            const w = cvs.width;
            const h = cvs.height;
            
            // 1. Draw Original
            ctx.drawImage(srcImg, 0, 0, w, h);
            
            // A. Slice & Displace (Draw parts shifted) - KEEP IN MAIN THREAD (Faster with drawImage)
            if(document.getElementById('chk-slice').checked) {
                const amount = parseInt(document.getElementById('slice-amount').value);
                const height = parseInt(document.getElementById('slice-height').value);
                const maxOffset = parseInt(document.getElementById('slice-offset').value);
                
                for(let i=0; i<amount; i++) {
                    const y = Math.random() * h;
                    const sh = Math.random() * height + 2;
                    const off = (Math.random() - 0.5) * maxOffset * 2;
                    
                    // Draw a slice shifted
                    ctx.drawImage(srcImg, 
                        0, y / (h/srcImg.height), srcImg.width, sh / (h/srcImg.height), // Source
                        off, y, w, sh // Dest
                    );
                }
            }

            // If no pixel manip needed, stop here
            if(!document.getElementById('chk-rgb').checked && !document.getElementById('chk-scan').checked) {
                updateDownload(cvs.toDataURL('image/jpeg', 0.9));
                return;
            }

            // Use Worker for Pixel Manipulation (RGB & Scanlines)
            if (glitchWorker) {
                const btn = document.getElementById('btn-render');
                btn.innerText = "å¤„ç†ä¸­...";
                btn.disabled = true;

                const imgData = ctx.getImageData(0, 0, w, h);
                
                const config = {
                    rgb: {
                        enabled: document.getElementById('chk-rgb').checked,
                        amount: parseInt(document.getElementById('rgb-amount').value),
                        angle: parseInt(document.getElementById('rgb-angle').value)
                    },
                    scan: {
                        enabled: document.getElementById('chk-scan').checked,
                        density: parseInt(document.getElementById('scan-density').value),
                        opacity: parseInt(document.getElementById('scan-opacity').value) / 100
                    }
                };

                glitchWorker.postMessage({
                    type: 'process',
                    imageData: imgData,
                    config: config
                }, [imgData.data.buffer]);
                
                return; // Worker handles the rest
            }

            // Fallback for no worker (Original Code)
            // B. RGB Shift (Composite Operation)
            if(document.getElementById('chk-rgb').checked) {
                const offX = parseInt(document.getElementById('rgb-amount').value);
                const offY = parseInt(document.getElementById('rgb-angle').value);
                
                if(offX !== 0 || offY !== 0) {
                    const imgData = ctx.getImageData(0, 0, w, h);
                    const original = ctx.getImageData(0, 0, w, h); // Copy
                    const d = imgData.data;
                    const s = original.data;
                    
                    for(let y=0; y<h; y++) {
                        for(let x=0; x<w; x++) {
                            const idx = (y * w + x) * 4;
                            
                            // Red Channel: Shift Left/Up
                            let rx = x - offX;
                            let ry = y - offY;
                            if(rx >= 0 && rx < w && ry >= 0 && ry < h) {
                                d[idx] = s[(ry * w + rx) * 4]; 
                            }
                            
                            // Blue Channel: Shift Right/Down
                            let bx = x + offX;
                            let by = y + offY;
                            if(bx >= 0 && bx < w && by >= 0 && by < h) {
                                d[idx+2] = s[(by * w + bx) * 4 + 2];
                            }
                        }
                    }
                    ctx.putImageData(imgData, 0, 0);
                }
            }
            
            // C. Scanlines
            if(document.getElementById('chk-scan').checked) {
                const density = parseInt(document.getElementById('scan-density').value);
                const opacity = parseInt(document.getElementById('scan-opacity').value) / 100;
                
                ctx.fillStyle = `rgba(0,0,0,${opacity})`;
                for(let y=0; y<h; y+=density) {
                    ctx.fillRect(0, y, w, 1);
                }
            }
            
            updateDownload(cvs.toDataURL('image/jpeg', 0.9));
        }

        // --- Data Mosh Logic ---
        function performDataMosh(uint8, seed, amount, iter) {
             const corrupted = new Uint8Array(uint8);
             // Simple PRNG for reproducibility if needed (but we use Math.random for now)
             
             for(let i=0; i<iter; i++) {
                // Pick a random spot, strictly after header (assume ~5% header safe zone)
                const maxIdx = corrupted.length - 100;
                const minIdx = Math.floor(corrupted.length / 20); 
                
                const idx = Math.floor(minIdx + Math.random() * (maxIdx - minIdx));
                
                // Action: Replace byte
                const val = Math.floor(Math.random() * 256);
                corrupted[idx] = val;
                
                // Action: Replace chunk with 0
                if(Math.random() > 0.5) {
                    for(let j=0; j<amount; j++) {
                        if(idx+j < maxIdx) corrupted[idx+j] = 0;
                    }
                }
            }
            return corrupted;
        }

        document.getElementById('btn-mosh').onclick = () => {
            if(!srcLoaded) return alert("è¯·å…ˆä¸Šä¼ å›¾ç‰‡ï¼");
            
            const btn = document.getElementById('btn-mosh');
            btn.disabled = true;
            btn.innerText = "ç ´åä¸­...";
            
            cvs.toBlob(blob => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const buffer = e.target.result; // ArrayBuffer
                    const uint8 = new Uint8Array(buffer);
                    
                    const amount = parseInt(document.getElementById('data-amount').value); 
                    const iter = parseInt(document.getElementById('data-iter').value); 
                    
                    const corrupted = performDataMosh(uint8, 0, amount, iter);
                    
                    const newBlob = new Blob([corrupted], {type: 'image/jpeg'});
                    const url = URL.createObjectURL(newBlob);
                    
                    const imgMosh = document.getElementById('img-mosh');
                    imgMosh.src = url;
                    
                    updateDownload(url);
                    btn.disabled = false;
                    btn.innerText = "â˜ ï¸ ç ´åæ•°æ® (MOSH)";
                };
                reader.readAsArrayBuffer(blob);
            }, 'image/jpeg', 0.8);
        };

        // --- GIF Generation Logic ---
        let generatedFrames = []; // Stores { blob, url, seed, params }

        // 1. Generate Frames Step
        document.getElementById('btn-gen-frames').onclick = async () => {
             if(!srcLoaded) return alert("è¯·å…ˆä¸Šä¼ å›¾ç‰‡ï¼");
             
             const btn = document.getElementById('btn-gen-frames');
             const status = document.getElementById('gif-status');
             
             btn.disabled = true;
             btn.innerText = "ç”Ÿæˆä¸­...";
             status.innerText = "ç”Ÿæˆå¸§æ•°æ®...";
             
             try {
                 const framesCount = parseInt(document.getElementById('gif-frames').value);
                 const amount = parseInt(document.getElementById('gif-amount').value);
                 const iter = parseInt(document.getElementById('gif-iter').value);
                 const randomSeed = document.getElementById('gif-seed-random').checked;
                 
                 // Clear existing if needed? Or append? Let's clear for now based on "Generate Frames" usually implies fresh set
                 // But user might want to add more. Let's Append if Shift key pressed? No, keep simple: Clear first.
                 // Actually, let's just clear for simplicity unless we add "Add Frames" button.
                 generatedFrames = []; 
                 
                 // Get Source Blob
                 const srcBlob = await new Promise(resolve => cvs.toBlob(resolve, 'image/jpeg', 0.8));
                 const srcBuffer = await srcBlob.arrayBuffer();
                 const srcUint8 = new Uint8Array(srcBuffer);
                 
                 for(let i=0; i<framesCount; i++) {
                     // status.innerText = `ç”Ÿæˆå¸§ ${i+1}/${framesCount}...`;
                     // Allow UI to update
                     await new Promise(r => requestAnimationFrame(r));
                     
                     const seed = randomSeed ? Math.floor(Math.random() * 10000) : i;
                     const corrupted = performDataMosh(srcUint8, seed, amount, iter); 
                     const blob = new Blob([corrupted], {type: 'image/jpeg'});
                     const url = URL.createObjectURL(blob);
                     
                     generatedFrames.push({
                         blob: blob,
                         url: url,
                         seed: seed,
                         amount: amount,
                         iter: iter,
                         srcUint8: srcUint8 // Keep ref to source for regeneration
                     });
                 }
                 
                 renderFrameEditor();
                 status.innerText = `å·²ç”Ÿæˆ ${generatedFrames.length} å¸§`;
                 
             } catch (e) {
                 console.error(e);
                 alert('å¸§ç”Ÿæˆå¤±è´¥: ' + e.message);
             } finally {
                 btn.disabled = false;
                 btn.innerText = "ğŸ“¸ ç”Ÿæˆå¸§åºåˆ—";
             }
        };

        // 2. Render Frame Editor UI
        function renderFrameEditor() {
            const container = document.getElementById('frame-editor');
            const list = document.getElementById('frame-list');
            const countDisplay = document.getElementById('frame-count-display');
            const renderBtn = document.getElementById('btn-render-gif');
            
            if(generatedFrames.length > 0) {
                container.style.display = 'block';
                renderBtn.disabled = false;
            } else {
                container.style.display = 'none';
                renderBtn.disabled = true;
            }
            
            countDisplay.innerText = generatedFrames.length;
            list.innerHTML = '';
            
            generatedFrames.forEach((frame, index) => {
                 const item = document.createElement('div');
                 item.id = `frame-item-${index}`;
                 item.className = 'frame-item';
                 item.onclick = (e) => {
                    // Ignore clicks on buttons inside
                    if(e.target.tagName === 'BUTTON') return;
                    previewFrame(index);
                 };
                 
                 // Image
                 const img = document.createElement('img');
                 img.src = frame.url;
                 img.style.width = '100%';
                 img.style.height = '100%';
                 img.style.objectFit = 'cover';
                 
                 // Overlay Controls
                 const overlay = document.createElement('div');
                 overlay.className = 'frame-overlay';
                 
                 // Regenerate Btn
                 const btnRegen = document.createElement('button');
                 btnRegen.innerHTML = 'â†»';
                 btnRegen.title = 'é‡æ–°ç”Ÿæˆæ­¤å¸§';
                 btnRegen.onclick = (e) => { e.stopPropagation(); regenerateFrame(index); };
                 styleMiniBtn(btnRegen);

                 // Delete Btn
                 const btnDel = document.createElement('button');
                 btnDel.innerHTML = 'Ã—';
                 btnDel.style.color = '#ff4d4d';
                 btnDel.title = 'åˆ é™¤æ­¤å¸§';
                 btnDel.onclick = (e) => { e.stopPropagation(); deleteFrame(index); };
                 styleMiniBtn(btnDel);
                 
                 // Move Left
                 const btnLeft = document.createElement('button');
                 btnLeft.innerHTML = 'â€¹';
                 btnLeft.onclick = (e) => { e.stopPropagation(); moveFrame(index, -1); };
                 styleMiniBtn(btnLeft);
                 if(index === 0) btnLeft.style.visibility = 'hidden';

                 // Move Right
                 const btnRight = document.createElement('button');
                 btnRight.innerHTML = 'â€º';
                 btnRight.onclick = (e) => { e.stopPropagation(); moveFrame(index, 1); };
                 styleMiniBtn(btnRight);
                 if(index === generatedFrames.length - 1) btnRight.style.visibility = 'hidden';

                 overlay.appendChild(btnLeft);
                 overlay.appendChild(btnRegen);
                 overlay.appendChild(btnDel);
                 overlay.appendChild(btnRight);
                 
                 item.appendChild(img);
                 item.appendChild(overlay);
                 list.appendChild(item);
             });
         }

         window.previewFrame = (index) => {
             // Highlight
             document.querySelectorAll('.frame-item').forEach(el => el.classList.remove('active'));
             const item = document.getElementById(`frame-item-${index}`);
             if(item) item.classList.add('active');
             
             // Show Image
             if(generatedFrames[index]) {
                 const imgGif = document.getElementById('img-gif');
                 imgGif.src = generatedFrames[index].url;
                 imgGif.style.display = 'block';
                 
                 // Update status text just for feedback
                 document.getElementById('gif-status').innerText = `é¢„è§ˆç¬¬ ${index+1} å¸§`;
             }
         };

        function styleMiniBtn(btn) {
            btn.style.background = 'none';
            btn.style.border = 'none';
            btn.style.color = '#fff';
            btn.style.cursor = 'pointer';
            btn.style.fontSize = '12px';
            btn.style.padding = '2px 4px';
            btn.onmouseover = () => btn.style.opacity = '1';
            btn.onmouseout = () => btn.style.opacity = '0.7';
            btn.style.opacity = '0.7';
        }

        window.clearFrames = () => {
            generatedFrames.forEach(f => URL.revokeObjectURL(f.url));
            generatedFrames = [];
            renderFrameEditor();
        };

        window.deleteFrame = (index) => {
            URL.revokeObjectURL(generatedFrames[index].url);
            generatedFrames.splice(index, 1);
            renderFrameEditor();
        };

        window.moveFrame = (index, dir) => {
            if(index + dir < 0 || index + dir >= generatedFrames.length) return;
            const temp = generatedFrames[index];
            generatedFrames[index] = generatedFrames[index+dir];
            generatedFrames[index+dir] = temp;
            renderFrameEditor();
        };

        window.regenerateFrame = (index) => {
            const frame = generatedFrames[index];
            const newSeed = Math.floor(Math.random() * 10000); // New random seed
            const corrupted = performDataMosh(frame.srcUint8, newSeed, frame.amount, frame.iter);
            
            URL.revokeObjectURL(frame.url); // Free old
            const blob = new Blob([corrupted], {type: 'image/jpeg'});
            
            generatedFrames[index] = {
                ...frame,
                blob: blob,
                url: URL.createObjectURL(blob),
                seed: newSeed
            };
            renderFrameEditor();
        };

        // 3. Render Final GIF
        document.getElementById('btn-render-gif').onclick = async () => {
             if(generatedFrames.length === 0) return;
             if(!gifLibLoaded) return alert("GIF åº“å°šæœªåŠ è½½ï¼Œè¯·ç¨å€™...");
             
             const btn = document.getElementById('btn-render-gif');
             const status = document.getElementById('gif-status');
             const progressContainer = document.getElementById('gif-progress-container');
             const progressBar = document.getElementById('gif-progress-bar');
             const progressText = document.getElementById('gif-progress-text');

             btn.disabled = true;
             btn.innerText = "ç”Ÿæˆä¸­...";
             status.innerText = "å¼€å§‹æ¸²æŸ“ GIF...";
             
             // Reset & Show Progress
             progressContainer.style.display = 'block';
             progressBar.style.width = '0%';
             progressText.innerText = '0%';

             try {
                 const delay = parseInt(document.getElementById('gif-delay').value);
                 
                 // Initialize GIF Encoder with local worker
                 const gif = new GIF({
                    workers: 2,
                    quality: 10,
                    workerScript: '../js/workers/gif.worker.js'
                 });
                 
                 // Progress Event
                 gif.on('progress', function(p) {
                    const pct = Math.round(p * 100);
                    progressBar.style.width = pct + '%';
                    progressText.innerText = `æ¸²æŸ“ä¸­... ${pct}%`;
                 });

                 // Add frames from generated list
                 for(let i=0; i<generatedFrames.length; i++) {
                     const frame = generatedFrames[i];
                     const img = new Image();
                     await new Promise((resolve) => {
                         img.onload = resolve;
                         img.onerror = resolve; 
                         img.src = frame.url;
                     });
                     
                     if(img.width > 0) {
                         gif.addFrame(img, {delay: delay});
                     }
                 }
                 
                 status.innerText = "ç¼–ç  GIF ä¸­ (å¯èƒ½éœ€è¦å‡ ç§’)...";
                 
                 gif.on('finished', function(blob) {
                    const url = URL.createObjectURL(blob);
                    const imgGif = document.getElementById('img-gif');
                    imgGif.src = url;
                    imgGif.style.display = 'block';
                    
                    updateDownload(url, 'glitch.gif');
                    btn.disabled = false;
                    btn.innerText = "ğŸ¬ å¯¼å‡º GIF";
                    status.innerText = "å®Œæˆ!";
                    
                    // Hide Progress after delay
                    setTimeout(() => {
                        progressContainer.style.display = 'none';
                    }, 2000);
                 });
                 
                 gif.render();
                 
             } catch (e) {
                 console.error(e);
                 alert('GIF ç”Ÿæˆå¤±è´¥: ' + e.message);
                 btn.disabled = false;
                 btn.innerText = "ğŸ¬ å¯¼å‡º GIF";
                 status.innerText = "å‡ºé”™";
                 progressContainer.style.display = 'none';
             }
        };

        // --- Utils ---
        document.getElementById('btn-render').onclick = renderLayerGlitch;
        
        document.getElementById('btn-random').onclick = () => {
            document.getElementById('rgb-amount').value = Math.random() * 50;
            document.getElementById('slice-amount').value = Math.random() * 20;
            document.getElementById('slice-offset').value = Math.random() * 100;
            updateVal('val-rgb', parseInt(document.getElementById('rgb-amount').value));
            updateVal('val-slice', parseInt(document.getElementById('slice-amount').value));
            updateVal('val-slice-o', parseInt(document.getElementById('slice-offset').value));
            renderLayerGlitch();
        };

        function updateDownload(url, filename) {
            const btn = document.getElementById('btn-download');
            btn.style.display = 'flex';
            btn.href = url;
            btn.download = filename || `glitch_${Date.now()}.jpg`;
        }
    </script>
</body>
</html>
