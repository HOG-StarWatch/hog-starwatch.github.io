<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ–‡ä»¶å¤„ç†</title>
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <div class="workspace" style="flex-direction: column;">
        <div class="sub-tab-group">
            <div class="sub-tab active" onclick="fileTool.switchSubTab('zip', this)">ZIP æ‰“åŒ…</div>
            <div class="sub-tab" onclick="fileTool.switchSubTab('corrupt', this)">æ–‡ä»¶ç ´å</div>
        </div>

        <!-- External Tool Container (Iframe) -->
        <div id="external-tool-container" style="display:none; flex:1; width:100%; height:100%; overflow:hidden; border-radius: var(--radius-lg); background: var(--bg-panel); border: 1px solid var(--border);">
            <iframe id="tool-frame" style="width:100%; height:100%; border:none; background: transparent;"></iframe>
        </div>

        <div class="workspace" id="inline-workspace">
            <div class="panel">
                <!-- ZIP Pack SubTab -->
                <div id="file-zip-view">
                    <div class="panel-header">
                        <div class="panel-title">æ–‡ä»¶æ‰“åŒ… (ZIP Archiver)</div>
                    </div>
                    <div style="padding: 2rem; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 2rem; height: 100%;">
                        
                        <div class="upload-area" id="drop-zone">
                            <div style="font-size: 3rem; margin-bottom: 1rem;">ğŸ“¦</div>
                            <div style="font-size: 1.2rem; font-weight: 600; margin-bottom: 0.5rem;">ç‚¹å‡»æˆ–æ‹–æ‹½æ–‡ä»¶/æ–‡ä»¶å¤¹åˆ°æ­¤å¤„</div>
                            <div style="color: var(--text-dim); font-size: 0.9rem;">æ”¯æŒå¤šæ–‡ä»¶é€‰æ‹©ï¼Œå°†è‡ªåŠ¨æ‰“åŒ…ä¸º ZIP</div>
                            <input type="file" id="file-picker" multiple style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer;" onchange="fileTool.handleFiles(this.files)">
                        </div>

                        <div id="file-list" style="width: 100%; max-width: 500px; max-height: 200px; overflow-y: auto; display: none; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 1rem;">
                            <!-- File items will be added here -->
                        </div>

                        <div id="file-options" style="width: 100%; max-width: 500px; display: none; flex-direction: column; gap: 1rem;">
                            <div class="input-row">
                                <label>å‹ç¼©çº§åˆ«:</label>
                                <select id="zip-level">
                                    <option value="STORE">ä»…å­˜å‚¨ (ä¸å‹ç¼©, æœ€å¿«)</option>
                                    <option value="DEFLATE_1">å¿«é€Ÿå‹ç¼© (Level 1)</option>
                                    <option value="DEFLATE_5" selected>æ ‡å‡†å‹ç¼© (Level 5)</option>
                                    <option value="DEFLATE_9">æœ€å¤§å‹ç¼© (Level 9, æœ€æ…¢)</option>
                                </select>
                            </div>
                            <div class="input-row">
                                <label>æ–‡ä»¶å:</label>
                                <input type="text" id="zip-name" value="archive.zip" placeholder="archive.zip">
                            </div>
                            <button class="btn btn-primary" style="justify-content: center; padding: 1rem;" onclick="fileTool.createZip()">
                                <span id="zip-btn-text">å¼€å§‹æ‰“åŒ…ä¸‹è½½</span>
                            </button>
                        </div>

                    </div>
                </div>

                <!-- File Corrupt SubTab -->
                <div id="file-corrupt-view" style="display:none; height:100%; flex-direction:column;">
                    <div class="panel-header">
                        <div class="panel-title">æ–‡ä»¶ç ´å (File Corruptor)</div>
                        <div class="panel-actions">
                             <button class="btn btn-icon" onclick="fileTool.clearCorrupt()">æ¸…ç©º</button>
                        </div>
                    </div>
                    <div style="padding:1rem; flex:1; display:flex; flex-direction:column; gap:1rem; overflow:hidden;">
                        <div class="upload-area" id="corrupt-drop-zone">
                             <div style="margin-bottom:1rem; font-size:3rem;">ğŸ—‘ï¸</div>
                             <div style="font-size: 1.2rem; font-weight: 600; margin-bottom: 0.5rem;">æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„ æˆ– ç‚¹å‡»é€‰æ‹©</div>
                             <div style="color: var(--text-dim); font-size: 0.9rem;">è­¦å‘Šï¼šæ­¤æ“ä½œä¸å¯é€†ï¼ˆè™½ç„¶è¿™é‡Œåªæ˜¯ç”Ÿæˆå‰¯æœ¬ï¼‰ï¼Œè¯·è°¨æ…ä½¿ç”¨</div>
                             <input type="file" id="corrupt-file-input" style="position:absolute; top:0; left:0; width:100%; height:100%; opacity:0; cursor:pointer;" onchange="fileTool.handleCorruptFile(this.files[0])">
                        </div>
                        
                        <div id="corrupt-settings" style="display:none; flex-direction:column; gap:1.5rem; max-width: 600px; margin: 0 auto; width: 100%;">
                             <div class="info-row" style="display:flex; justify-content:space-between; align-items:center; padding: 1rem; background: rgba(0,0,0,0.2); border-radius: 8px;">
                                <span id="corrupt-file-name" style="font-weight:bold;">Filename.ext</span>
                                <span id="corrupt-file-size" style="color:var(--text-dim);">0 KB</span>
                             </div>
                             
                             <div class="input-row">
                                <label>ç ´åæ¨¡å¼:</label>
                                <select id="corrupt-mode">
                                    <option value="random">éšæœºå­—èŠ‚æ›¿æ¢ (Random Noise)</option>
                                    <option value="zero">æ¸…é›¶ (Zero Fill)</option>
                                    <option value="header">ä»…å¤´éƒ¨ç ´å (Header Only)</option>
                                    <option value="scramble">å±€éƒ¨ä¹±åº (Shuffle)</option>
                                </select>
                             </div>
                             
                             <div class="input-row" style="flex-direction: column; align-items: flex-start; gap: 0.5rem;">
                                <div style="display: flex; justify-content: space-between; width: 100%;">
                                    <label>ç ´åç¨‹åº¦ (Intensity):</label>
                                    <span id="corrupt-val" style="font-weight: bold; color: var(--primary);">5%</span>
                                </div>
                                <input type="range" id="corrupt-amount" min="1" max="100" value="5" style="width: 100%;" oninput="document.getElementById('corrupt-val').innerText = this.value + '%'">
                             </div>
                             
                             <button class="btn btn-primary" style="justify-content: center; padding: 1rem;" onclick="fileTool.execCorrupt()">â˜ ï¸ å¼€å§‹ç ´åå¹¶ä¸‹è½½</button>
                        </div>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <div id="toast" class="toast">æ“ä½œæˆåŠŸ</div>
    <script src="../js/app.js"></script>
    <script src="../js/loader.js"></script>
    <script>
        const fileTool = {
            files: [],
            corruptFileObj: null,
            
            switchSubTab: function(id, el) {
                document.querySelectorAll('.sub-tab').forEach(t => t.classList.remove('active'));
                el.classList.add('active');
                
                document.getElementById('file-zip-view').style.display = 'none';
                document.getElementById('file-corrupt-view').style.display = 'none';
                
                const view = document.getElementById(`file-${id}-view`);
                if (view) {
                    if(id === 'corrupt') {
                        view.style.display = 'flex';
                    } else {
                        view.style.display = 'block';
                    }
                }
            },

            handleFiles: function(fileList) {
                this.files = Array.from(fileList);
                this.updateUI();
            },

            updateUI: function() {
                const listEl = document.getElementById('file-list');
                const optsEl = document.getElementById('file-options');
                const dropEl = document.getElementById('drop-zone');
                
                if (this.files.length > 0) {
                    listEl.style.display = 'block';
                    optsEl.style.display = 'flex';
                    dropEl.style.display = 'none'; 
                    
                    listEl.innerHTML = '';
                    this.files.forEach((f, index) => {
                        const item = document.createElement('div');
                        item.style.cssText = 'display:flex; justify-content:space-between; padding:8px; border-bottom:1px solid rgba(255,255,255,0.1); font-size:0.9rem;';
                        item.innerHTML = `
                            <span style="overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${f.name}</span>
                            <span style="color:var(--text-dim); margin-left:10px;">${(f.size/1024).toFixed(1)} KB</span>
                        `;
                        listEl.appendChild(item);
                    });
                } else {
                    listEl.style.display = 'none';
                    optsEl.style.display = 'none';
                    dropEl.style.display = 'block';
                }
            },

            createZip: async function() {
                if (this.files.length === 0) return;
                
                app.showToast('æ­£åœ¨åŠ è½½ç»„ä»¶...', 'info');
                ResourceLoader.loadDeps('@file-export').then(async () => {
                    const btnText = document.getElementById('zip-btn-text');
                    const originalText = btnText.innerText;
                    btnText.innerText = "æ­£åœ¨æ‰“åŒ…...";
                    
                    try {
                        const zip = new JSZip();
                        const levelMap = {
                            'STORE': { level: 0 },
                            'DEFLATE_1': { level: 1 },
                            'DEFLATE_5': { level: 5 },
                            'DEFLATE_9': { level: 9 }
                        };
                        
                        const levelKey = document.getElementById('zip-level').value;
                        const compression = levelKey === 'STORE' ? 'STORE' : 'DEFLATE';
                        const compressionOptions = levelKey === 'STORE' ? null : levelMap[levelKey];

                        // Add files
                        this.files.forEach(file => {
                            const path = file.webkitRelativePath || file.name;
                            zip.file(path, file);
                        });

                        const blob = await zip.generateAsync({
                            type: "blob",
                            compression: compression,
                            compressionOptions: compressionOptions
                        }, (metadata) => {
                            btnText.innerText = `æ‰“åŒ…ä¸­ ${metadata.percent.toFixed(0)}%`;
                        });

                        const filename = document.getElementById('zip-name').value || "archive.zip";
                        saveAs(blob, filename);
                        
                        app.showToast('æ‰“åŒ…å®Œæˆï¼Œå·²å¼€å§‹ä¸‹è½½');
                    } catch (e) {
                        app.showToast('æ‰“åŒ…å¤±è´¥: ' + e.message, 'error');
                        console.error(e);
                    } finally {
                        btnText.innerText = originalText;
                    }
                });
            },
            
            // --- File Corruptor Logic ---
            handleCorruptFile: function(file) {
                if(!file) return;
                this.corruptFileObj = file;
                document.getElementById('corrupt-drop-zone').style.display = 'none';
                document.getElementById('corrupt-settings').style.display = 'flex';
                document.getElementById('corrupt-file-name').innerText = file.name;
                document.getElementById('corrupt-file-size').innerText = (file.size / 1024).toFixed(2) + ' KB';
            },

            clearCorrupt: function() {
                this.corruptFileObj = null;
                document.getElementById('corrupt-drop-zone').style.display = 'block';
                document.getElementById('corrupt-settings').style.display = 'none';
                document.getElementById('corrupt-file-input').value = '';
            },

            execCorrupt: async function() {
                if(!this.corruptFileObj) return;
                
                const file = this.corruptFileObj;
                const mode = document.getElementById('corrupt-mode').value;
                const amount = parseInt(document.getElementById('corrupt-amount').value) / 100; // 0.01 - 1.0
                
                app.showToast('æ­£åœ¨åŠ è½½ç»„ä»¶...', 'info');
                try {
                    await ResourceLoader.loadDeps('file-saver');
                } catch (e) {
                    app.showToast('ç»„ä»¶åŠ è½½å¤±è´¥', 'error');
                    return;
                }

                app.showToast('æ­£åœ¨ç ´åæ–‡ä»¶...', 'info');

                try {
                    const buf = await file.arrayBuffer();
                    // Copy buffer to avoid modifying original (though arrayBuffer is new copy usually)
                    const bytes = new Uint8Array(buf); 
                    const len = bytes.length;
                    
                    if(mode === 'header') {
                        // Corrupt first 1KB or 10%
                        const limit = Math.min(len, 1024);
                        // Header corruption needs to be dense to be effective
                        for(let i=0; i<limit; i++) {
                            if(Math.random() < Math.max(0.1, amount)) { 
                                bytes[i] = Math.floor(Math.random() * 256);
                            }
                        }
                    } else if (mode === 'scramble') {
                        // Swap bytes randomly
                        const totalSwaps = Math.floor(len * amount);
                        for(let i=0; i<totalSwaps; i++) {
                            const idx1 = Math.floor(Math.random() * len);
                            const idx2 = Math.floor(Math.random() * len);
                            const temp = bytes[idx1];
                            bytes[idx1] = bytes[idx2];
                            bytes[idx2] = temp;
                        }
                    } else {
                        // Random or Zero
                        const totalDamage = Math.floor(len * amount);
                        for(let i=0; i<totalDamage; i++) {
                            const idx = Math.floor(Math.random() * len);
                            if(mode === 'zero') {
                                bytes[idx] = 0;
                            } else {
                                bytes[idx] = Math.floor(Math.random() * 256);
                            }
                        }
                    }
                    
                    const blob = new Blob([bytes], {type: file.type});
                    saveAs(blob, "corrupted_" + file.name);
                    app.showToast('æ–‡ä»¶å·²ç ´åå¹¶ä¸‹è½½');
                } catch(e) {
                    app.showToast('å¤„ç†å¤±è´¥: ' + e.message, 'error');
                    console.error(e);
                }
            }
        };
    </script>
</body>
</html>
