<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG ÁîªÊùø</title>
    <link rel="stylesheet" href="../css/style.css">
    <script src="../js/app.js"></script>
    <style> body{margin:0;padding:0;display:flex;flex-direction:column;height:100vh;overflow:hidden} .controls{display:flex;flex-direction:column;gap:15px;align-items:stretch;max-width:100%;height:100%} .canvas-container{display:grid;place-items:center;background:rgba(0,0,0,0.2);border-radius:var(--radius-md);overflow:auto;border:1px dashed var(--border);height:100%;width:100%} #svg-canvas{background:white;box-shadow:0 0 20px rgba(0,0,0,0.3);cursor:crosshair;min-width:512px;min-height:512px} .color-picker-wrapper{display:flex;align-items:center;justify-content:space-between;gap:5px} .tool-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px} .tool-btn.active{background:var(--secondary);color:var(--bg-deep)} </style>
</head>
<body>
    <div class="panel-header">
        <div class="panel-title">SVG Áü¢ÈáèÁîªÊùø</div>
        <div class="panel-actions">
            <button class="btn btn-secondary" onclick="window.location.href='image-drawing.html'">ËøîÂõûËâ≤ÊùøËΩ¨Êç¢</button>
        </div>
    </div>

    <div class="layout-sidebar">
        <div class="controls panel">
            <div class="color-picker-wrapper">
                <span>ÊèèËæπ:</span>
                <input type="color" id="stroke-color" value="#000000">
            </div>
            <div class="color-picker-wrapper">
                <span>Â°´ÂÖÖ:</span>
                <div style="display:flex; align-items:center; gap:5px;">
                    <input type="color" id="fill-color" value="#ffffff">
                    <label style="font-size:0.8rem;"><input type="checkbox" id="enable-fill"> ÂêØÁî®</label>
                </div>
            </div>
            <div class="color-picker-wrapper">
                <span>Á≤óÁªÜ:</span>
                <div style="display:flex; align-items:center; gap:5px; flex:1; justify-content:flex-end;">
                    <input type="range" id="stroke-width" min="1" max="50" value="3" style="width:100px">
                    <span id="width-val" style="width:20px; text-align:right;">3</span>
                </div>
            </div>
            <div class="color-picker-wrapper">
                <span>ÈÄèÊòéÂ∫¶:</span>
                <div style="display:flex; align-items:center; gap:5px; flex:1; justify-content:flex-end;">
                    <input type="range" id="opacity" min="0" max="100" value="100" style="width:100px">
                    <span id="opacity-val" style="width:35px; text-align:right;">100%</span>
                </div>
            </div>
            <div class="color-picker-wrapper">
                <span>Á¨îËß¶:</span>
                <select id="line-cap" style="background:var(--bg-deep); color:var(--text-main); border:1px solid var(--border); border-radius:4px; padding:2px;">
                    <option value="round">ÂúÜÂ§¥</option>
                    <option value="square">ÊñπÂ§¥</option>
                    <option value="butt">Âπ≥Â§¥</option>
                </select>
            </div>
            
            <div style="width:100%; height:1px; background:var(--border); margin:5px 0;"></div>

            <div class="color-picker-wrapper">
                <span>ËæÖÂä©:</span>
                <div style="display:flex; align-items:center; gap:5px; flex:1; justify-content:flex-end;">
                    <label style="font-size:0.8rem; display:flex; align-items:center;"><input type="checkbox" id="show-grid" onchange="toggleGrid()"> ÁΩëÊ†º</label>
                    <label style="font-size:0.8rem; display:flex; align-items:center;"><input type="checkbox" id="snap-grid"> Âê∏ÈôÑ</label>
                    <input type="number" id="grid-size" value="20" min="5" max="100" style="width:35px; font-size:0.8rem; padding:0;" onchange="updateGrid()" title="ÁΩëÊ†ºÂ§ßÂ∞è">
                </div>
            </div>
            
            <div class="tool-grid">
                <button class="btn btn-primary tool-btn active" onclick="setMode('path', this)">‚úèÔ∏è Ëá™Áî±Á¨î</button>
                <button class="btn tool-btn" onclick="setMode('line', this)">üìè Áõ¥Á∫ø</button>
                <button class="btn tool-btn" onclick="setMode('rect', this)">‚¨ú Áü©ÂΩ¢</button>
                <button class="btn tool-btn" onclick="setMode('circle', this)">‚≠ï ÂúÜÂΩ¢</button>
                <button class="btn tool-btn" onclick="setMode('ellipse', this)">ü•ö Ê§≠ÂúÜ</button>
                <button class="btn tool-btn" onclick="setMode('text', this)">T ÊñáÊú¨</button>
                <button class="btn tool-btn" onclick="setMode('spray', this)">üöø Âñ∑Êû™</button>
                <button class="btn tool-btn" onclick="setMode('calligraphy', this)">‚úíÔ∏è ‰π¶Ê≥ïÁ¨î</button>
            </div>
            
            <div style="width:100%; height:1px; background:var(--border); margin:5px 0;"></div>
            
            <div class="tool-grid">
                <button class="btn btn-success" onclick="undo()">‚Ü©Ô∏è Êí§ÈîÄ</button>
                <button class="btn btn-danger" onclick="clearCanvas()">üóëÔ∏è Ê∏ÖÁ©∫</button>
            </div>
            <button class="btn btn-primary" onclick="exportSVG()" style="margin-top:auto;">üíæ ÂØºÂá∫ SVG</button>
            
            <div style="width:100%; height:1px; background:var(--border); margin:5px 0;"></div>
            
            <div style="display:flex; flex-direction:column; gap:8px;">
                <div style="display:flex; gap:5px; align-items:center;">
                    <input type="text" id="art-seed" placeholder="ÁïôÁ©∫ÂàôÈöèÊú∫" style="width:80px; font-size:0.8rem; padding:4px;">
                    <button class="btn btn-secondary" onclick="generateRandomArt()" style="flex:1; font-size:0.8rem;">üé≤ ÁîüÊàêËâ∫ÊúØ</button>
                </div>
                <div style="display:flex; justify-content:space-between; align-items:center; margin-top:2px;">
                    <label style="font-size:0.8rem; cursor:pointer; display:flex; align-items:center; gap:5px; user-select:none;">
                        <input type="checkbox" id="clear-before-gen" checked> Ë¶ÜÁõñÊ∏ÖÁ©∫
                    </label>
                    <span id="seed-display" 
                          style="font-size:0.75rem; color:var(--text-main); background:var(--bg-deep); padding:2px 6px; border-radius:4px; border:1px solid var(--border); cursor:pointer; max-width: 100px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" 
                          title="ÁÇπÂáªÂ§çÂà∂ÂΩìÂâçÁßçÂ≠ê" 
                          onclick="copySeed()">
                    </span>
                </div>
                
                <div style="border:1px solid var(--border); border-radius:4px; padding:5px; margin-top:5px; max-height:150px; overflow-y:auto; font-size:0.8rem;">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
                        <span style="font-weight:bold;">È£éÊ†ºÁ≠õÈÄâ:</span>
                        <a href="javascript:void(0)" onclick="toggleAllStyles(this)" style="color:var(--secondary); text-decoration:none;">ÂÖ®ÈÄâ</a>
                    </div>
                    <div id="style-list" style="display:grid; grid-template-columns: 1fr 1fr; gap:2px;">
                        <!-- Styles injected by JS -->
                    </div>
                </div>
            </div>
        </div>

        <div class="canvas-container">
            <svg id="svg-canvas" width="512" height="512" xmlns="http://www.w3.org/2000/svg"></svg>
        </div>
    </div>

    <div id="toast"></div>
    <script>
        const ns = 'http://www.w3.org/2000/svg';
        const create = (t, a={}) => {
            const el = document.createElementNS(ns, t);
            Object.entries(a).forEach(([k,v]) => el.setAttribute(k, v));
            return el;
        };

        const svg = document.getElementById('svg-canvas');
        let isDrawing = false;
        let startX, startY;
        let currentElement = null;
        let mode = 'path';
        let history = [];
        let sprayInterval = null;
        let lastPos = {x: 0, y: 0};
        
        // Styles Configuration
        const styleDefs = [
            { id: 'geometric', name: 'Âá†‰Ωï' },
            { id: 'mandala', name: 'ÊõºÈôÄÁΩó' },
            { id: 'flow', name: 'ÊµÅÂÖâ' },
            { id: 'circuit', name: 'ÁîµË∑Ø' },
            { id: 'pixel', name: 'ÂÉèÁ¥†' },
            { id: 'starfield', name: 'ÊòüÁ©∫' },
            { id: 'bubbles', name: 'Ê∞îÊ≥°' },
            { id: 'waves', name: 'Ê≥¢Êµ™' },
            { id: 'memphis', name: 'Â≠üËè≤ÊñØ' },
            { id: 'fractal', name: 'ÂàÜÂΩ¢Ê†ë' },
            { id: 'maze', name: 'Ëø∑ÂÆ´' },
            { id: 'hexagons', name: 'ÂÖ≠ËæπÂΩ¢' },
            { id: 'rain', name: 'Êï∞Á†ÅÈõ®' },
            { id: 'spirals', name: 'Ëû∫Êóã' },
            { id: 'crossstitch', name: 'ÂçÅÂ≠óÁª£' }
        ];

        // Init Style List
        const styleListEl = document.getElementById('style-list');
        styleDefs.forEach(s => {
            const div = document.createElement('div');
            div.innerHTML = `<label style="cursor:pointer; display:flex; align-items:center; gap:3px;"><input type="checkbox" name="style-filter" value="${s.id}" checked> ${s.name}</label>`;
            styleListEl.appendChild(div);
        });

        function toggleAllStyles(btn) {
            const checkboxes = document.querySelectorAll('input[name="style-filter"]');
            const allChecked = Array.from(checkboxes).every(c => c.checked);
            checkboxes.forEach(c => c.checked = !allChecked);
            btn.innerText = allChecked ? 'ÂÖ®ÈÄâ' : 'ÂÖ®‰∏çÈÄâ';
        }

        // Setup Controls
        document.getElementById('stroke-width').addEventListener('input', (e) => {
            document.getElementById('width-val').innerText = e.target.value;
        });
        document.getElementById('opacity').addEventListener('input', (e) => {
            document.getElementById('opacity-val').innerText = e.target.value + '%';
        });

        function setMode(m, btn) {
            mode = m;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            if(btn) btn.classList.add('active');
            app.showToast(`ÂàáÊç¢Ê®°Âºè: ${m}`);
        }

        function toggleGrid() {
            const show = document.getElementById('show-grid').checked;
            const size = document.getElementById('grid-size').value;
            const canvas = document.getElementById('svg-canvas');
            if (show) {
                canvas.style.backgroundImage = `linear-gradient(to right, #ddd 1px, transparent 1px), linear-gradient(to bottom, #ddd 1px, transparent 1px)`;
                canvas.style.backgroundSize = `${size}px ${size}px`;
            } else {
                canvas.style.backgroundImage = 'none';
            }
        }

        function updateGrid() {
            if(document.getElementById('show-grid').checked) toggleGrid();
        }

        function getMousePos(evt) {
            const rect = svg.getBoundingClientRect();
            // Calculate scale if svg is resized by css
            const scaleX = 512 / rect.width;
            const scaleY = 512 / rect.height;
            let x = (evt.clientX - rect.left) * scaleX;
            let y = (evt.clientY - rect.top) * scaleY;

            if (document.getElementById('snap-grid').checked) {
                const size = parseInt(document.getElementById('grid-size').value) || 20;
                x = Math.round(x / size) * size;
                y = Math.round(y / size) * size;
            }
            return { x, y };
        }

        function getStyles() {
            const stroke = document.getElementById('stroke-color').value;
            const fillEnabled = document.getElementById('enable-fill').checked;
            const fill = fillEnabled ? document.getElementById('fill-color').value : 'none';
            const width = document.getElementById('stroke-width').value;
            const opacity = document.getElementById('opacity').value / 100;
            const lineCap = document.getElementById('line-cap').value;
            return { stroke, fill, width, opacity, lineCap };
        }

        svg.addEventListener('mousedown', (e) => {
            if(mode === 'text') {
                const text = prompt("ËØ∑ËæìÂÖ•ÊñáÊú¨:", "Text");
                if(text) {
                    const pos = getMousePos(e);
                    const styles = getStyles();
                    const el = create('text', {'x': pos.x, 'y': pos.y, 'fill': styles.stroke, 'font-size': styles.width * 5, 'font-family': 'Arial, sans-serif', 'opacity': styles.opacity});
                    el.textContent = text;
                    svg.appendChild(el);
                    history.push(el);
                }
                return;
            }

            isDrawing = true;
            const pos = getMousePos(e);
            startX = pos.x;
            startY = pos.y;
            lastPos = pos;
            const styles = getStyles();

            if (mode === 'spray') {
                currentElement = create('g', {'class': 'spray-group'});
                svg.appendChild(currentElement);
                
                // Start spraying
                sprayInterval = setInterval(() => {
                    if(!isDrawing) return;
                    const styles = getStyles();
                    spray(lastPos.x, lastPos.y, styles);
                }, 50);
                spray(pos.x, pos.y, styles); 
                return;
            }

            if (mode === 'calligraphy') {
                currentElement = create('g', {'fill': styles.stroke, 'opacity': styles.opacity});
                svg.appendChild(currentElement);
                // Initial dab
                drawCalligraphy(pos.x, pos.y, styles);
                return;
            }

            if (mode === 'path') {
                currentElement = create('path', {'d': `M ${startX} ${startY}`, 'fill': 'none', 'stroke-linecap': styles.lineCap, 'stroke-linejoin': 'round'});
            } else if (mode === 'line') {
                currentElement = create('line', {'x1': startX, 'y1': startY, 'x2': startX, 'y2': startY, 'fill': 'none', 'stroke-linecap': styles.lineCap});
            } else if (mode === 'rect') {
                currentElement = create('rect', {'x': startX, 'y': startY, 'width': 0, 'height': 0, 'fill': styles.fill, 'stroke-linejoin': 'round'});
            } else if (mode === 'circle') {
                currentElement = create('circle', {'cx': startX, 'cy': startY, 'r': 0, 'fill': styles.fill});
            } else if (mode === 'ellipse') {
                currentElement = create('ellipse', {'cx': startX, 'cy': startY, 'rx': 0, 'ry': 0, 'fill': styles.fill});
            }

            if(currentElement) {
                if(mode !== 'spray' && mode !== 'calligraphy') {
                    currentElement.setAttribute('stroke', styles.stroke);
                    currentElement.setAttribute('stroke-width', styles.width);
                    currentElement.setAttribute('opacity', styles.opacity);
                }
                svg.appendChild(currentElement);
            }
        });

        function drawCalligraphy(x, y, styles) {
            if(!currentElement) return;
            // Draw a slanted line at 45 degrees
            const size = styles.width;
            const angle = Math.PI / 4; // 45 deg
            const dx = Math.cos(angle) * size;
            const dy = Math.sin(angle) * size;
            
            const segment = create('line', {'x1': x - dx, 'y1': y + dy, 'x2': x + dx, 'y2': y - dy, 'stroke': styles.stroke, 'stroke-width': 2});
            
            currentElement.appendChild(segment);
        }

        function spray(x, y, styles) {
            if(!currentElement) return;
            const density = 5;
            const radius = styles.width * 2;
            
            for(let i=0; i<density; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * radius;
                const dotX = x + r * Math.cos(angle);
                const dotY = y + r * Math.sin(angle);
                
                const dot = create('circle', {'cx': dotX, 'cy': dotY, 'r': Math.random() * 1.5, 'fill': styles.stroke, 'opacity': styles.opacity});
                currentElement.appendChild(dot);
            }
        }

        svg.addEventListener('mousemove', (e) => {
            const pos = getMousePos(e);
            lastPos = pos;
            
            if (isDrawing && mode === 'spray') {
                const styles = getStyles();
                spray(pos.x, pos.y, styles);
                return;
            }

            if (isDrawing && mode === 'calligraphy') {
                const styles = getStyles();
                drawCalligraphy(pos.x, pos.y, styles);
                return;
            }

            if (!isDrawing || !currentElement) return;

            let targetX = pos.x;
            let targetY = pos.y;

            // Shift Constraints
            if (e.shiftKey) {
                if (mode === 'line') {
                    const dx = targetX - startX;
                    const dy = targetY - startY;
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    const snapAngle = Math.round(angle / 45) * 45;
                    const rad = snapAngle * Math.PI / 180;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    targetX = startX + Math.cos(rad) * dist;
                    targetY = startY + Math.sin(rad) * dist;
                } else if (mode === 'rect') {
                    const w = Math.abs(targetX - startX);
                    const h = Math.abs(targetY - startY);
                    const size = Math.max(w, h);
                    targetX = startX + (targetX > startX ? size : -size);
                    targetY = startY + (targetY > startY ? size : -size);
                } else if (mode === 'ellipse') {
                    const rx = Math.abs(targetX - startX);
                    const ry = Math.abs(targetY - startY);
                    const r = Math.max(rx, ry);
                    targetX = startX + (targetX > startX ? r : -r);
                    targetY = startY + (targetY > startY ? r : -r);
                }
            }

            if (mode === 'path') {
                const d = currentElement.getAttribute('d');
                currentElement.setAttribute('d', `${d} L ${pos.x} ${pos.y}`);
            } else if (mode === 'line') {
                currentElement.setAttribute('x2', targetX);
                currentElement.setAttribute('y2', targetY);
            } else if (mode === 'rect') {
                const w = targetX - startX;
                const h = targetY - startY;
                currentElement.setAttribute('x', w < 0 ? targetX : startX);
                currentElement.setAttribute('y', h < 0 ? targetY : startY);
                currentElement.setAttribute('width', Math.abs(w));
                currentElement.setAttribute('height', Math.abs(h));
            } else if (mode === 'circle') {
                const r = Math.sqrt(Math.pow(pos.x - startX, 2) + Math.pow(pos.y - startY, 2));
                currentElement.setAttribute('r', r);
            } else if (mode === 'ellipse') {
                currentElement.setAttribute('rx', Math.abs(targetX - startX));
                currentElement.setAttribute('ry', Math.abs(targetY - startY));
            }
        });

        svg.addEventListener('mouseup', () => {
            if (isDrawing) {
                if(sprayInterval) clearInterval(sprayInterval);
                if(currentElement) history.push(currentElement);
            }
            isDrawing = false;
            currentElement = null;
        });

        svg.addEventListener('mouseleave', () => {
            if (isDrawing) {
                 if(sprayInterval) clearInterval(sprayInterval);
                 if(currentElement) history.push(currentElement);
            }
            isDrawing = false;
            currentElement = null;
        });

        function undo() {
            if (history.length > 0) {
                const el = history.pop();
                svg.removeChild(el);
            }
        }

        function clearCanvas() {
            if(confirm('Á°ÆÂÆöÊ∏ÖÁ©∫ÁîªÊùøÂêóÔºü')) {
                svg.innerHTML = '';
                history = [];
            }
        }

        function exportSVG() {
            const serializer = new XMLSerializer();
            let source = serializer.serializeToString(svg);
            // Add xml declaration
            source = '<?xml version="1.0" standalone="no"?>\r\n' + source;
            
            const url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);
            const a = document.createElement('a');
            a.href = url;
            a.download = `drawing-${Date.now()}.svg`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            app.showToast('SVG Â∑≤ÂØºÂá∫');
        }

        function copySeed() {
            const seedText = document.getElementById('seed-display').innerText;
            if(seedText) {
                const val = seedText.split(': ')[1];
                if(val) {
                    navigator.clipboard.writeText(val);
                    app.showToast('ÁßçÂ≠êÂ∑≤Â§çÂà∂: ' + val);
                }
            }
        }

        function generateRandomArt() {
            // 1. Handle Canvas Clearing
            const shouldClear = document.getElementById('clear-before-gen').checked;
            if (shouldClear) {
                svg.innerHTML = '';
                history = [];
            }

            // 2. Seed Processing
            const seedInput = document.getElementById('art-seed');
            let seedVal = seedInput.value.trim();
            
            // If empty, use random, but DON'T fill input (so next click is random again)
            if (!seedVal) {
                seedVal = Math.random().toString(36).substring(2, 8).toUpperCase();
            }
            
            // Display seed
            document.getElementById('seed-display').innerText = `ÁßçÂ≠ê: ${seedVal}`;

            // Hash function (cyrb53)
            const cyrb53 = function(str, seed = 0) {
                let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
                for (let i = 0, ch; i < str.length; i++) {
                    ch = str.charCodeAt(i);
                    h1 = Math.imul(h1 ^ ch, 2654435761);
                    h2 = Math.imul(h2 ^ ch, 1597334677);
                }
                h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);
                h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);
                return 4294967296 * (2097151 & h2) + (h1 >>> 0);
            };

            const seedHash = cyrb53(seedVal);

            // PRNG (Mulberry32)
            const random = (function(a) {
                return function() {
                  var t = a += 0x6D2B79F5;
                  t = Math.imul(t ^ t >>> 15, t | 1);
                  t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                  return ((t ^ t >>> 14) >>> 0) / 4294967296;
                }
            })(seedHash);

            // Helper: Random Range
            const randRange = (min, max) => min + random() * (max - min);
            const randInt = (min, max) => Math.floor(randRange(min, max));
            const randChoice = (arr) => arr[Math.floor(random() * arr.length)];
            const chance = (prob) => random() < prob;

            // 3. Palette Generator
            const generatePalette = () => {
                const hue = randInt(0, 360);
                const scheme = randChoice(['complementary', 'analogous', 'triadic', 'split']);
                const palette = [];
                
                const addColor = (h, s, l) => {
                    palette.push(`hsl(${h % 360}, ${s}%, ${l}%)`);
                };

                // Base color
                const s = randInt(60, 90);
                const l = randInt(40, 60);
                addColor(hue, s, l);

                if (scheme === 'complementary') {
                    addColor(hue + 180, s, l);
                    addColor(hue, s - 20, l + 20);
                    addColor(hue + 180, s - 20, l - 10);
                } else if (scheme === 'analogous') {
                    addColor(hue + 30, s, l);
                    addColor(hue - 30, s, l);
                    addColor(hue + 60, s - 10, l + 10);
                } else if (scheme === 'triadic') {
                    addColor(hue + 120, s, l);
                    addColor(hue + 240, s, l);
                    addColor(hue, s - 30, l + 30);
                } else { // split
                    addColor(hue + 150, s, l);
                    addColor(hue + 210, s, l);
                    addColor(hue, s - 10, l + 30);
                }
                // Add a dark and a light neutral
                palette.push(`hsl(${hue}, 10%, 90%)`);
                palette.push(`hsl(${hue}, 20%, 20%)`);
                return palette;
            };

            const palette = generatePalette();
            
            // Filter styles
            const selectedStyles = Array.from(document.querySelectorAll('input[name="style-filter"]:checked')).map(cb => cb.value);
            if (selectedStyles.length === 0) {
                app.showToast('ËØ∑Ëá≥Â∞ëÈÄâÊã©‰∏ÄÁßçÈ£éÊ†º');
                return;
            }
            
            const style = randChoice(selectedStyles);
            const width = 512;
            const height = 512;

            // 4. Generators
            const generators = {
                geometric: () => {
                    // Recursive subdivision (Bauhaus style)
                    const maxDepth = 4;
                    
                    if (shouldClear) {
                        const bg = create('rect', {'width': width, 'height': height, 'fill': '#f0f0f0'});
                        svg.appendChild(bg);
                    }

                    const drawRect = (x, y, w, h, depth) => {
                        if (depth >= maxDepth || (chance(0.3) && depth > 1)) {
                            const color = randChoice(palette);
                            const el = create('rect', {'x': x, 'y': y, 'width': w, 'height': h, 'fill': color, 'stroke': '#333', 'stroke-width': 2});
                            svg.appendChild(el);
                            
                            // Add detail?
                            if (chance(0.3) && w > 40 && h > 40) {
                                const type = randChoice(['circle', 'lines']);
                                if (type === 'circle') {
                                    const c = create('circle', {'cx': x + w/2, 'cy': y + h/2, 'r': Math.min(w, h)/3, 'fill': randChoice(palette)});
                                    svg.appendChild(c);
                                }
                            }
                            return;
                        }

                        // Split
                        const splitVert = random() > 0.5;
                        if (splitVert) {
                            const split = w * randRange(0.3, 0.7);
                            drawRect(x, y, split, h, depth + 1);
                            drawRect(x + split, y, w - split, h, depth + 1);
                        } else {
                            const split = h * randRange(0.3, 0.7);
                            drawRect(x, y, w, split, depth + 1);
                            drawRect(x, y + split, w, h - split, depth + 1);
                        }
                    };
                    
                    drawRect(10, 10, width-20, height-20, 0);
                },
                
                mandala: () => {
                    // Radial symmetry
                    const cx = width / 2;
                    const cy = height / 2;
                    const rings = randInt(5, 12);
                    
                    if (shouldClear) {
                        const bg = create('rect', {'width': width, 'height': height, 'fill': palette[palette.length-1]});
                        svg.appendChild(bg);
                    }

                    for (let r = rings; r > 0; r--) {
                        const radius = (width / 2) * (r / rings);
                        const points = randInt(6, 24);
                        const shape = randChoice(['circle', 'petal', 'triangle']);
                        const color = palette[r % palette.length];
                        
                        const g = create('g');
                        svg.appendChild(g);

                        for (let i = 0; i < points; i++) {
                            const angle = (i / points) * Math.PI * 2;
                            const x = cx + Math.cos(angle) * radius * 0.8;
                            const y = cy + Math.sin(angle) * radius * 0.8;
                            
                            let el;
                            if (shape === 'circle') {
                                el = create('circle', {'cx': x, 'cy': y, 'r': radius * 0.2});
                            } else if (shape === 'triangle') {
                                el = create('polygon');
                                const s = radius * 0.2;
                                const pts = `${x},${y-s} ${x-s},${y+s} ${x+s},${y+s}`;
                                el.setAttribute('points', pts);
                                el.setAttribute('transform', `rotate(${(angle * 180 / Math.PI) + 90}, ${x}, ${y})`);
                            } else {
                                // Petal (Ellipse)
                                el = create('ellipse', {'cx': x, 'cy': y, 'rx': radius * 0.1, 'ry': radius * 0.3, 'transform': `rotate(${(angle * 180 / Math.PI) + 90}, ${x}, ${y})`});
                            }
                            
                            el.setAttribute('fill', color);
                            el.setAttribute('opacity', 0.8);
                            g.appendChild(el);
                        }
                    }
                },
                
                flow: () => {
                    // Flowing lines
                    if (shouldClear) {
                        const bg = create('rect', {'width': width, 'height': height, 'fill': '#111'});
                        svg.appendChild(bg);
                    }

                    const lines = randInt(50, 100);
                    const steps = 20;
                    
                    for(let i=0; i<lines; i++) {
                        const path = create('path');
                        let d = `M ${randRange(0, width)} ${randRange(0, height)}`;
                        let x = randRange(0, width);
                        let y = randRange(0, height);
                        
                        // Create a smooth curve
                        for(let s=0; s<steps; s++) {
                             const angle = (x / width) * Math.PI * 4 + (y / height) * Math.PI * 4;
                             x += Math.cos(angle) * 20;
                             y += Math.sin(angle) * 20;
                             d += ` L ${x} ${y}`;
                        }
                        
                        path.setAttribute('d', d);
                        path.setAttribute('fill', 'none');
                        path.setAttribute('stroke', randChoice(palette));
                        path.setAttribute('stroke-width', randRange(1, 4));
                        path.setAttribute('opacity', randRange(0.3, 0.8));
                        svg.appendChild(path);
                    }
                },

                circuit: () => {
                    // Circuit board style
                    if (shouldClear) {
                        const bg = create('rect', {'width': width, 'height': height, 'fill': '#002'});
                        svg.appendChild(bg);
                    }
                    
                    const gridSize = 32;
                    const cols = Math.floor(width / gridSize);
                    const rows = Math.floor(height / gridSize);
                    const traces = randInt(20, 50);
                    
                    for(let i=0; i<traces; i++) {
                        let cx = randInt(1, cols-1) * gridSize;
                        let cy = randInt(1, rows-1) * gridSize;
                        const len = randInt(5, 15);
                        let points = [[cx, cy]];
                        let dir = randInt(0, 4); // 0:R, 1:D, 2:L, 3:U
                        
                        for(let j=0; j<len; j++) {
                            if(chance(0.3)) dir = (dir + (chance(0.5)?1:3)) % 4;
                            if(dir === 0) cx += gridSize;
                            else if(dir === 1) cy += gridSize;
                            else if(dir === 2) cx -= gridSize;
                            else cy -= gridSize;
                            
                            // Clamp
                            cx = Math.max(0, Math.min(width, cx));
                            cy = Math.max(0, Math.min(height, cy));
                            points.push([cx, cy]);
                        }
                        
                        const polyline = create('polyline', {'points': points.map(p => p.join(',')).join(' '), 'fill': 'none', 'stroke': randChoice(palette), 'stroke-width': 2, 'stroke-linecap': 'round', 'stroke-linejoin': 'round', 'opacity': 0.8});
                        svg.appendChild(polyline);
                        
                        // Terminals
                        const start = create('circle', {'cx': points[0][0], 'cy': points[0][1], 'r': 3, 'fill': '#fff'});
                        svg.appendChild(start);
                        
                        const end = create('circle', {'cx': points[points.length-1][0], 'cy': points[points.length-1][1], 'r': 3, 'fill': '#fff'});
                        svg.appendChild(end);
                    }
                },

                pixel: () => {
                    // Pixel art grid
                    const pSize = randChoice([16, 32, 64]);
                    const cols = Math.ceil(width / pSize);
                    const rows = Math.ceil(height / pSize);
                    
                    if (shouldClear) {
                        const bg = create('rect', {'width': width, 'height': height, 'fill': '#000'});
                        svg.appendChild(bg);
                    }
                    
                    // Symmetry?
                    const symX = chance(0.5);
                    const symY = chance(0.5);
                    
                    for(let y=0; y<rows; y++) {
                        for(let x=0; x<cols; x++) {
                            // Check symmetry
                            let srcX = x, srcY = y;
                            if(symX && x >= cols/2) srcX = cols - 1 - x;
                            if(symY && y >= rows/2) srcY = rows - 1 - y;
                            
                            // Noise based on position
                            const noise = (Math.sin(srcX*0.5) + Math.cos(srcY*0.5)) * 0.5 + 0.5;
                            
                            if (random() > 0.4) { // Sparsity
                                const rect = create('rect', {'x': x * pSize, 'y': y * pSize, 'width': pSize, 'height': pSize, 'fill': randChoice(palette), 'opacity': 0.8 + random()*0.2});
                                svg.appendChild(rect);
                            }
                        }
                    }
                },
                
                starfield: () => {
                    // Constellation / Starfield
                    if (shouldClear) {
                        const bg = create('rect', {'width': width, 'height': height, 'fill': '#0a0a1a'});
                        svg.appendChild(bg);
                    }
                    
                    const starCount = randInt(50, 100);
                    const stars = [];
                    
                    // Generate stars
                    for(let i=0; i<starCount; i++) {
                        const s = {
                            x: randRange(0, width),
                            y: randRange(0, height),
                            r: randRange(1, 3)
                        };
                        stars.push(s);
                        
                        const c = create('circle', {'cx': s.x, 'cy': s.y, 'r': s.r, 'fill': '#fff', 'opacity': randRange(0.5, 1)});
                        svg.appendChild(c);
                    }
                    
                    // Connect neighbors
                    const maxDist = 80;
                    for(let i=0; i<stars.length; i++) {
                        for(let j=i+1; j<stars.length; j++) {
                            const dx = stars[i].x - stars[j].x;
                            const dy = stars[i].y - stars[j].y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            
                            if (dist < maxDist) {
                                const line = create('line', {'x1': stars[i].x, 'y1': stars[i].y, 'x2': stars[j].x, 'y2': stars[j].y, 'stroke': randChoice(palette), 'stroke-width': (1 - dist/maxDist) * 2, 'opacity': (1 - dist/maxDist) * 0.5});
                                svg.appendChild(line);
                            }
                        }
                    }
                },

                bubbles: () => {
                    if (shouldClear) {
                        const bg = create('rect', {'width': width, 'height': height, 'fill': palette[palette.length-1]});
                        svg.appendChild(bg);
                    }
                    const count = randInt(20, 50);
                    for(let i=0; i<count; i++) {
                        const r = randRange(10, 80);
                        const cx = randRange(0, width);
                        const cy = randRange(0, height);
                        const c = create('circle', {'cx': cx, 'cy': cy, 'r': r, 'fill': randChoice(palette), 'opacity': randRange(0.2, 0.6)});
                        // Add some gradient-like stroke
                        if(chance(0.5)) {
                            c.setAttribute('stroke', '#fff');
                            c.setAttribute('stroke-width', 2);
                            c.setAttribute('stroke-opacity', 0.4);
                        }
                        svg.appendChild(c);
                    }
                },

                waves: () => {
                    if (shouldClear) {
                        const bg = create('rect', {'width': width, 'height': height, 'fill': palette[palette.length-1]});
                        svg.appendChild(bg);
                    }
                    const layers = randInt(5, 10);
                    const stepY = height / layers;
                    
                    for(let i=0; i<layers; i++) {
                        const yBase = i * stepY;
                        let d = `M 0 ${yBase + 50}`;
                        const freq = randRange(0.01, 0.05);
                        const amp = randRange(20, 50);
                        const phase = randRange(0, Math.PI*2);
                        
                        for(let x=0; x<=width; x+=10) {
                            const y = yBase + Math.sin(x * freq + phase) * amp;
                            d += ` L ${x} ${y}`;
                        }
                        d += ` L ${width} ${height} L 0 ${height} Z`;
                        
                        const path = create('path', {'d': d, 'fill': palette[i % palette.length], 'opacity': 0.7});
                        svg.appendChild(path);
                    }
                },

                memphis: () => {
                    if (shouldClear) {
                        const bg = create('rect', {'width': width, 'height': height, 'fill': '#fff'});
                        svg.appendChild(bg);
                    }
                    const count = randInt(30, 60);
                    for(let i=0; i<count; i++) {
                        const type = randChoice(['rect', 'circle', 'line', 'triangle', 'squiggle']);
                        const x = randRange(0, width);
                        const y = randRange(0, height);
                        const color = randChoice(palette);
                        const rot = randRange(0, 360);
                        
                        let el;
                        if(type === 'rect') {
                            el = create('rect', {'x': x, 'y': y, 'width': randRange(20, 60), 'height': randRange(20, 60)});
                        } else if (type === 'circle') {
                            el = create('circle', {'cx': x, 'cy': y, 'r': randRange(10, 30)});
                        } else if (type === 'triangle') {
                            el = create('polygon', {'points': '0,-20 -20,20 20,20'});
                        } else if (type === 'line') {
                            el = create('rect', {'width': randRange(40, 80), 'height': 5, 'x': x, 'y': y});
                        } else { // squiggle
                            el = create('path', {'d': 'M0,0 Q10,-20 20,0 T40,0', 'fill': 'none', 'stroke': color, 'stroke-width': 4, 'transform': `translate(${x},${y}) rotate(${rot}) scale(${randRange(1,2)})`});
                            svg.appendChild(el);
                            continue; // Special handling for path
                        }
                        
                        if(type !== 'squiggle') {
                            el.setAttribute('fill', color);
                            if(type === 'triangle') {
                                el.setAttribute('transform', `translate(${x},${y}) rotate(${rot})`);
                            } else if (type === 'rect') {
                                el.setAttribute('transform', `rotate(${rot}, ${x}, ${y})`);
                            }
                        }
                        svg.appendChild(el);
                    }
                },

                fractal: () => {
                    // Recursive Tree
                    if (shouldClear) {
                        const bg = create('rect', {'width': width, 'height': height, 'fill': '#111'});
                        svg.appendChild(bg);
                    }
                    
                    const drawBranch = (x, y, len, angle, depth) => {
                        if (depth === 0) return;
                        
                        const x2 = x + Math.cos(angle) * len;
                        const y2 = y + Math.sin(angle) * len;
                        
                        const line = create('line', {'x1': x, 'y1': y, 'x2': x2, 'y2': y2, 'stroke': palette[depth % palette.length], 'stroke-width': depth, 'stroke-linecap': 'round'});
                        svg.appendChild(line);
                        
                        // Recursive calls
                        const subLen = len * 0.7;
                        drawBranch(x2, y2, subLen, angle - 0.4, depth - 1);
                        drawBranch(x2, y2, subLen, angle + 0.4, depth - 1);
                    };
                    
                    // Start from bottom center
                    drawBranch(width/2, height, 120, -Math.PI/2, 9);
                },

                maze: () => {
                    if (shouldClear) {
                        const bg = create('rect', {'width': width, 'height': height, 'fill': '#fff'});
                        svg.appendChild(bg);
                    }
                    const cellSize = 20;
                    const cols = Math.floor(width/cellSize);
                    const rows = Math.floor(height/cellSize);
                    
                    for(let y=0; y<rows; y++) {
                        for(let x=0; x<cols; x++) {
                            const px = x * cellSize;
                            const py = y * cellSize;
                            
                            const line = create('line', {'stroke': '#000', 'stroke-width': 2, 'stroke-linecap': 'round'});
                            
                            if (chance(0.5)) {
                                // Forward slash
                                line.setAttribute('x1', px);
                                line.setAttribute('y1', py + cellSize);
                                line.setAttribute('x2', px + cellSize);
                                line.setAttribute('y2', py);
                            } else {
                                // Backslash
                                line.setAttribute('x1', px);
                                line.setAttribute('y1', py);
                                line.setAttribute('x2', px + cellSize);
                                line.setAttribute('y2', py + cellSize);
                            }
                            // Add color variation
                            if (chance(0.2)) line.setAttribute('stroke', randChoice(palette));
                            
                            svg.appendChild(line);
                        }
                    }
                },

                hexagons: () => {
                    if (shouldClear) {
                        const bg = create('rect', {'width': width, 'height': height, 'fill': '#222'});
                        svg.appendChild(bg);
                    }
                    const r = 30;
                    const h = r * Math.sqrt(3);
                    const cols = Math.ceil(width / (r * 1.5));
                    const rows = Math.ceil(height / h);
                    
                    for(let y=0; y<rows; y++) {
                        for(let x=0; x<cols; x++) {
                            const cx = x * r * 1.5;
                            const cy = y * h + (x % 2 === 0 ? 0 : h/2);
                            
                            if (chance(0.8)) {
                                const poly = create('polygon');
                                let pts = "";
                                for(let i=0; i<6; i++) {
                                    const ang = i * Math.PI / 3;
                                    pts += `${cx + r*Math.cos(ang)},${cy + r*Math.sin(ang)} `;
                                }
                                poly.setAttribute('points', pts);
                                poly.setAttribute('fill', randChoice(palette));
                                poly.setAttribute('stroke', '#111');
                                poly.setAttribute('stroke-width', 2);
                                poly.setAttribute('opacity', randRange(0.5, 0.9));
                                svg.appendChild(poly);
                            }
                        }
                    }
                },

                rain: () => {
                    // Digital Rain
                    if (shouldClear) {
                        const bg = create('rect', {'width': width, 'height': height, 'fill': '#000'});
                        svg.appendChild(bg);
                    }
                    const cols = 40;
                    const colWidth = width / cols;
                    
                    for(let i=0; i<cols; i++) {
                        const drops = randInt(5, 15);
                        const x = i * colWidth + colWidth/2;
                        
                        for(let j=0; j<drops; j++) {
                            const y = randRange(0, height);
                            const len = randRange(10, 50);
                            const text = create('text', {'x': x, 'y': y, 'fill': i%2===0 ? '#0f0' : randChoice(palette), 'font-family': 'monospace', 'font-size': randRange(10, 20), 'opacity': randRange(0.2, 0.9)});
                            // Random char
                            text.textContent = String.fromCharCode(0x30A0 + randInt(0, 96));
                            svg.appendChild(text);
                        }
                    }
                },

                spirals: () => {
                    if (shouldClear) {
                        const bg = create('rect', {'width': width, 'height': height, 'fill': palette[0]});
                        svg.appendChild(bg);
                    }
                    const cx = width/2;
                    const cy = height/2;
                    const count = 300;
                    const a = 5;
                    const b = 2;
                    
                    let pathD = `M ${cx} ${cy}`;
                    
                    for(let i=0; i<count; i++) {
                        const angle = 0.5 * i;
                        const r = a + b * angle;
                        const x = cx + r * Math.cos(angle);
                        const y = cy + r * Math.sin(angle);
                        
                        const circle = create('circle', {'cx': x, 'cy': y, 'r': i/10, 'fill': randChoice(palette)});
                        svg.appendChild(circle);
                    }
                },

                crossstitch: () => {
                     if (shouldClear) {
                        const bg = create('rect', {'width': width, 'height': height, 'fill': '#fff'});
                        svg.appendChild(bg);
                    }
                    const gridSize = 10;
                    const cols = width / gridSize;
                    const rows = height / gridSize;
                    
                    // Pattern generator
                    for(let y=0; y<rows; y++) {
                        for(let x=0; x<cols; x++) {
                            // Simple cellular automata or noise pattern
                            const noise = (Math.sin(x*0.2) * Math.cos(y*0.2));
                            if(noise > 0 || chance(0.3)) {
                                const px = x * gridSize;
                                const py = y * gridSize;
                                const color = randChoice(palette);
                                
                                const g = create('g', {'stroke': color, 'stroke-width': 2});
                                
                                const l1 = create('line', {'x1': px + 2, 'y1': py + 2, 'x2': px + gridSize - 2, 'y2': py + gridSize - 2});
                                
                                const l2 = create('line', {'x1': px + gridSize - 2, 'y1': py + 2, 'x2': px + 2, 'y2': py + gridSize - 2});
                                
                                g.appendChild(l1);
                                g.appendChild(l2);
                                svg.appendChild(g);
                            }
                        }
                    }
                }
            };

            // Run
            generators[style]();
            app.showToast(`ÁîüÊàêÂÆåÊØï: ${style}`);
        }
    </script>
</body>
</html>