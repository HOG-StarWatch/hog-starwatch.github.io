<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG ÁîªÊùø</title>
    <link rel="stylesheet" href="../css/style.css">
    <script src="../js/app.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        /* Override style.css .controls if needed, but style.css .controls is actually what we want for sidebar */
        /* Local overrides */
        .controls {
            /* Ensure it uses column layout from style.css or force it here */
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: stretch; /* Stretch to fill width */
            max-width: 100%; /* Let grid handle width */
            height: 100%; /* Fill sidebar height */
        }
        
        .canvas-container {
            display: grid;
            place-items: center;
            background: rgba(0,0,0,0.2);
            border-radius: var(--radius-md);
            overflow: auto;
            border: 1px dashed var(--border);
            height: 100%; /* Fill remaining height */
            width: 100%;
        }
        #svg-canvas {
            background: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
            cursor: crosshair;
            min-width: 512px;
            min-height: 512px;
        }
        .color-picker-wrapper {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 5px;
        }
        .tool-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        .tool-btn.active {
            background: var(--secondary);
            color: var(--bg-deep);
        }
    </style>
</head>
<body>
    <div class="panel-header">
        <div class="panel-title">SVG Áü¢ÈáèÁîªÊùø</div>
        <div class="panel-actions">
            <button class="btn btn-secondary" onclick="window.location.href='image-drawing.html'">ËøîÂõûËâ≤ÊùøËΩ¨Êç¢</button>
        </div>
    </div>

    <div class="layout-sidebar">
        <div class="controls panel">
            <div class="color-picker-wrapper">
                <span>ÊèèËæπ:</span>
                <input type="color" id="stroke-color" value="#000000">
            </div>
            <div class="color-picker-wrapper">
                <span>Â°´ÂÖÖ:</span>
                <div style="display:flex; align-items:center; gap:5px;">
                    <input type="color" id="fill-color" value="#ffffff">
                    <label style="font-size:0.8rem;"><input type="checkbox" id="enable-fill"> ÂêØÁî®</label>
                </div>
            </div>
            <div class="color-picker-wrapper">
                <span>Á≤óÁªÜ:</span>
                <div style="display:flex; align-items:center; gap:5px; flex:1; justify-content:flex-end;">
                    <input type="range" id="stroke-width" min="1" max="50" value="3" style="width:100px">
                    <span id="width-val" style="width:20px; text-align:right;">3</span>
                </div>
            </div>
            <div class="color-picker-wrapper">
                <span>ÈÄèÊòéÂ∫¶:</span>
                <div style="display:flex; align-items:center; gap:5px; flex:1; justify-content:flex-end;">
                    <input type="range" id="opacity" min="0" max="100" value="100" style="width:100px">
                    <span id="opacity-val" style="width:35px; text-align:right;">100%</span>
                </div>
            </div>
            <div class="color-picker-wrapper">
                <span>Á¨îËß¶:</span>
                <select id="line-cap" style="background:var(--bg-deep); color:var(--text-main); border:1px solid var(--border); border-radius:4px; padding:2px;">
                    <option value="round">ÂúÜÂ§¥</option>
                    <option value="square">ÊñπÂ§¥</option>
                    <option value="butt">Âπ≥Â§¥</option>
                </select>
            </div>
            
            <div style="width:100%; height:1px; background:var(--border); margin:5px 0;"></div>
            
            <div class="tool-grid">
                <button class="btn btn-primary tool-btn active" onclick="setMode('path', this)">‚úèÔ∏è Ëá™Áî±Á¨î</button>
                <button class="btn tool-btn" onclick="setMode('line', this)">üìè Áõ¥Á∫ø</button>
                <button class="btn tool-btn" onclick="setMode('rect', this)">‚¨ú Áü©ÂΩ¢</button>
                <button class="btn tool-btn" onclick="setMode('circle', this)">‚≠ï ÂúÜÂΩ¢</button>
                <button class="btn tool-btn" onclick="setMode('ellipse', this)">ü•ö Ê§≠ÂúÜ</button>
                <button class="btn tool-btn" onclick="setMode('text', this)">T ÊñáÊú¨</button>
                <button class="btn tool-btn" onclick="setMode('spray', this)">üöø Âñ∑Êû™</button>
                <button class="btn tool-btn" onclick="setMode('calligraphy', this)">‚úíÔ∏è ‰π¶Ê≥ïÁ¨î</button>
            </div>
            
            <div style="width:100%; height:1px; background:var(--border); margin:5px 0;"></div>
            
            <div class="tool-grid">
                <button class="btn btn-success" onclick="undo()">‚Ü©Ô∏è Êí§ÈîÄ</button>
                <button class="btn btn-danger" onclick="clearCanvas()">üóëÔ∏è Ê∏ÖÁ©∫</button>
            </div>
            <button class="btn btn-primary" onclick="exportSVG()" style="margin-top:auto;">üíæ ÂØºÂá∫ SVG</button>
            
            <div style="width:100%; height:1px; background:var(--border); margin:5px 0;"></div>
            
            <div style="display:flex; flex-direction:column; gap:8px;">
                <div style="display:flex; gap:5px; align-items:center;">
                    <input type="text" id="art-seed" placeholder="ÁïôÁ©∫ÂàôÈöèÊú∫" style="width:80px; font-size:0.8rem; padding:4px;">
                    <button class="btn btn-secondary" onclick="generateRandomArt()" style="flex:1; font-size:0.8rem;">üé≤ ÁîüÊàêËâ∫ÊúØ</button>
                </div>
                <div style="display:flex; justify-content:space-between; align-items:center; margin-top:2px;">
                    <label style="font-size:0.8rem; cursor:pointer; display:flex; align-items:center; gap:5px; user-select:none;">
                        <input type="checkbox" id="clear-before-gen" checked> Ë¶ÜÁõñÊ∏ÖÁ©∫
                    </label>
                    <span id="seed-display" 
                          style="font-size:0.75rem; color:var(--text-main); background:var(--bg-deep); padding:2px 6px; border-radius:4px; border:1px solid var(--border); cursor:pointer; max-width: 100px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" 
                          title="ÁÇπÂáªÂ§çÂà∂ÂΩìÂâçÁßçÂ≠ê" 
                          onclick="copySeed()">
                    </span>
                </div>
                
                <div style="border:1px solid var(--border); border-radius:4px; padding:5px; margin-top:5px; max-height:150px; overflow-y:auto; font-size:0.8rem;">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
                        <span style="font-weight:bold;">È£éÊ†ºÁ≠õÈÄâ:</span>
                        <a href="javascript:void(0)" onclick="toggleAllStyles(this)" style="color:var(--secondary); text-decoration:none;">ÂÖ®ÈÄâ</a>
                    </div>
                    <div id="style-list" style="display:grid; grid-template-columns: 1fr 1fr; gap:2px;">
                        <!-- Styles injected by JS -->
                    </div>
                </div>
            </div>
        </div>

        <div class="canvas-container">
            <svg id="svg-canvas" width="512" height="512" xmlns="http://www.w3.org/2000/svg"></svg>
        </div>
    </div>

    <div id="toast"></div>
    <script>
        const svg = document.getElementById('svg-canvas');
        let isDrawing = false;
        let startX, startY;
        let currentElement = null;
        let mode = 'path';
        let history = [];
        let sprayInterval = null;
        let lastPos = {x: 0, y: 0};
        
        // Styles Configuration
        const styleDefs = [
            { id: 'geometric', name: 'Âá†‰Ωï' },
            { id: 'mandala', name: 'ÊõºÈôÄÁΩó' },
            { id: 'flow', name: 'ÊµÅÂÖâ' },
            { id: 'circuit', name: 'ÁîµË∑Ø' },
            { id: 'pixel', name: 'ÂÉèÁ¥†' },
            { id: 'starfield', name: 'ÊòüÁ©∫' },
            { id: 'bubbles', name: 'Ê∞îÊ≥°' },
            { id: 'waves', name: 'Ê≥¢Êµ™' },
            { id: 'memphis', name: 'Â≠üËè≤ÊñØ' },
            { id: 'fractal', name: 'ÂàÜÂΩ¢Ê†ë' },
            { id: 'maze', name: 'Ëø∑ÂÆ´' },
            { id: 'hexagons', name: 'ÂÖ≠ËæπÂΩ¢' },
            { id: 'rain', name: 'Êï∞Á†ÅÈõ®' },
            { id: 'spirals', name: 'Ëû∫Êóã' },
            { id: 'crossstitch', name: 'ÂçÅÂ≠óÁª£' }
        ];

        // Init Style List
        const styleListEl = document.getElementById('style-list');
        styleDefs.forEach(s => {
            const div = document.createElement('div');
            div.innerHTML = `<label style="cursor:pointer; display:flex; align-items:center; gap:3px;"><input type="checkbox" name="style-filter" value="${s.id}" checked> ${s.name}</label>`;
            styleListEl.appendChild(div);
        });

        function toggleAllStyles(btn) {
            const checkboxes = document.querySelectorAll('input[name="style-filter"]');
            const allChecked = Array.from(checkboxes).every(c => c.checked);
            checkboxes.forEach(c => c.checked = !allChecked);
            btn.innerText = allChecked ? 'ÂÖ®ÈÄâ' : 'ÂÖ®‰∏çÈÄâ';
        }

        // Setup Controls
        document.getElementById('stroke-width').addEventListener('input', (e) => {
            document.getElementById('width-val').innerText = e.target.value;
        });
        document.getElementById('opacity').addEventListener('input', (e) => {
            document.getElementById('opacity-val').innerText = e.target.value + '%';
        });

        function setMode(m, btn) {
            mode = m;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            if(btn) btn.classList.add('active');
            app.showToast(`ÂàáÊç¢Ê®°Âºè: ${m}`);
        }

        function getMousePos(evt) {
            const rect = svg.getBoundingClientRect();
            // Calculate scale if svg is resized by css
            const scaleX = 512 / rect.width;
            const scaleY = 512 / rect.height;
            return {
                x: (evt.clientX - rect.left) * scaleX,
                y: (evt.clientY - rect.top) * scaleY
            };
        }

        function getStyles() {
            const stroke = document.getElementById('stroke-color').value;
            const fillEnabled = document.getElementById('enable-fill').checked;
            const fill = fillEnabled ? document.getElementById('fill-color').value : 'none';
            const width = document.getElementById('stroke-width').value;
            const opacity = document.getElementById('opacity').value / 100;
            const lineCap = document.getElementById('line-cap').value;
            return { stroke, fill, width, opacity, lineCap };
        }

        svg.addEventListener('mousedown', (e) => {
            if(mode === 'text') {
                const text = prompt("ËØ∑ËæìÂÖ•ÊñáÊú¨:", "Text");
                if(text) {
                    const pos = getMousePos(e);
                    const styles = getStyles();
                    const el = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    el.setAttribute('x', pos.x);
                    el.setAttribute('y', pos.y);
                    el.setAttribute('fill', styles.stroke); // Text uses fill as color usually
                    el.setAttribute('font-size', styles.width * 5); // Scale font size with stroke width
                    el.setAttribute('font-family', 'Arial, sans-serif');
                    el.setAttribute('opacity', styles.opacity);
                    el.textContent = text;
                    svg.appendChild(el);
                    history.push(el);
                }
                return;
            }

            isDrawing = true;
            const pos = getMousePos(e);
            startX = pos.x;
            startY = pos.y;
            lastPos = pos;
            const styles = getStyles();

            if (mode === 'spray') {
                currentElement = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                currentElement.setAttribute('class', 'spray-group');
                svg.appendChild(currentElement);
                
                // Start spraying
                sprayInterval = setInterval(() => {
                    if(!isDrawing) return;
                    const styles = getStyles();
                    spray(lastPos.x, lastPos.y, styles);
                }, 50);
                spray(pos.x, pos.y, styles); 
                return;
            }

            if (mode === 'calligraphy') {
                currentElement = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                currentElement.setAttribute('fill', styles.stroke);
                currentElement.setAttribute('opacity', styles.opacity);
                svg.appendChild(currentElement);
                // Initial dab
                drawCalligraphy(pos.x, pos.y, styles);
                return;
            }

            if (mode === 'path') {
                currentElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                currentElement.setAttribute('d', `M ${startX} ${startY}`);
                currentElement.setAttribute('fill', 'none'); 
                currentElement.setAttribute('stroke-linecap', styles.lineCap); // Use selected lineCap
                currentElement.setAttribute('stroke-linejoin', 'round');
            } else if (mode === 'line') {
                currentElement = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                currentElement.setAttribute('x1', startX);
                currentElement.setAttribute('y1', startY);
                currentElement.setAttribute('x2', startX);
                currentElement.setAttribute('y2', startY);
                currentElement.setAttribute('fill', 'none');
                currentElement.setAttribute('stroke-linecap', styles.lineCap);
            } else if (mode === 'rect') {
                currentElement = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                currentElement.setAttribute('x', startX);
                currentElement.setAttribute('y', startY);
                currentElement.setAttribute('width', 0);
                currentElement.setAttribute('height', 0);
                currentElement.setAttribute('fill', styles.fill);
                currentElement.setAttribute('stroke-linejoin', 'round'); // Rect corners
            } else if (mode === 'circle') {
                currentElement = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                currentElement.setAttribute('cx', startX);
                currentElement.setAttribute('cy', startY);
                currentElement.setAttribute('r', 0);
                currentElement.setAttribute('fill', styles.fill);
            } else if (mode === 'ellipse') {
                currentElement = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
                currentElement.setAttribute('cx', startX);
                currentElement.setAttribute('cy', startY);
                currentElement.setAttribute('rx', 0);
                currentElement.setAttribute('ry', 0);
                currentElement.setAttribute('fill', styles.fill);
            }

            if(currentElement) {
                if(mode !== 'spray' && mode !== 'calligraphy') {
                    currentElement.setAttribute('stroke', styles.stroke);
                    currentElement.setAttribute('stroke-width', styles.width);
                    currentElement.setAttribute('opacity', styles.opacity);
                }
                svg.appendChild(currentElement);
            }
        });

        function drawCalligraphy(x, y, styles) {
            if(!currentElement) return;
            // Draw a slanted line at 45 degrees
            const size = styles.width;
            const angle = Math.PI / 4; // 45 deg
            const dx = Math.cos(angle) * size;
            const dy = Math.sin(angle) * size;
            
            const segment = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            segment.setAttribute('x1', x - dx);
            segment.setAttribute('y1', y + dy);
            segment.setAttribute('x2', x + dx);
            segment.setAttribute('y2', y - dy);
            segment.setAttribute('stroke', styles.stroke);
            segment.setAttribute('stroke-width', 2); // Thin stroke for the nib edge
            
            currentElement.appendChild(segment);
        }

        function spray(x, y, styles) {
            if(!currentElement) return;
            const density = 5;
            const radius = styles.width * 2;
            
            for(let i=0; i<density; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * radius;
                const dotX = x + r * Math.cos(angle);
                const dotY = y + r * Math.sin(angle);
                
                const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                dot.setAttribute('cx', dotX);
                dot.setAttribute('cy', dotY);
                dot.setAttribute('r', Math.random() * 1.5);
                dot.setAttribute('fill', styles.stroke);
                dot.setAttribute('opacity', styles.opacity);
                currentElement.appendChild(dot);
            }
        }

        svg.addEventListener('mousemove', (e) => {
            const pos = getMousePos(e);
            lastPos = pos;
            
            if (isDrawing && mode === 'spray') {
                const styles = getStyles();
                spray(pos.x, pos.y, styles);
                return;
            }

            if (isDrawing && mode === 'calligraphy') {
                const styles = getStyles();
                drawCalligraphy(pos.x, pos.y, styles);
                return;
            }

            if (!isDrawing || !currentElement) return;

            if (mode === 'path') {
                const d = currentElement.getAttribute('d');
                currentElement.setAttribute('d', `${d} L ${pos.x} ${pos.y}`);
            } else if (mode === 'line') {
                currentElement.setAttribute('x2', pos.x);
                currentElement.setAttribute('y2', pos.y);
            } else if (mode === 'rect') {
                const w = pos.x - startX;
                const h = pos.y - startY;
                currentElement.setAttribute('x', w < 0 ? pos.x : startX);
                currentElement.setAttribute('y', h < 0 ? pos.y : startY);
                currentElement.setAttribute('width', Math.abs(w));
                currentElement.setAttribute('height', Math.abs(h));
            } else if (mode === 'circle') {
                const r = Math.sqrt(Math.pow(pos.x - startX, 2) + Math.pow(pos.y - startY, 2));
                currentElement.setAttribute('r', r);
            } else if (mode === 'ellipse') {
                currentElement.setAttribute('rx', Math.abs(pos.x - startX));
                currentElement.setAttribute('ry', Math.abs(pos.y - startY));
            }
        });

        svg.addEventListener('mouseup', () => {
            if (isDrawing) {
                if(sprayInterval) clearInterval(sprayInterval);
                if(currentElement) history.push(currentElement);
            }
            isDrawing = false;
            currentElement = null;
        });

        svg.addEventListener('mouseleave', () => {
            if (isDrawing) {
                 if(sprayInterval) clearInterval(sprayInterval);
                 if(currentElement) history.push(currentElement);
            }
            isDrawing = false;
            currentElement = null;
        });

        function undo() {
            if (history.length > 0) {
                const el = history.pop();
                svg.removeChild(el);
            }
        }

        function clearCanvas() {
            if(confirm('Á°ÆÂÆöÊ∏ÖÁ©∫ÁîªÊùøÂêóÔºü')) {
                svg.innerHTML = '';
                history = [];
            }
        }

        function exportSVG() {
            const serializer = new XMLSerializer();
            let source = serializer.serializeToString(svg);
            // Add xml declaration
            source = '<?xml version="1.0" standalone="no"?>\r\n' + source;
            
            const url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);
            const a = document.createElement('a');
            a.href = url;
            a.download = `drawing-${Date.now()}.svg`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            app.showToast('SVG Â∑≤ÂØºÂá∫');
        }

        function copySeed() {
            const seedText = document.getElementById('seed-display').innerText;
            if(seedText) {
                const val = seedText.split(': ')[1];
                if(val) {
                    navigator.clipboard.writeText(val);
                    app.showToast('ÁßçÂ≠êÂ∑≤Â§çÂà∂: ' + val);
                }
            }
        }

        function generateRandomArt() {
            // 1. Handle Canvas Clearing
            const shouldClear = document.getElementById('clear-before-gen').checked;
            if (shouldClear) {
                svg.innerHTML = '';
                history = [];
            }

            // 2. Seed Processing
            const seedInput = document.getElementById('art-seed');
            let seedVal = seedInput.value.trim();
            
            // If empty, use random, but DON'T fill input (so next click is random again)
            if (!seedVal) {
                seedVal = Math.random().toString(36).substring(2, 8).toUpperCase();
            }
            
            // Display seed
            document.getElementById('seed-display').innerText = `ÁßçÂ≠ê: ${seedVal}`;

            // Hash function (cyrb53)
            const cyrb53 = function(str, seed = 0) {
                let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
                for (let i = 0, ch; i < str.length; i++) {
                    ch = str.charCodeAt(i);
                    h1 = Math.imul(h1 ^ ch, 2654435761);
                    h2 = Math.imul(h2 ^ ch, 1597334677);
                }
                h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);
                h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);
                return 4294967296 * (2097151 & h2) + (h1 >>> 0);
            };

            const seedHash = cyrb53(seedVal);

            // PRNG (Mulberry32)
            const random = (function(a) {
                return function() {
                  var t = a += 0x6D2B79F5;
                  t = Math.imul(t ^ t >>> 15, t | 1);
                  t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                  return ((t ^ t >>> 14) >>> 0) / 4294967296;
                }
            })(seedHash);

            // Helper: Random Range
            const randRange = (min, max) => min + random() * (max - min);
            const randInt = (min, max) => Math.floor(randRange(min, max));
            const randChoice = (arr) => arr[Math.floor(random() * arr.length)];
            const chance = (prob) => random() < prob;

            // 3. Palette Generator
            const generatePalette = () => {
                const hue = randInt(0, 360);
                const scheme = randChoice(['complementary', 'analogous', 'triadic', 'split']);
                const palette = [];
                
                const addColor = (h, s, l) => {
                    palette.push(`hsl(${h % 360}, ${s}%, ${l}%)`);
                };

                // Base color
                const s = randInt(60, 90);
                const l = randInt(40, 60);
                addColor(hue, s, l);

                if (scheme === 'complementary') {
                    addColor(hue + 180, s, l);
                    addColor(hue, s - 20, l + 20);
                    addColor(hue + 180, s - 20, l - 10);
                } else if (scheme === 'analogous') {
                    addColor(hue + 30, s, l);
                    addColor(hue - 30, s, l);
                    addColor(hue + 60, s - 10, l + 10);
                } else if (scheme === 'triadic') {
                    addColor(hue + 120, s, l);
                    addColor(hue + 240, s, l);
                    addColor(hue, s - 30, l + 30);
                } else { // split
                    addColor(hue + 150, s, l);
                    addColor(hue + 210, s, l);
                    addColor(hue, s - 10, l + 30);
                }
                // Add a dark and a light neutral
                palette.push(`hsl(${hue}, 10%, 90%)`);
                palette.push(`hsl(${hue}, 20%, 20%)`);
                return palette;
            };

            const palette = generatePalette();
            
            // Filter styles
            const selectedStyles = Array.from(document.querySelectorAll('input[name="style-filter"]:checked')).map(cb => cb.value);
            if (selectedStyles.length === 0) {
                app.showToast('ËØ∑Ëá≥Â∞ëÈÄâÊã©‰∏ÄÁßçÈ£éÊ†º');
                return;
            }
            
            const style = randChoice(selectedStyles);
            const width = 512;
            const height = 512;

            // 4. Generators
            const generators = {
                geometric: () => {
                    // Recursive subdivision (Bauhaus style)
                    const maxDepth = 4;
                    
                    if (shouldClear) {
                        const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        bg.setAttribute('width', width);
                        bg.setAttribute('height', height);
                        bg.setAttribute('fill', '#f0f0f0');
                        svg.appendChild(bg);
                    }

                    const drawRect = (x, y, w, h, depth) => {
                        if (depth >= maxDepth || (chance(0.3) && depth > 1)) {
                            const color = randChoice(palette);
                            const el = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                            el.setAttribute('x', x);
                            el.setAttribute('y', y);
                            el.setAttribute('width', w);
                            el.setAttribute('height', h);
                            el.setAttribute('fill', color);
                            el.setAttribute('stroke', '#333');
                            el.setAttribute('stroke-width', 2);
                            svg.appendChild(el);
                            
                            // Add detail?
                            if (chance(0.3) && w > 40 && h > 40) {
                                const type = randChoice(['circle', 'lines']);
                                if (type === 'circle') {
                                    const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                                    c.setAttribute('cx', x + w/2);
                                    c.setAttribute('cy', y + h/2);
                                    c.setAttribute('r', Math.min(w, h)/3);
                                    c.setAttribute('fill', randChoice(palette));
                                    svg.appendChild(c);
                                }
                            }
                            return;
                        }

                        // Split
                        const splitVert = random() > 0.5;
                        if (splitVert) {
                            const split = w * randRange(0.3, 0.7);
                            drawRect(x, y, split, h, depth + 1);
                            drawRect(x + split, y, w - split, h, depth + 1);
                        } else {
                            const split = h * randRange(0.3, 0.7);
                            drawRect(x, y, w, split, depth + 1);
                            drawRect(x, y + split, w, h - split, depth + 1);
                        }
                    };
                    
                    drawRect(10, 10, width-20, height-20, 0);
                },
                
                mandala: () => {
                    // Radial symmetry
                    const cx = width / 2;
                    const cy = height / 2;
                    const rings = randInt(5, 12);
                    
                    if (shouldClear) {
                        const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        bg.setAttribute('width', width);
                        bg.setAttribute('height', height);
                        bg.setAttribute('fill', palette[palette.length-1]);
                        svg.appendChild(bg);
                    }

                    for (let r = rings; r > 0; r--) {
                        const radius = (width / 2) * (r / rings);
                        const points = randInt(6, 24);
                        const shape = randChoice(['circle', 'petal', 'triangle']);
                        const color = palette[r % palette.length];
                        
                        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        svg.appendChild(g);

                        for (let i = 0; i < points; i++) {
                            const angle = (i / points) * Math.PI * 2;
                            const x = cx + Math.cos(angle) * radius * 0.8;
                            const y = cy + Math.sin(angle) * radius * 0.8;
                            
                            let el;
                            if (shape === 'circle') {
                                el = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                                el.setAttribute('cx', x);
                                el.setAttribute('cy', y);
                                el.setAttribute('r', radius * 0.2);
                            } else if (shape === 'triangle') {
                                el = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                                const s = radius * 0.2;
                                const pts = `${x},${y-s} ${x-s},${y+s} ${x+s},${y+s}`;
                                el.setAttribute('points', pts);
                                el.setAttribute('transform', `rotate(${(angle * 180 / Math.PI) + 90}, ${x}, ${y})`);
                            } else {
                                // Petal (Ellipse)
                                el = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
                                el.setAttribute('cx', x);
                                el.setAttribute('cy', y);
                                el.setAttribute('rx', radius * 0.1);
                                el.setAttribute('ry', radius * 0.3);
                                el.setAttribute('transform', `rotate(${(angle * 180 / Math.PI) + 90}, ${x}, ${y})`);
                            }
                            
                            el.setAttribute('fill', color);
                            el.setAttribute('opacity', 0.8);
                            g.appendChild(el);
                        }
                    }
                },
                
                flow: () => {
                    // Flowing lines
                    if (shouldClear) {
                        const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        bg.setAttribute('width', width);
                        bg.setAttribute('height', height);
                        bg.setAttribute('fill', '#111');
                        svg.appendChild(bg);
                    }

                    const lines = randInt(50, 100);
                    const steps = 20;
                    
                    for(let i=0; i<lines; i++) {
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        let d = `M ${randRange(0, width)} ${randRange(0, height)}`;
                        let x = randRange(0, width);
                        let y = randRange(0, height);
                        
                        // Create a smooth curve
                        for(let s=0; s<steps; s++) {
                             const angle = (x / width) * Math.PI * 4 + (y / height) * Math.PI * 4;
                             x += Math.cos(angle) * 20;
                             y += Math.sin(angle) * 20;
                             d += ` L ${x} ${y}`;
                        }
                        
                        path.setAttribute('d', d);
                        path.setAttribute('fill', 'none');
                        path.setAttribute('stroke', randChoice(palette));
                        path.setAttribute('stroke-width', randRange(1, 4));
                        path.setAttribute('opacity', randRange(0.3, 0.8));
                        svg.appendChild(path);
                    }
                },

                circuit: () => {
                    // Circuit board style
                    if (shouldClear) {
                        const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        bg.setAttribute('width', width);
                        bg.setAttribute('height', height);
                        bg.setAttribute('fill', '#002');
                        svg.appendChild(bg);
                    }
                    
                    const gridSize = 32;
                    const cols = Math.floor(width / gridSize);
                    const rows = Math.floor(height / gridSize);
                    const traces = randInt(20, 50);
                    
                    for(let i=0; i<traces; i++) {
                        let cx = randInt(1, cols-1) * gridSize;
                        let cy = randInt(1, rows-1) * gridSize;
                        const len = randInt(5, 15);
                        let points = [[cx, cy]];
                        let dir = randInt(0, 4); // 0:R, 1:D, 2:L, 3:U
                        
                        for(let j=0; j<len; j++) {
                            if(chance(0.3)) dir = (dir + (chance(0.5)?1:3)) % 4;
                            if(dir === 0) cx += gridSize;
                            else if(dir === 1) cy += gridSize;
                            else if(dir === 2) cx -= gridSize;
                            else cy -= gridSize;
                            
                            // Clamp
                            cx = Math.max(0, Math.min(width, cx));
                            cy = Math.max(0, Math.min(height, cy));
                            points.push([cx, cy]);
                        }
                        
                        const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                        polyline.setAttribute('points', points.map(p => p.join(',')).join(' '));
                        polyline.setAttribute('fill', 'none');
                        polyline.setAttribute('stroke', randChoice(palette));
                        polyline.setAttribute('stroke-width', 2);
                        polyline.setAttribute('stroke-linecap', 'round');
                        polyline.setAttribute('stroke-linejoin', 'round');
                        polyline.setAttribute('opacity', 0.8);
                        svg.appendChild(polyline);
                        
                        // Terminals
                        const start = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        start.setAttribute('cx', points[0][0]);
                        start.setAttribute('cy', points[0][1]);
                        start.setAttribute('r', 3);
                        start.setAttribute('fill', '#fff');
                        svg.appendChild(start);
                        
                        const end = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        end.setAttribute('cx', points[points.length-1][0]);
                        end.setAttribute('cy', points[points.length-1][1]);
                        end.setAttribute('r', 3);
                        end.setAttribute('fill', '#fff');
                        svg.appendChild(end);
                    }
                },

                pixel: () => {
                    // Pixel art grid
                    const pSize = randChoice([16, 32, 64]);
                    const cols = Math.ceil(width / pSize);
                    const rows = Math.ceil(height / pSize);
                    
                    if (shouldClear) {
                        const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        bg.setAttribute('width', width);
                        bg.setAttribute('height', height);
                        bg.setAttribute('fill', '#000');
                        svg.appendChild(bg);
                    }
                    
                    // Symmetry?
                    const symX = chance(0.5);
                    const symY = chance(0.5);
                    
                    for(let y=0; y<rows; y++) {
                        for(let x=0; x<cols; x++) {
                            // Check symmetry
                            let srcX = x, srcY = y;
                            if(symX && x >= cols/2) srcX = cols - 1 - x;
                            if(symY && y >= rows/2) srcY = rows - 1 - y;
                            
                            // Noise based on position
                            const noise = (Math.sin(srcX*0.5) + Math.cos(srcY*0.5)) * 0.5 + 0.5;
                            
                            if (random() > 0.4) { // Sparsity
                                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                                rect.setAttribute('x', x * pSize);
                                rect.setAttribute('y', y * pSize);
                                rect.setAttribute('width', pSize);
                                rect.setAttribute('height', pSize);
                                rect.setAttribute('fill', randChoice(palette));
                                rect.setAttribute('opacity', 0.8 + random()*0.2);
                                svg.appendChild(rect);
                            }
                        }
                    }
                },
                
                starfield: () => {
                    // Constellation / Starfield
                    if (shouldClear) {
                        const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        bg.setAttribute('width', width);
                        bg.setAttribute('height', height);
                        bg.setAttribute('fill', '#0a0a1a');
                        svg.appendChild(bg);
                    }
                    
                    const starCount = randInt(50, 100);
                    const stars = [];
                    
                    // Generate stars
                    for(let i=0; i<starCount; i++) {
                        const s = {
                            x: randRange(0, width),
                            y: randRange(0, height),
                            r: randRange(1, 3)
                        };
                        stars.push(s);
                        
                        const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        c.setAttribute('cx', s.x);
                        c.setAttribute('cy', s.y);
                        c.setAttribute('r', s.r);
                        c.setAttribute('fill', '#fff');
                        c.setAttribute('opacity', randRange(0.5, 1));
                        svg.appendChild(c);
                    }
                    
                    // Connect neighbors
                    const maxDist = 80;
                    for(let i=0; i<stars.length; i++) {
                        for(let j=i+1; j<stars.length; j++) {
                            const dx = stars[i].x - stars[j].x;
                            const dy = stars[i].y - stars[j].y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            
                            if (dist < maxDist) {
                                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                line.setAttribute('x1', stars[i].x);
                                line.setAttribute('y1', stars[i].y);
                                line.setAttribute('x2', stars[j].x);
                                line.setAttribute('y2', stars[j].y);
                                line.setAttribute('stroke', randChoice(palette));
                                line.setAttribute('stroke-width', (1 - dist/maxDist) * 2);
                                line.setAttribute('opacity', (1 - dist/maxDist) * 0.5);
                                svg.appendChild(line);
                            }
                        }
                    }
                },

                bubbles: () => {
                    if (shouldClear) {
                        const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        bg.setAttribute('width', width);
                        bg.setAttribute('height', height);
                        bg.setAttribute('fill', palette[palette.length-1]);
                        svg.appendChild(bg);
                    }
                    const count = randInt(20, 50);
                    for(let i=0; i<count; i++) {
                        const r = randRange(10, 80);
                        const cx = randRange(0, width);
                        const cy = randRange(0, height);
                        const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        c.setAttribute('cx', cx);
                        c.setAttribute('cy', cy);
                        c.setAttribute('r', r);
                        c.setAttribute('fill', randChoice(palette));
                        c.setAttribute('opacity', randRange(0.2, 0.6));
                        // Add some gradient-like stroke
                        if(chance(0.5)) {
                            c.setAttribute('stroke', '#fff');
                            c.setAttribute('stroke-width', 2);
                            c.setAttribute('stroke-opacity', 0.4);
                        }
                        svg.appendChild(c);
                    }
                },

                waves: () => {
                    if (shouldClear) {
                        const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        bg.setAttribute('width', width);
                        bg.setAttribute('height', height);
                        bg.setAttribute('fill', palette[palette.length-1]);
                        svg.appendChild(bg);
                    }
                    const layers = randInt(5, 10);
                    const stepY = height / layers;
                    
                    for(let i=0; i<layers; i++) {
                        const yBase = i * stepY;
                        let d = `M 0 ${yBase + 50}`;
                        const freq = randRange(0.01, 0.05);
                        const amp = randRange(20, 50);
                        const phase = randRange(0, Math.PI*2);
                        
                        for(let x=0; x<=width; x+=10) {
                            const y = yBase + Math.sin(x * freq + phase) * amp;
                            d += ` L ${x} ${y}`;
                        }
                        d += ` L ${width} ${height} L 0 ${height} Z`;
                        
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('d', d);
                        path.setAttribute('fill', palette[i % palette.length]);
                        path.setAttribute('opacity', 0.7);
                        svg.appendChild(path);
                    }
                },

                memphis: () => {
                    if (shouldClear) {
                        const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        bg.setAttribute('width', width);
                        bg.setAttribute('height', height);
                        bg.setAttribute('fill', '#fff'); // 80s style usually white/pastel bg
                        svg.appendChild(bg);
                    }
                    const count = randInt(30, 60);
                    for(let i=0; i<count; i++) {
                        const type = randChoice(['rect', 'circle', 'line', 'triangle', 'squiggle']);
                        const x = randRange(0, width);
                        const y = randRange(0, height);
                        const color = randChoice(palette);
                        const rot = randRange(0, 360);
                        
                        let el;
                        if(type === 'rect') {
                            el = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                            el.setAttribute('x', x);
                            el.setAttribute('y', y);
                            el.setAttribute('width', randRange(20, 60));
                            el.setAttribute('height', randRange(20, 60));
                        } else if (type === 'circle') {
                            el = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                            el.setAttribute('cx', x);
                            el.setAttribute('cy', y);
                            el.setAttribute('r', randRange(10, 30));
                        } else if (type === 'triangle') {
                            el = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                            el.setAttribute('points', '0,-20 -20,20 20,20');
                        } else if (type === 'line') {
                            el = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                            el.setAttribute('width', randRange(40, 80));
                            el.setAttribute('height', 5);
                            el.setAttribute('x', x);
                            el.setAttribute('y', y);
                        } else { // squiggle
                            el = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                            el.setAttribute('d', 'M0,0 Q10,-20 20,0 T40,0');
                            el.setAttribute('fill', 'none');
                            el.setAttribute('stroke', color);
                            el.setAttribute('stroke-width', 4);
                            el.setAttribute('transform', `translate(${x},${y}) rotate(${rot}) scale(${randRange(1,2)})`);
                            svg.appendChild(el);
                            continue; // Special handling for path
                        }
                        
                        if(type !== 'squiggle') {
                            el.setAttribute('fill', color);
                            if(type === 'triangle') {
                                el.setAttribute('transform', `translate(${x},${y}) rotate(${rot})`);
                            } else if (type === 'rect') {
                                el.setAttribute('transform', `rotate(${rot}, ${x}, ${y})`);
                            }
                        }
                        svg.appendChild(el);
                    }
                },

                fractal: () => {
                    // Recursive Tree
                    if (shouldClear) {
                        const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        bg.setAttribute('width', width);
                        bg.setAttribute('height', height);
                        bg.setAttribute('fill', '#111');
                        svg.appendChild(bg);
                    }
                    
                    const drawBranch = (x, y, len, angle, depth) => {
                        if (depth === 0) return;
                        
                        const x2 = x + Math.cos(angle) * len;
                        const y2 = y + Math.sin(angle) * len;
                        
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', x);
                        line.setAttribute('y1', y);
                        line.setAttribute('x2', x2);
                        line.setAttribute('y2', y2);
                        line.setAttribute('stroke', palette[depth % palette.length]);
                        line.setAttribute('stroke-width', depth);
                        line.setAttribute('stroke-linecap', 'round');
                        svg.appendChild(line);
                        
                        // Recursive calls
                        const subLen = len * 0.7;
                        drawBranch(x2, y2, subLen, angle - 0.4, depth - 1);
                        drawBranch(x2, y2, subLen, angle + 0.4, depth - 1);
                    };
                    
                    // Start from bottom center
                    drawBranch(width/2, height, 120, -Math.PI/2, 9);
                },

                maze: () => {
                    if (shouldClear) {
                        const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        bg.setAttribute('width', width);
                        bg.setAttribute('height', height);
                        bg.setAttribute('fill', '#fff');
                        svg.appendChild(bg);
                    }
                    const cellSize = 20;
                    const cols = Math.floor(width/cellSize);
                    const rows = Math.floor(height/cellSize);
                    
                    for(let y=0; y<rows; y++) {
                        for(let x=0; x<cols; x++) {
                            const px = x * cellSize;
                            const py = y * cellSize;
                            
                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            line.setAttribute('stroke', '#000');
                            line.setAttribute('stroke-width', 2);
                            line.setAttribute('stroke-linecap', 'round');
                            
                            if (chance(0.5)) {
                                // Forward slash
                                line.setAttribute('x1', px);
                                line.setAttribute('y1', py + cellSize);
                                line.setAttribute('x2', px + cellSize);
                                line.setAttribute('y2', py);
                            } else {
                                // Backslash
                                line.setAttribute('x1', px);
                                line.setAttribute('y1', py);
                                line.setAttribute('x2', px + cellSize);
                                line.setAttribute('y2', py + cellSize);
                            }
                            // Add color variation
                            if (chance(0.2)) line.setAttribute('stroke', randChoice(palette));
                            
                            svg.appendChild(line);
                        }
                    }
                },

                hexagons: () => {
                    if (shouldClear) {
                        const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        bg.setAttribute('width', width);
                        bg.setAttribute('height', height);
                        bg.setAttribute('fill', '#222');
                        svg.appendChild(bg);
                    }
                    const r = 30;
                    const h = r * Math.sqrt(3);
                    const cols = Math.ceil(width / (r * 1.5));
                    const rows = Math.ceil(height / h);
                    
                    for(let y=0; y<rows; y++) {
                        for(let x=0; x<cols; x++) {
                            const cx = x * r * 1.5;
                            const cy = y * h + (x % 2 === 0 ? 0 : h/2);
                            
                            if (chance(0.8)) {
                                const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                                let pts = "";
                                for(let i=0; i<6; i++) {
                                    const ang = i * Math.PI / 3;
                                    pts += `${cx + r*Math.cos(ang)},${cy + r*Math.sin(ang)} `;
                                }
                                poly.setAttribute('points', pts);
                                poly.setAttribute('fill', randChoice(palette));
                                poly.setAttribute('stroke', '#111');
                                poly.setAttribute('stroke-width', 2);
                                poly.setAttribute('opacity', randRange(0.5, 0.9));
                                svg.appendChild(poly);
                            }
                        }
                    }
                },

                rain: () => {
                    // Digital Rain
                    if (shouldClear) {
                        const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        bg.setAttribute('width', width);
                        bg.setAttribute('height', height);
                        bg.setAttribute('fill', '#000');
                        svg.appendChild(bg);
                    }
                    const cols = 40;
                    const colWidth = width / cols;
                    
                    for(let i=0; i<cols; i++) {
                        const drops = randInt(5, 15);
                        const x = i * colWidth + colWidth/2;
                        
                        for(let j=0; j<drops; j++) {
                            const y = randRange(0, height);
                            const len = randRange(10, 50);
                            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            text.setAttribute('x', x);
                            text.setAttribute('y', y);
                            text.setAttribute('fill', i%2===0 ? '#0f0' : randChoice(palette));
                            text.setAttribute('font-family', 'monospace');
                            text.setAttribute('font-size', randRange(10, 20));
                            text.setAttribute('opacity', randRange(0.2, 0.9));
                            // Random char
                            text.textContent = String.fromCharCode(0x30A0 + randInt(0, 96));
                            svg.appendChild(text);
                        }
                    }
                },

                spirals: () => {
                    if (shouldClear) {
                        const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        bg.setAttribute('width', width);
                        bg.setAttribute('height', height);
                        bg.setAttribute('fill', palette[0]);
                        svg.appendChild(bg);
                    }
                    const cx = width/2;
                    const cy = height/2;
                    const count = 300;
                    const a = 5;
                    const b = 2;
                    
                    let pathD = `M ${cx} ${cy}`;
                    
                    for(let i=0; i<count; i++) {
                        const angle = 0.5 * i;
                        const r = a + b * angle;
                        const x = cx + r * Math.cos(angle);
                        const y = cy + r * Math.sin(angle);
                        
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('cx', x);
                        circle.setAttribute('cy', y);
                        circle.setAttribute('r', i/10);
                        circle.setAttribute('fill', randChoice(palette));
                        svg.appendChild(circle);
                    }
                },

                crossstitch: () => {
                     if (shouldClear) {
                        const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        bg.setAttribute('width', width);
                        bg.setAttribute('height', height);
                        bg.setAttribute('fill', '#fff');
                        svg.appendChild(bg);
                    }
                    const gridSize = 10;
                    const cols = width / gridSize;
                    const rows = height / gridSize;
                    
                    // Pattern generator
                    for(let y=0; y<rows; y++) {
                        for(let x=0; x<cols; x++) {
                            // Simple cellular automata or noise pattern
                            const noise = (Math.sin(x*0.2) * Math.cos(y*0.2));
                            if(noise > 0 || chance(0.3)) {
                                const px = x * gridSize;
                                const py = y * gridSize;
                                const color = randChoice(palette);
                                
                                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                                g.setAttribute('stroke', color);
                                g.setAttribute('stroke-width', 2);
                                
                                const l1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                l1.setAttribute('x1', px + 2);
                                l1.setAttribute('y1', py + 2);
                                l1.setAttribute('x2', px + gridSize - 2);
                                l1.setAttribute('y2', py + gridSize - 2);
                                
                                const l2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                l2.setAttribute('x1', px + gridSize - 2);
                                l2.setAttribute('y1', py + 2);
                                l2.setAttribute('x2', px + 2);
                                l2.setAttribute('y2', py + gridSize - 2);
                                
                                g.appendChild(l1);
                                g.appendChild(l2);
                                svg.appendChild(g);
                            }
                        }
                    }
                }
            };

            // Run
            generators[style]();
            app.showToast(`ÁîüÊàêÂÆåÊØï: ${style}`);
        }
    </script>
</body>
</html>