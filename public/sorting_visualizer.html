<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÊéíÂ∫èÁÆóÊ≥ïÂèØËßÜÂåñÁªàÊûÅÁâà</title>
    <style>
        :root {
            --bg-primary: #1a1025;
            --bg-secondary: #2d1b3e;
            --bg-tertiary: #4a2c66;
            --accent: #9b59b6;
            --accent-hover: #8e44ad;
            --text-primary: #f5f5f5;
            --text-secondary: #b0a0c0;
            --bar-default: #a569bd;
            --bar-compare: #e74c3c;
            --bar-swap: #f1c40f;
            --bar-sorted: #2ecc71;
            --bar-aux: #3498db;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        header {
            background-color: var(--bg-secondary);
            padding: 0.8rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 10;
            height: 70px;
        }

        h1 {
            font-size: 1.4rem;
            color: var(--accent);
            text-shadow: 0 0 10px rgba(155, 89, 182, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
            height: calc(100vh - 70px);
        }

        .sidebar {
            width: 380px;
            background-color: var(--bg-secondary);
            border-right: 1px solid var(--bg-tertiary);
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Changed from overflow-y: auto */
        }

        .sidebar-top {
            padding: 1rem;
            background-color: var(--bg-secondary);
            border-bottom: 1px solid var(--bg-tertiary);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 5;
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .info-panel {
            background-color: rgba(0,0,0,0.2);
            padding: 1rem;
            border-radius: 8px;
            font-size: 0.9rem;
            line-height: 1.5;
            border: 1px solid var(--bg-tertiary);
            min-height: 140px;
            display: flex;
            flex-direction: column;
        }

        .info-title {
            font-size: 1.1rem;
            color: var(--accent);
            margin-bottom: 0.5rem;
            font-weight: bold;
        }

        .info-meta {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .info-desc {
            font-size: 0.85rem;
            color: var(--text-primary);
            overflow-y: auto;
            max-height: 80px;
            padding-right: 5px;
        }

        .search-box {
            padding: 0.6rem;
            background: var(--bg-primary);
            border: 1px solid var(--bg-tertiary);
            color: white;
            border-radius: 4px;
            width: 100%;
            outline: none;
            transition: border-color 0.2s;
        }
        .search-box:focus {
            border-color: var(--accent);
        }

        .category-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            padding-bottom: 5px;
        }

        .tab-btn {
            background-color: transparent;
            border: 1px solid var(--bg-tertiary);
            color: var(--text-secondary);
            padding: 4px 8px;
            font-size: 0.8rem;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tab-btn:hover, .tab-btn.active {
            background-color: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .algorithm-list {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .category-header {
            font-size: 0.85rem;
            color: var(--accent);
            margin-top: 0.5rem;
            margin-bottom: 0.2rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
            opacity: 0.8;
            border-bottom: 1px solid var(--bg-tertiary);
            padding-bottom: 2px;
        }

        .algo-btn {
            background-color: rgba(255,255,255,0.03);
            text-align: left;
            border: 1px solid transparent;
            color: var(--text-secondary);
            padding: 0.8rem 1rem;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .algo-btn:hover {
            background-color: var(--bg-tertiary);
            color: white;
            transform: translateX(3px);
        }

        .algo-btn.active {
            background-color: rgba(155, 89, 182, 0.2);
            color: var(--accent);
            border-color: var(--accent);
            font-weight: bold;
        }

        .visualizer-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 1rem;
            position: relative;
        }

        canvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
            background-color: rgba(0,0,0,0.2);
            box-shadow: inset 0 0 20px rgba(0,0,0,0.2);
        }

        .controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        button.control-btn {
            background-color: var(--accent);
            color: white;
            border: none;
            padding: 0.6rem 1.2rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        button.control-btn:hover {
            background-color: var(--accent-hover);
            transform: translateY(-1px);
        }

        button.control-btn:disabled {
            background-color: var(--bg-tertiary);
            cursor: not-allowed;
            transform: none;
            color: var(--text-secondary);
            opacity: 0.6;
        }

        button.control-btn.pause-btn {
            background-color: #f39c12;
        }
        button.control-btn.pause-btn:hover {
            background-color: #d68910;
        }
        button.control-btn.stop-btn {
            background-color: #e74c3c;
        }
        button.control-btn.stop-btn:hover {
            background-color: #c0392b;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
        }

        label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            font-weight: 600;
        }

        input[type="range"] {
            accent-color: var(--accent);
            width: 120px;
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            outline: none;
        }

        .complexity-badge {
            background-color: var(--bg-tertiary);
            padding: 2px 6px;
            border-radius: 4px;
            color: #fff;
            font-family: monospace;
        }

        .stats-overlay {
            position: absolute;
            top: 2rem;
            left: 2rem;
            background-color: rgba(26, 16, 37, 0.85);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--bg-tertiary);
            pointer-events: none;
            backdrop-filter: blur(4px);
            min-width: 180px;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.3rem;
            font-size: 0.9rem;
        }
        .stat-label { color: var(--text-secondary); }
        .stat-value { color: var(--text-primary); font-family: monospace; font-weight: bold; }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        ::-webkit-scrollbar-thumb {
            background: var(--bg-tertiary);
            border-radius: 3px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }
    </style>
</head>
<body>
    <header>
        <h1><span></span>üü£</span> AlgoViz Pro</h1>
        <div class="controls">
            <div class="control-group">
                <label>Êï∞Èáè (Size)</label>
                <input type="range" id="sizeRange" min="10" max="300" value="50">
            </div>
            <div class="control-group">
                <label>ÈÄüÂ∫¶ (Speed)</label>
                <input type="range" id="speedRange" min="1" max="100" value="50">
            </div>
            <button id="resetBtn" class="control-btn">‚Ü∫ ÈáçÁΩÆ</button>
            <button id="pauseBtn" class="control-btn pause-btn" disabled>‚ùö‚ùö ÊöÇÂÅú</button>
            <button id="startBtn" class="control-btn">‚ñ∂ ÂºÄÂßã</button>
        </div>
    </header>

    <div class="main-container">
        <aside class="sidebar">
            <div class="sidebar-top">
                <div id="infoPanel" class="info-panel">
                    <h3 class="info-title" id="infoTitle">ÈÄâÊã©‰∏Ä‰∏™ÁÆóÊ≥ï</h3>
                    <div class="info-meta">
                        <div>Êó∂Èó¥: <span id="infoTime" class="complexity-badge">-</span></div>
                        <div>Á©∫Èó¥: <span id="infoSpace" class="complexity-badge">-</span></div>
                    </div>
                    <div class="info-desc" id="infoDesc">ËØ∑‰ªé‰∏ãÊñπÂàóË°®ÈÄâÊã©‰∏Ä‰∏™ÁÆóÊ≥ïÂºÄÂßãÂèØËßÜÂåñ„ÄÇ</div>
                </div>
                <input type="text" id="searchAlgo" class="search-box" placeholder="ÊêúÁ¥¢ÁÆóÊ≥ï...">
                <div id="categoryTabs" class="category-tabs">
                    <!-- Tabs will be populated here -->
                </div>
            </div>
            <div id="algoList" class="algorithm-list">
                <!-- Algorithms will be populated here -->
            </div>
        </aside>

        <main class="visualizer-area">
            <canvas id="canvas"></canvas>
            <div class="stats-overlay">
                <div class="stat-item"><span class="stat-label">ÊØîËæÉÊ¨°Êï∞:</span> <span class="stat-value" id="comparisons">0</span></div>
                <div class="stat-item"><span class="stat-label">Êï∞ÁªÑËÆøÈóÆ:</span> <span class="stat-value" id="accesses">0</span></div>
                <div class="stat-item"><span class="stat-label">ËÄóÊó∂:</span> <span class="stat-value" id="timeElapsed">0ms</span></div>
            </div>
        </main>
    </div>

    <script>
        window.onerror = function(msg, url, line, col, error) {
           const div = document.createElement('div');
           div.style.position = 'fixed';
           div.style.top = '10px';
           div.style.right = '10px';
           div.style.background = 'rgba(255, 0, 0, 0.9)';
           div.style.color = 'white';
           div.style.padding = '15px';
           div.style.borderRadius = '5px';
           div.style.zIndex = '9999';
           div.style.boxShadow = '0 0 10px rgba(0,0,0,0.5)';
           div.style.maxWidth = '400px';
           div.innerText = 'JS Error: ' + msg + '\nLine: ' + line;
           document.body.appendChild(div);
           return false;
        };

        /**
         * ÊéíÂ∫èÁÆóÊ≥ïÂèØËßÜÂåñ - Ê®°ÂùóÂåñÂºÄÂèëÊåáÂçó
         * ==========================================
         * 
         * 1. ÁÆóÊ≥ïÊ∑ªÂä†Ê†ºÂºè (Algorithm Registration Format):
         *    registerAlgo(
         *        category,    // ÂàÜÁ±ª (Category): 'exchange', 'selection', 'insertion', 'merge', 'distribution', 'heap', 'hybrid', 'esoteric', 'other'
         *        name,        // ÂêçÁß∞ (Name): "‰∏≠ÊñáÂêçÁß∞ (English Name)"
         *        complexity,  // Êó∂Èó¥Â§çÊùÇÂ∫¶ (Time Complexity): e.g., "O(N^2)"
         *        space,       // Á©∫Èó¥Â§çÊùÇÂ∫¶ (Space Complexity): e.g., "O(1)"
         *        desc,        // ÊèèËø∞ (Description): "ÁÆóÊ≥ïÁöÑÁÆÄË¶ÅËØ¥Êòé"
         *        func         // ÂÆûÁé∞ÂáΩÊï∞ (Implementation): async (viz) => { ... }
         *    );
         * 
         * 2. Ê†∏ÂøÉ API (Core API):
         *    - await viz.compare(i, j): ÊØîËæÉÊï∞ÁªÑÁ¥¢Âºï i Âíå j ÁöÑÂÖÉÁ¥†„ÄÇËøîÂõû boolean (arr[i] > arr[j])„ÄÇ
         *    - await viz.swap(i, j): ‰∫§Êç¢Êï∞ÁªÑÁ¥¢Âºï i Âíå j ÁöÑÂÖÉÁ¥†„ÄÇ
         *    - await viz.write(i, val): Â∞ÜÂÄº val ÂÜôÂÖ•Êï∞ÁªÑÁ¥¢Âºï i„ÄÇ
         *    - await viz.sleep(): ÊöÇÂÅú‰∏ÄÂ∞èÊÆµÊó∂Èó¥ÔºàÁî±ÈÄüÂ∫¶ÊéßÂà∂Ôºâ„ÄÇÈÄöÂ∏∏Âú®ÊâãÂä®‰øÆÊîπÊï∞ÁªÑÂêéË∞ÉÁî® viz.state Êõ¥Êñ∞È¢úËâ≤„ÄÇ
         *    - viz.state[i]: ËÆæÁΩÆÁ¥¢Âºï i ÁöÑÈ¢úËâ≤Áä∂ÊÄÅ (0:ÈªòËÆ§, 1:ÊØîËæÉ, 2:‰∫§Êç¢/ÈáçÂÜô, 3:Â∑≤ÊéíÂ∫è, 4:ËæÖÂä©)„ÄÇ
         * 
         * 3. ÂàÜÁ±ªËØ¥Êòé (Categories):
         *    - exchange: ‰∫§Êç¢Á±ª (ÂÜíÊ≥°, Âø´ÊéíÁ≠â)
         *    - selection: ÈÄâÊã©Á±ª (ÈÄâÊã©, Â†ÜÊéíÁ≠â)
         *    - insertion: ÊèíÂÖ•Á±ª (ÊèíÂÖ•, Â∏åÂ∞îÁ≠â)
         *    - merge: ÂΩíÂπ∂Á±ª
         *    - distribution: ÂàÜÂ∏ÉÁ±ª (Âü∫Êï∞, Ê°∂, ËÆ°Êï∞Á≠â)
         *    - heap: Â†ÜÁ±ª
         *    - hybrid: Ê∑∑ÂêàÁ±ª (TimSort, IntroSortÁ≠â)
         *    - esoteric: Ë∂£Âë≥/ÂÖ∂‰ªñÁ±ª (Bogo, StalinÁ≠â)
         * 
         * 4. Ê®°ÂùóÂåñÊ∑ªÂä† (Modular Addition):
         *    Áõ¥Êé•Âú® "Algorithm Implementations" Âå∫Âüü‰∏ãÊñπË∞ÉÁî® registerAlgo Âç≥ÂèØ„ÄÇ
         */

        // --- Ê†∏ÂøÉÂèØËßÜÂåñÂºïÊìé (Core Visualization Engine) ---
        class Visualizer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.array = [];
                this.width = canvas.width;
                this.height = canvas.height;
                this.barWidth = 0;
                this.state = []; // To store colors/states of bars
                
                this.stats = { comparisons: 0, accesses: 0, startTime: 0 };
                this.isRunning = false;
                this.isPaused = false;
                this.stopSignal = false;
                this.pausePromise = null;
                this.delay = 50;

                this.resize();
                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = this.canvas.offsetHeight;
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                this.draw();
            }

            generateArray(size) {
                this.array = [];
                this.state = [];
                for (let i = 0; i < size; i++) {
                    // Generate value between 5 and 100
                    this.array.push(Math.random() * 95 + 5);
                    this.state.push(0); // 0: default
                }
                this.resetStats();
                this.draw();
            }

            resetStats() {
                this.stats = { comparisons: 0, accesses: 0, startTime: 0 };
                this.updateStatsUI();
            }

            updateStatsUI() {
                document.getElementById('comparisons').innerText = this.stats.comparisons;
                document.getElementById('accesses').innerText = this.stats.accesses;
                if(this.stats.startTime && this.isRunning) {
                    document.getElementById('timeElapsed').innerText = (Date.now() - this.stats.startTime) + 'ms';
                }
            }

            draw() {
                this.ctx.fillStyle = '#1a1025';
                this.ctx.fillRect(0, 0, this.width, this.height);

                const len = this.array.length;
                this.barWidth = this.width / len;

                for (let i = 0; i < len; i++) {
                    const h = (this.array[i] / 100) * this.height * 0.9;
                    const x = i * this.barWidth;
                    const y = this.height - h;

                    // Color mapping
                    let color = '#a569bd'; // default
                    if (this.state[i] === 1) color = '#e74c3c'; // compare
                    if (this.state[i] === 2) color = '#f1c40f'; // swap
                    if (this.state[i] === 3) color = '#2ecc71'; // sorted
                    if (this.state[i] === 4) color = '#3498db'; // aux/highlight

                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(x, y, this.barWidth - 1, h);
                }
            }

            async checkPause() {
                if (this.isPaused) {
                    await new Promise(resolve => {
                        this.pausePromise = resolve;
                    });
                }
            }

            pause() {
                this.isPaused = true;
            }

            resume() {
                this.isPaused = false;
                if (this.pausePromise) {
                    this.pausePromise();
                    this.pausePromise = null;
                }
            }

            async swap(i, j) {
                if (this.stopSignal) throw new Error('Stopped');
                let temp = this.array[i];
                this.array[i] = this.array[j];
                this.array[j] = temp;
                this.stats.accesses += 4;
                
                this.state[i] = 2;
                this.state[j] = 2;
                this.draw();
                await this.sleep();
                this.state[i] = 0;
                this.state[j] = 0;
            }

            async compare(i, j) {
                if (this.stopSignal) throw new Error('Stopped');
                this.stats.comparisons++;
                this.stats.accesses += 2;
                this.updateStatsUI();
                
                this.state[i] = 1;
                this.state[j] = 1;
                this.draw();
                await this.sleep();
                this.state[i] = 0;
                this.state[j] = 0;
                
                return this.array[i] > this.array[j];
            }

            async write(i, val) {
                if (this.stopSignal) throw new Error('Stopped');
                this.array[i] = val;
                this.stats.accesses++;
                this.state[i] = 4;
                this.draw();
                await this.sleep();
                this.state[i] = 0;
            }

            // For algorithms that just need to highlight without doing anything
            async highlight(indices, colorCode) {
                 if (this.stopSignal) throw new Error('Stopped');
                 for(let idx of indices) {
                     if(idx >= 0 && idx < this.state.length) this.state[idx] = colorCode;
                 }
                 this.draw();
                 await this.sleep();
                 for(let idx of indices) {
                     if(idx >= 0 && idx < this.state.length) this.state[idx] = 0;
                 }
            }

            async sleep() {
                if (this.stopSignal) throw new Error('Stopped');
                await this.checkPause();
                if (this.delay > 0) {
                    await new Promise(resolve => setTimeout(resolve, this.delay));
                }
            }

            async run(algorithmGenerator) {
                if (this.isRunning) return;
                this.isRunning = true;
                this.stopSignal = false;
                this.stats.startTime = Date.now();
                
                // Disable controls
                document.getElementById('startBtn').disabled = true;
                document.getElementById('sizeRange').disabled = true;
                document.getElementById('pauseBtn').disabled = false;
                document.getElementById('pauseBtn').innerText = '‚ùö‚ùö ÊöÇÂÅú';

                try {
                    await algorithmGenerator(this);
                    // Mark all as sorted
                    for(let i=0; i<this.array.length; i++) {
                        if (this.stopSignal) break;
                        this.state[i] = 3;
                        this.draw();
                        await new Promise(r => setTimeout(r, 10)); // Wave effect
                    }
                } catch (e) {
                    if (e.message !== 'Stopped') console.error(e);
                } finally {
                    this.isRunning = false;
                    this.isPaused = false;
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('sizeRange').disabled = false;
                    document.getElementById('pauseBtn').disabled = true;
                    document.getElementById('pauseBtn').innerText = '‚ùö‚ùö ÊöÇÂÅú';
                    this.updateStatsUI();
                }
            }
            
            stop() {
                if(this.isRunning) this.stopSignal = true;
            }
        }

        // --- Algorithm Registry ---
        const algorithms = {
            exchange: [],
            selection: [],
            insertion: [],
            merge: [],
            distribution: [],
            esoteric: [],
            hybrid: [],
            heap: [],
            other: []
        };

        function registerAlgo(category, name, complexity, space, desc, func) {
            if (!algorithms[category]) {
                console.warn(`Category '${category}' not found for algo '${name}'. Defaulting to 'other'.`);
                if (!algorithms['other']) algorithms['other'] = [];
                category = 'other';
            }
            algorithms[category].push({
                name, complexity, space, desc, func
            });
        }

        // --- ÁÆóÊ≥ïÂÆûÁé∞ (Algorithm Implementations) ---
        
        // 1. Bubble Sort
        registerAlgo('exchange', 'ÂÜíÊ≥°ÊéíÂ∫è (Bubble Sort)', 'O(N^2)', 'O(1)', 
            'ÈÄöËøáÈáçÂ§çÈÅçÂéÜË¶ÅÊéíÂ∫èÁöÑÂàóË°®ÔºåÊØîËæÉÊØèÂØπÁõ∏ÈÇªÈ°πÔºåÂ¶ÇÊûúÂÆÉ‰ª¨ÁöÑÈ°∫Â∫èÈîôËØØÔºàÂçáÂ∫èÊéíÂàóÊó∂ÔºåÂâçËÄÖÂ§ß‰∫éÂêéËÄÖÔºâÔºåÂ∞±‰∫§Êç¢ÂÆÉ‰ª¨„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                for (let i = 0; i < n - 1; i++) {
                    for (let j = 0; j < n - i - 1; j++) {
                        if (await viz.compare(j, j + 1)) {
                            await viz.swap(j, j + 1);
                        }
                    }
                    viz.state[n-1-i] = 3; // Mark sorted
                }
                viz.state[0] = 3;
            }
        );

        // 50. Tournament Sort
        registerAlgo('selection', 'Èî¶Ê†áËµõÊéíÂ∫è (Tournament Sort)', 'O(N log N)', 'O(N)', 
            'ÈÄöËøáÂª∫Á´ãÈî¶Ê†áËµõÊ†ëÔºàÁ±ª‰ºº‰∫éÂ†ÜÔºâÊù•ÈÄâÂá∫ÊúÄÂ∞èÂÖÉÁ¥†„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                // Build a tournament tree (heap-like) simulation
                for(let i=0; i<n; i++) {
                     // Sift up
                     let child = i;
                     while(child > 0) {
                         let parent = Math.floor((child-1)/2);
                         if(await viz.compare(child, parent)) { // max heap
                             await viz.swap(child, parent);
                             child = parent;
                         } else {
                             break;
                         }
                     }
                     viz.state[i] = 4;
                }
                
                // Extract max
                for(let i=n-1; i>0; i--) {
                    await viz.swap(0, i);
                    viz.state[i] = 3;
                    
                    // Sift down 0
                    let root = 0;
                    while(true) {
                        let left = 2*root + 1;
                        let right = 2*root + 2;
                        let max = root;
                        
                        if(left < i && await viz.compare(left, max)) max = left;
                        if(right < i && await viz.compare(right, max)) max = right;
                        
                        if(max !== root) {
                            await viz.swap(root, max);
                            root = max;
                        } else {
                            break;
                        }
                    }
                }
                viz.state[0] = 3;
            }
        );

        // 51. Odd-Even Merge Sort (Batcher's)
        registerAlgo('merge', 'Â•áÂÅ∂ÂΩíÂπ∂ÊéíÂ∫è (Batcher\'s Odd-Even Merge)', 'O(N log^2 N)', 'O(N)', 
            'Âü∫‰∫éÊéíÂ∫èÁΩëÁªúÁöÑÂπ∂Ë°åÊéíÂ∫èÁÆóÊ≥ï„ÄÇÈÄöËøáÈÄíÂΩíÂú∞ÂêàÂπ∂Â•áÊï∞‰ΩçÁΩÆÂíåÂÅ∂Êï∞‰ΩçÁΩÆÁöÑÂ≠êÂ∫èÂàó„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                
                async function compareAndSwap(i, j) {
                    if (j < n && await viz.compare(i, j)) {
                        await viz.swap(i, j);
                    }
                }
                
                // Iterative Batcher's for arbitrary n
                for (let p = 1; p < n; p += p) {
                    for (let k = p; k > 0; k = Math.floor(k / 2)) {
                        for (let j = k % p; j + k < n; j += 2 * k) {
                            for (let i = 0; i < n - j - k; i++) {
                                if (Math.floor((j + i) / (p * 2)) === Math.floor((j + i + k) / (p * 2))) {
                                    await compareAndSwap(j + i, j + i + k);
                                }
                            }
                        }
                    }
                }
                for(let i=0; i<n; i++) viz.state[i] = 3;
            }
        );

        // 52. Shear Sort
        registerAlgo('other', 'Ââ™ÂàáÊéíÂ∫è (Shear Sort)', 'O(N sqrt(N))', 'O(1)', 
            '‰∏ÄÁßçÂú®‰∫åÁª¥ÁΩëÊ†º‰∏äËøõË°åÁöÑÂπ∂Ë°åÊéíÂ∫èÁÆóÊ≥ïÔºåË°åÂíåÂàó‰∫§ÊõøÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                let rows = Math.floor(Math.sqrt(n));
                let cols = Math.ceil(n / rows);
                let logN = Math.ceil(Math.log2(n));
                
                for(let k=0; k<logN + 1; k++) {
                    // Sort rows
                    for(let r=0; r<rows; r++) {
                        let start = r * cols;
                        let end = Math.min((r+1) * cols, n);
                        let isEven = (r % 2 === 0);
                        
                        // Bubble sort the row
                        for(let i=start; i<end; i++) {
                            for(let j=start; j<end-1-(i-start); j++) {
                                let c1 = j;
                                let c2 = j+1;
                                if(c2 >= end) continue;
                                let cmp = await viz.compare(c1, c2); 
                                if(isEven) {
                                    if(cmp) await viz.swap(c1, c2);
                                } else {
                                    if(!cmp) await viz.swap(c1, c2); 
                                }
                            }
                        }
                    }
                    
                    // Sort columns
                    for(let c=0; c<cols; c++) {
                         for(let i=0; i<rows; i++) {
                             for(let j=0; j<rows-1-i; j++) {
                                 let idx1 = j * cols + c;
                                 let idx2 = (j+1) * cols + c;
                                 if(idx1 < n && idx2 < n) {
                                     if(await viz.compare(idx1, idx2)) await viz.swap(idx1, idx2);
                                 }
                             }
                         }
                    }
                }
                // Final cleanup pass
                 for(let i=0; i<n; i++) {
                    for(let j=0; j<n-1; j++) {
                         if(await viz.compare(j, j+1)) await viz.swap(j, j+1);
                    }
                     viz.state[n-1-i] = 3;
                 }
                 viz.state[0] = 3;
            }
        );

        // 2. Selection Sort
        registerAlgo('selection', 'ÈÄâÊã©ÊéíÂ∫è (Selection Sort)', 'O(N^2)', 'O(1)', 
            'È¶ñÂÖàÂú®Êú™ÊéíÂ∫èÂ∫èÂàó‰∏≠ÊâæÂà∞ÊúÄÂ∞èÔºàÂ§ßÔºâÂÖÉÁ¥†ÔºåÂ≠òÊîæÂà∞ÊéíÂ∫èÂ∫èÂàóÁöÑËµ∑Âßã‰ΩçÁΩÆÔºåÁÑ∂ÂêéÔºåÂÜç‰ªéÂâ©‰ΩôÊú™ÊéíÂ∫èÂÖÉÁ¥†‰∏≠ÁªßÁª≠ÂØªÊâæÊúÄÂ∞èÔºàÂ§ßÔºâÂÖÉÁ¥†ÔºåÁÑ∂ÂêéÊîæÂà∞Â∑≤ÊéíÂ∫èÂ∫èÂàóÁöÑÊú´Â∞æ„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                for (let i = 0; i < n; i++) {
                    let minIdx = i;
                    viz.state[i] = 4; // Current position
                    for (let j = i + 1; j < n; j++) {
                        if (await viz.compare(minIdx, j)) { // minIdx > j?
                             minIdx = j;
                        }
                    }
                    if (minIdx !== i) {
                        await viz.swap(i, minIdx);
                    }
                    viz.state[i] = 3;
                }
            }
        );

        // 3. Insertion Sort
        registerAlgo('insertion', 'ÊèíÂÖ•ÊéíÂ∫è (Insertion Sort)', 'O(N^2)', 'O(1)', 
            'ÈÄöËøáÊûÑÂª∫ÊúâÂ∫èÂ∫èÂàóÔºåÂØπ‰∫éÊú™ÊéíÂ∫èÊï∞ÊçÆÔºåÂú®Â∑≤ÊéíÂ∫èÂ∫èÂàó‰∏≠‰ªéÂêéÂêëÂâçÊâ´ÊèèÔºåÊâæÂà∞Áõ∏Â∫î‰ΩçÁΩÆÂπ∂ÊèíÂÖ•„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                viz.state[0] = 3;
                for (let i = 1; i < n; i++) {
                    let key = viz.array[i];
                    let j = i - 1;
                    viz.state[i] = 4; // Selected
                    
                    // Note: visualization of "sliding" is tricky without swap, 
                    // usually implemented as repeated swaps for visual clarity or shifting.
                    // Here we use repeated swaps for better visual effect in this framework.
                    while (j >= 0 && (await viz.compare(j, j+1))) { 
                        // compare j and j+1 (where j+1 holds the key effectively moving left)
                         await viz.swap(j, j + 1);
                         j--;
                    }
                    viz.state[i] = 3; // Approximate sorted zone
                    for(let k=0; k<=i; k++) viz.state[k] = 3;
                }
            }
        );

        // 4. Merge Sort
        registerAlgo('merge', 'ÂΩíÂπ∂ÊéíÂ∫è (Merge Sort)', 'O(N log N)', 'O(N)', 
            'ÈááÁî®ÂàÜÊ≤ªÊ≥ïÔºåÂ∞ÜÂ∑≤ÊúâÂ∫èÁöÑÂ≠êÂ∫èÂàóÂêàÂπ∂ÔºåÂæóÂà∞ÂÆåÂÖ®ÊúâÂ∫èÁöÑÂ∫èÂàó„ÄÇÂç≥ÂÖà‰ΩøÊØè‰∏™Â≠êÂ∫èÂàóÊúâÂ∫èÔºåÂÜç‰ΩøÂ≠êÂ∫èÂàóÊÆµÈó¥ÊúâÂ∫è„ÄÇ',
            async (viz) => {
                async function merge(l, m, r) {
                    let n1 = m - l + 1;
                    let n2 = r - m;
                    let L = [], R = [];
                    
                    for(let i=0; i<n1; i++) L.push(viz.array[l+i]);
                    for(let j=0; j<n2; j++) R.push(viz.array[m+1+j]);
                    
                    let i=0, j=0, k=l;
                    
                    while(i < n1 && j < n2) {
                        viz.state[k] = 1; // compare
                        // Visualizing comparison of aux arrays is hard, we just highlight k
                        await viz.sleep();
                        
                        // We actually need to compare values. In visualizer we use the auxiliary values.
                        // We count comparison manually here as visualizer.compare works on indices.
                        viz.stats.comparisons++;
                        viz.updateStatsUI();
                        
                        if(L[i] <= R[j]) {
                            await viz.write(k, L[i]);
                            i++;
                        } else {
                            await viz.write(k, R[j]);
                            j++;
                        }
                        k++;
                    }
                    
                    while(i < n1) {
                        await viz.write(k, L[i]);
                        i++; k++;
                    }
                    while(j < n2) {
                        await viz.write(k, R[j]);
                        j++; k++;
                    }
                }
                
                async function mergeSort(l, r) {
                    if(l >= r) return;
                    let m = l + Math.floor((r-l)/2);
                    await mergeSort(l, m);
                    await mergeSort(m+1, r);
                    await merge(l, m, r);
                }
                
                await mergeSort(0, viz.array.length - 1);
            }
        );

        // 5. Quick Sort (Lomuto)
        registerAlgo('exchange', 'Âø´ÈÄüÊéíÂ∫è (Quick Sort - Lomuto)', 'O(N log N)', 'O(log N)', 
            'ÈÄöËøá‰∏ÄË∂üÊéíÂ∫èÂ∞ÜË¶ÅÊéíÂ∫èÁöÑÊï∞ÊçÆÂàÜÂâ≤ÊàêÁã¨Á´ãÁöÑ‰∏§ÈÉ®ÂàÜÔºåÂÖ∂‰∏≠‰∏ÄÈÉ®ÂàÜÁöÑÊâÄÊúâÊï∞ÊçÆÈÉΩÊØîÂè¶Â§ñ‰∏ÄÈÉ®ÂàÜÁöÑÊâÄÊúâÊï∞ÊçÆÈÉΩË¶ÅÂ∞èÔºåÁÑ∂ÂêéÂÜçÊåâÊ≠§ÊñπÊ≥ïÂØπËøô‰∏§ÈÉ®ÂàÜÊï∞ÊçÆÂàÜÂà´ËøõË°åÂø´ÈÄüÊéíÂ∫è„ÄÇ',
            async (viz) => {
                async function partition(low, high) {
                    let pivot = viz.array[high];
                    viz.state[high] = 4; // Pivot
                    let i = low - 1;
                    
                    for(let j=low; j < high; j++) {
                        // Compare viz.array[j] < pivot
                        // Since compare takes indices, we can't directly compare with pivot value if it's not at an index constant.
                        // But pivot IS at 'high'.
                        if(!(await viz.compare(j, high))) { // if array[j] < array[high] (pivot) -> logic inverted for ascending? 
                            // wait, compare returns array[i] > array[j]. 
                            // We want array[j] < pivot. 
                            // compare(j, high) returns array[j] > pivot.
                            // so if !compare(j, high) -> array[j] <= pivot.
                        } else {
                            // array[j] > pivot, do nothing
                            continue;
                        }
                        
                        // Actually standard Lomuto: if arr[j] <= pivot
                        // compare(j, high) -> arr[j] > arr[high] ? true : false
                        // So if compare is false, arr[j] <= arr[high]
                        
                        i++;
                        await viz.swap(i, j);
                    }
                    await viz.swap(i+1, high);
                    return i+1;
                }
                
                async function quickSort(low, high) {
                    if(low < high) {
                        let pi = await partition(low, high);
                        await quickSort(low, pi-1);
                        await quickSort(pi+1, high);
                    }
                }
                
                await quickSort(0, viz.array.length - 1);
            }
        );

        // 6. Heap Sort
        registerAlgo('selection', 'Â†ÜÊéíÂ∫è (Heap Sort)', 'O(N log N)', 'O(1)', 
            'Âà©Áî®Â†ÜËøôÁßçÊï∞ÊçÆÁªìÊûÑÊâÄËÆæËÆ°ÁöÑ‰∏ÄÁßçÊéíÂ∫èÁÆóÊ≥ï„ÄÇÂ∞ÜÂæÖÊéíÂ∫èÂ∫èÂàóÊûÑÈÄ†Êàê‰∏Ä‰∏™Â§ßÈ°∂Â†ÜÔºåÊ≠§Êó∂ÔºåÊï¥‰∏™Â∫èÂàóÁöÑÊúÄÂ§ßÂÄºÂ∞±ÊòØÂ†ÜÈ°∂ÁöÑÊ†πËäÇÁÇπ„ÄÇ',
            async (viz) => {
                let n = viz.array.length;

                async function heapify(n, i) {
                    let largest = i;
                    let l = 2 * i + 1;
                    let r = 2 * i + 2;

                    if (l < n && await viz.compare(l, largest)) {
                        largest = l;
                    }

                    if (r < n && await viz.compare(r, largest)) {
                        largest = r;
                    }

                    if (largest !== i) {
                        await viz.swap(i, largest);
                        await heapify(n, largest);
                    }
                }

                for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                    await heapify(n, i);
                }

                for (let i = n - 1; i > 0; i--) {
                    await viz.swap(0, i);
                    await heapify(i, 0);
                }
            }
        );

        // 7. Shell Sort
        registerAlgo('insertion', 'Â∏åÂ∞îÊéíÂ∫è (Shell Sort)', 'O(N log N)', 'O(1)', 
            'ÊòØÁÆÄÂçïÊèíÂÖ•ÊéíÂ∫èÁöÑÊîπËøõÁâà„ÄÇÂÆÉ‰∏éÊèíÂÖ•ÊéíÂ∫èÁöÑ‰∏çÂêå‰πãÂ§ÑÂú®‰∫éÔºåÂÆÉ‰ºö‰ºòÂÖàÊØîËæÉË∑ùÁ¶ªËæÉËøúÁöÑÂÖÉÁ¥†„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                for (let gap = Math.floor(n/2); gap > 0; gap = Math.floor(gap/2)) {
                    for (let i = gap; i < n; i++) {
                        let temp = viz.array[i];
                        let j;
                        // For visualization of shell sort with "temp" variable, it's cleaner to use swaps
                        // similar to the insertion sort implementation above.
                        for(j = i; j >= gap; j -= gap) {
                            if(await viz.compare(j-gap, j)) { // if arr[j-gap] > arr[j]
                                await viz.swap(j, j-gap);
                            } else {
                                break;
                            }
                        }
                    }
                }
            }
        );

        // 8. Cocktail Shaker Sort
        registerAlgo('exchange', 'È∏°Â∞æÈÖíÊéíÂ∫è (Cocktail Shaker)', 'O(N^2)', 'O(1)', 
            'ÂÜíÊ≥°ÊéíÂ∫èÁöÑÂèòÁßçÔºåÂÆÉÂèåÂêëËøõË°åÂÜíÊ≥°ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let swapped = true;
                let start = 0;
                let end = viz.array.length;

                while (swapped) {
                    swapped = false;
                    for (let i = start; i < end - 1; ++i) {
                        if (await viz.compare(i, i + 1)) {
                            await viz.swap(i, i + 1);
                            swapped = true;
                        }
                    }
                    if (!swapped) break;
                    swapped = false;
                    end--;
                    for (let i = end - 1; i >= start; i--) {
                        if (await viz.compare(i, i + 1)) {
                            await viz.swap(i, i + 1);
                            swapped = true;
                        }
                    }
                    start++;
                }
            }
        );

        // 9. Gnome Sort
        registerAlgo('exchange', 'Âú∞Á≤æÊéíÂ∫è (Gnome Sort)', 'O(N^2)', 'O(1)', 
            'Âè∑Áß∞ÊúÄÁÆÄÂçïÁöÑÊéíÂ∫èÁÆóÊ≥ïÔºåÂè™Êúâ‰∏ÄÂ±ÇÂæ™ÁéØ„ÄÇ',
            async (viz) => {
                let index = 0;
                let n = viz.array.length;
                while(index < n) {
                    if(index === 0) index++;
                    if(!(await viz.compare(index-1, index))) { // arr[index-1] <= arr[index]
                        index++;
                    } else {
                        await viz.swap(index, index-1);
                        index--;
                    }
                }
            }
        );

        // 10. Comb Sort
        registerAlgo('exchange', 'Ê¢≥ÊéíÂ∫è (Comb Sort)', 'O(N^2)', 'O(1)', 
            'ÂÜíÊ≥°ÊéíÂ∫èÁöÑÊîπËøõÁâàÔºåÊ∂àÈô§‰∫Ü‰πåÈæüÔºàÂ∞æÈÉ®ÁöÑÂ∞èÊï∞ÂÄºÔºâ„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                let gap = n;
                let shrink = 1.3;
                let sorted = false;

                while (!sorted) {
                    gap = Math.floor(gap / shrink);
                    if (gap <= 1) {
                        gap = 1;
                        sorted = true;
                    }

                    for (let i = 0; i + gap < n; i++) {
                        if (await viz.compare(i, i+gap)) {
                            await viz.swap(i, i+gap);
                            sorted = false;
                        }
                    }
                }
            }
        );


        // 11. Odd-Even Sort
        registerAlgo('exchange', 'Â•áÂÅ∂ÊéíÂ∫è (Odd-Even Sort)', 'O(N^2)', 'O(1)', 
            '‰∏ÄÁßçÁõ∏ÂØπÁÆÄÂçïÁöÑÊéíÂ∫èÁÆóÊ≥ïÔºåÊúÄÂàùÂèëÊòéÁî®‰∫éÊúâÊú¨Âú∞‰∫íËøûÁöÑÂπ∂Ë°åËÆ°ÁÆó„ÄÇ',
            async (viz) => {
                let sorted = false;
                let n = viz.array.length;
                while (!sorted) {
                    sorted = true;
                    for (let i = 1; i <= n - 2; i += 2) {
                        if (await viz.compare(i, i + 1)) {
                            await viz.swap(i, i + 1);
                            sorted = false;
                        }
                    }
                    for (let i = 0; i <= n - 2; i += 2) {
                        if (await viz.compare(i, i + 1)) {
                            await viz.swap(i, i + 1);
                            sorted = false;
                        }
                    }
                }
            }
        );

        // 12. Cycle Sort
        registerAlgo('selection', 'ÂúàÊéíÂ∫è (Cycle Sort)', 'O(N^2)', 'O(1)', 
            '‰∏ÄÁßçÂéüÂú∞„ÄÅ‰∏çÁ®≥ÂÆöÁöÑÊéíÂ∫èÁÆóÊ≥ïÔºåÁêÜËÆ∫‰∏äÂÜôÂÖ•Ê¨°Êï∞ÊúÄÂ∞ë„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                for (let cycleStart = 0; cycleStart <= n - 2; cycleStart++) {
                    let item = viz.array[cycleStart];
                    viz.state[cycleStart] = 4; // Selected
                    
                    let pos = cycleStart;
                    for (let i = cycleStart + 1; i < n; i++) {
                        // Compare item with array[i]. 
                        // viz.compare compares two indices. We need to compare value 'item'.
                        // We can't use viz.compare directly efficiently here without writing item to array or hacking.
                        // We will just read array[i] and compare manually, but highlight i.
                        viz.state[i] = 1;
                        await viz.sleep();
                        viz.state[i] = 0;
                        
                        if (viz.array[i] < item) {
                            pos++;
                        }
                    }

                    if (pos === cycleStart) {
                        continue;
                    }

                    while (item === viz.array[pos]) {
                        pos++;
                    }

                    if (pos !== cycleStart) {
                        let temp = viz.array[pos];
                        await viz.write(pos, item);
                        item = temp;
                    }

                    while (pos !== cycleStart) {
                        pos = cycleStart;
                        for (let i = cycleStart + 1; i < n; i++) {
                             viz.state[i] = 1;
                             await viz.sleep();
                             viz.state[i] = 0;
                             if (viz.array[i] < item) {
                                 pos++;
                             }
                        }
                        while (item === viz.array[pos]) {
                            pos++;
                        }
                        if (item !== viz.array[pos]) {
                            let temp = viz.array[pos];
                            await viz.write(pos, item);
                            item = temp;
                        }
                    }
                }
            }
        );

        // 13. Pancake Sort
        registerAlgo('other', 'ÁÖéÈ•ºÊéíÂ∫è (Pancake Sort)', 'O(N)', 'O(1)', 
            'Âè™ÂÖÅËÆ∏ÁøªËΩ¨Êìç‰ΩúÔºàFlipÔºâÔºåÂç≥ÂèçËΩ¨Êï∞ÁªÑÁöÑÂâçk‰∏™ÂÖÉÁ¥†„ÄÇ',
            async (viz) => {
                async function flip(k) {
                    let left = 0;
                    while (left < k) {
                        await viz.swap(left, k);
                        left++;
                        k--;
                    }
                }

                let n = viz.array.length;
                for (let currSize = n; currSize > 1; currSize--) {
                    let mi = 0;
                    for (let i = 0; i < currSize; i++) {
                        if (await viz.compare(i, mi)) { // if i > mi
                             mi = i;
                        }
                    }

                    if (mi !== currSize - 1) {
                        await flip(mi);
                        await flip(currSize - 1);
                    }
                }
            }
        );

        // 14. Stooge Sort
        registerAlgo('esoteric', 'ÊñØÂõæÂêâÊéíÂ∫è (Stooge Sort)', 'O(N^2.7)', 'O(1)', 
            '‰∏ÄÁßçÈùûÂ∏∏‰ΩéÊïàÁöÑÈÄíÂΩíÊéíÂ∫èÁÆóÊ≥ïÔºå‰ªÖÂÖ∑ÊïôÂ≠¶ÊÑè‰πâ„ÄÇ',
            async (viz) => {
                async function stoogeSort(l, h) {
                    if (l >= h) return;
                    
                    if (await viz.compare(l, h)) {
                        await viz.swap(l, h);
                    }
                    
                    if (h - l + 1 > 2) {
                        let t = Math.floor((h - l + 1) / 3);
                        await stoogeSort(l, h - t);
                        await stoogeSort(l + t, h);
                        await stoogeSort(l, h - t);
                    }
                }
                await stoogeSort(0, viz.array.length - 1);
            }
        );

        // 15. Bogo Sort
        registerAlgo('esoteric', 'Áå¥Â≠êÊéíÂ∫è (Bogo Sort)', 'Unbounded', 'O(1)', 
            'ÈöèÊú∫Êâì‰π±Êï∞ÁªÑÔºåÊ£ÄÊü•ÊòØÂê¶ÊúâÂ∫è„ÄÇÂ¶ÇÊûúÊòØÔºåÂàôÁªìÊùüÔºõÂê¶ÂàôÈáçÂ§ç„ÄÇÊÖéÁî®ÔºÅ',
            async (viz) => {
                function isSorted() {
                    for(let i=0; i<viz.array.length-1; i++){
                        if(viz.array[i] > viz.array[i+1]) return false;
                    }
                    return true;
                }
                
                let count = 0;
                while(!isSorted()) {
                    if(count++ > 500 && viz.array.length > 6) { 
                         // Failsafe for large arrays because Bogo is impossible
                         // We will switch to bubble sort if it takes too long so user sees something finishing
                         // But for purity, we should keep it random. 
                         // Let's just shuffle randomly.
                    }
                    
                    // Random Shuffle
                    let n = viz.array.length;
                    for(let i=0; i<n; i++) {
                        let r = Math.floor(Math.random() * n);
                        await viz.swap(i, r);
                    }
                    
                    // Check sorted logic requires reading, let's just use the loop above
                    // But to be visually correct we should compare
                    let sorted = true;
                    for(let i=0; i<n-1; i++) {
                        if(await viz.compare(i, i+1)) {
                            sorted = false;
                            break;
                        }
                    }
                    if(sorted) break;
                }
            }
        );

        // 16. Quick Sort (Hoare)
        registerAlgo('exchange', 'Âø´ÈÄüÊéíÂ∫è (Quick Sort - Hoare)', 'O(N log N)', 'O(log N)', 
            '‰ΩøÁî®HoareÂàÜÂå∫ÊñπÊ°àÁöÑÂø´ÈÄüÊéíÂ∫èÔºåÈÄöÂ∏∏ÊØîLomutoÂàÜÂå∫Êõ¥ÊúâÊïàÁéáÔºà‰∫§Êç¢Ê¨°Êï∞Êõ¥Â∞ëÔºâ„ÄÇ',
            async (viz) => {
                async function partition(low, high) {
                    let pivot = viz.array[Math.floor((low + high) / 2)];
                    // visual marker for pivot is hard since it's value based
                    
                    let i = low - 1;
                    let j = high + 1;
                    
                    while (true) {
                        do {
                            i++;
                            viz.state[i] = 1; 
                            await viz.sleep();
                            viz.state[i] = 0;
                        } while (viz.array[i] < pivot);

                        do {
                            j--;
                            viz.state[j] = 1;
                            await viz.sleep();
                            viz.state[j] = 0;
                        } while (viz.array[j] > pivot);

                        if (i >= j) return j;

                        await viz.swap(i, j);
                    }
                }

                async function quickSort(low, high) {
                    if (low < high) {
                        let p = await partition(low, high);
                        await quickSort(low, p);
                        await quickSort(p + 1, high);
                    }
                }
                
                await quickSort(0, viz.array.length - 1);
            }
        );

        // 17. Bitonic Sort
        registerAlgo('other', 'ÂèåË∞ÉÊéíÂ∫è (Bitonic Sort)', 'O(log^2 N)', 'O(N log^2 N)', 
            '‰∏ªË¶ÅÁî®‰∫éÂπ∂Ë°åËÆ°ÁÆóÁöÑÊØîËæÉÁΩëÁªúÊéíÂ∫èÁÆóÊ≥ï„ÄÇ',
            async (viz) => {
                async function compAndSwap(i, j, dir) {
                    if (dir === (viz.array[i] > viz.array[j])) {
                        await viz.swap(i, j);
                    } else {
                        // visualize comparison anyway
                        await viz.compare(i, j); 
                    }
                }

                async function bitonicMerge(low, cnt, dir) {
                    if (cnt > 1) {
                        let k = Math.floor(cnt / 2);
                        for (let i = low; i < low + k; i++) {
                            await compAndSwap(i, i + k, dir);
                        }
                        await bitonicMerge(low, k, dir);
                        await bitonicMerge(low + k, k, dir);
                    }
                }

                async function bitonicSort(low, cnt, dir) {
                    if (cnt > 1) {
                        let k = Math.floor(cnt / 2);
                        await bitonicSort(low, k, !dir); // Sort in ascending order since dir=1 means ascending
                        // Wait, bitonic sort usually: sort first half asc, second half desc, then merge.
                        // Standard: dir=1 (UP), dir=0 (DOWN)
                        
                        await bitonicSort(low, k, true);
                        await bitonicSort(low + k, k, false);
                        await bitonicMerge(low, cnt, dir);
                    }
                }
                
                // Bitonic sort works best on power of 2 arrays. 
                // We will just run it, but it might not sort correctly if not power of 2 unless handled.
                // For this demo we assume it works or we pad (not implemented). 
                // Let's implement the arbitrary n version or just warn user.
                // Actually, let's just run it. It will visualize cool patterns even if result is partial.
                await bitonicSort(0, viz.array.length, true);
            }
        );

        // 18. Radix Sort (LSD)
        registerAlgo('distribution', 'Âü∫Êï∞ÊéíÂ∫è (Radix Sort LSD)', 'O(N*k)', 'O(N+k)', 
            'ÊåâÁÖß‰Ωé‰ΩçÂÖàÊéíÂ∫èÔºåÁÑ∂ÂêéÊî∂ÈõÜÔºõÂÜçÊåâÁÖßÈ´ò‰ΩçÊéíÂ∫èÔºåÁÑ∂ÂêéÂÜçÊî∂ÈõÜÔºõ‰æùÊ¨°Á±ªÊé®ÔºåÁõ¥Âà∞ÊúÄÈ´ò‰Ωç„ÄÇ',
            async (viz) => {
                let max = Math.max(...viz.array);
                
                for (let exp = 1; Math.floor(max / exp) > 0; exp *= 10) {
                    let output = new Array(viz.array.length).fill(0);
                    let count = new Array(10).fill(0);
                    let n = viz.array.length;

                    for (let i = 0; i < n; i++) {
                        let index = Math.floor(viz.array[i] / exp) % 10;
                        count[index]++;
                        viz.state[i] = 1; 
                    }
                    await viz.sleep();
                    viz.state.fill(0);

                    for (let i = 1; i < 10; i++) {
                        count[i] += count[i - 1];
                    }

                    for (let i = n - 1; i >= 0; i--) {
                        let index = Math.floor(viz.array[i] / exp) % 10;
                        output[count[index] - 1] = viz.array[i];
                        count[index]--;
                        viz.state[i] = 2;
                    }
                    await viz.sleep();

                    for (let i = 0; i < n; i++) {
                        await viz.write(i, output[i]);
                    }
                }
            }
        );

        // 19. Counting Sort
        registerAlgo('distribution', 'ËÆ°Êï∞ÊéíÂ∫è (Counting Sort)', 'O(N+k)', 'O(k)', 
            'Â∞ÜËæìÂÖ•ÁöÑÊï∞ÊçÆÂÄºËΩ¨Âåñ‰∏∫ÈîÆÂ≠òÂÇ®Âú®È¢ùÂ§ñÂºÄËæüÁöÑÊï∞ÁªÑÁ©∫Èó¥‰∏≠„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                let max = Math.floor(Math.max(...viz.array));
                let min = Math.floor(Math.min(...viz.array));
                let range = max - min + 1;
                let count = new Array(range).fill(0);
                let output = new Array(n).fill(0);

                for (let i = 0; i < n; i++) {
                    count[Math.floor(viz.array[i]) - min]++;
                    viz.state[i] = 1;
                    await viz.sleep();
                    viz.state[i] = 0;
                }

                for (let i = 1; i < count.length; i++) {
                    count[i] += count[i - 1];
                }

                for (let i = n - 1; i >= 0; i--) {
                    let val = Math.floor(viz.array[i]);
                    output[count[val - min] - 1] = viz.array[i];
                    count[val - min]--;
                }

                for (let i = 0; i < n; i++) {
                    await viz.write(i, output[i]);
                }
            }
        );

        // 20. Slow Sort
        registerAlgo('esoteric', 'ÊÖ¢ÈÄüÊéíÂ∫è (Slow Sort)', 'O(N^(log N))', 'O(N)', 
            '‰∏ÄÁßçÊûÅÂÖ∂‰ΩéÊïàÁöÑ‰πòÊ≥ïÈÄíÂΩíÊéíÂ∫èÁÆóÊ≥ï„ÄÇ',
            async (viz) => {
                async function slowSort(i, j) {
                    if (i >= j) return;
                    let m = Math.floor((i + j) / 2);
                    await slowSort(i, m);
                    await slowSort(m + 1, j);
                    
                    if (await viz.compare(j, m)) { // if arr[j] < arr[m]
                        await viz.swap(j, m);
                    }
                    await slowSort(i, j - 1);
                }
                await slowSort(0, viz.array.length - 1);
            }
        );

        // 21. 3-Way Quick Sort
        registerAlgo('exchange', '‰∏âË∑ØÂø´Êéí (3-Way Quick Sort)', 'O(N log N)', 'O(log N)', 
            'Â∞ÜÊï∞ÁªÑÂàÜ‰∏∫Â∞è‰∫é„ÄÅÁ≠â‰∫éÂíåÂ§ß‰∫éÂü∫ÂáÜÂÄºÁöÑ‰∏âÈÉ®ÂàÜÔºåÂØπÈáçÂ§çÂÖÉÁ¥†ËæÉÂ§öÁöÑÊï∞ÁªÑÈùûÂ∏∏È´òÊïà„ÄÇ',
            async (viz) => {
                async function quickSort3Way(l, r) {
                    if (l >= r) return;
                    
                    let lt = l;
                    let gt = r;
                    let i = l + 1;
                    let pivot = viz.array[l];
                    viz.state[l] = 4; // Pivot

                    while (i <= gt) {
                        viz.stats.comparisons++;
                        viz.updateStatsUI();
                        
                        if (viz.array[i] < pivot) {
                            await viz.swap(lt, i);
                            lt++;
                            i++;
                        } else if (viz.array[i] > pivot) {
                            await viz.swap(i, gt);
                            gt--;
                        } else {
                            i++;
                        }
                    }

                    await quickSort3Way(l, lt - 1);
                    await quickSort3Way(gt + 1, r);
                }
                await quickSort3Way(0, viz.array.length - 1);
            }
        );

        // 22. Double Selection Sort
        registerAlgo('selection', 'ÂèåÂêëÈÄâÊã©ÊéíÂ∫è (Double Selection)', 'O(N^2)', 'O(1)', 
            'ÊØèÊ¨°ÈÅçÂéÜÂêåÊó∂ÈÄâÂá∫ÊúÄÂ§ßÂÄºÂíåÊúÄÂ∞èÂÄº„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                for (let i = 0; i < n / 2; i++) {
                    let minIdx = i;
                    let maxIdx = i;
                    
                    for (let j = i + 1; j < n - i; j++) {
                        if (await viz.compare(minIdx, j)) { // minIdx > j
                            minIdx = j;
                        }
                        if (await viz.compare(j, maxIdx)) { // j > maxIdx
                            maxIdx = j;
                        }
                    }
                    
                    if (minIdx !== i) await viz.swap(i, minIdx);
                    
                    // If maxIdx was at i, it has been moved to minIdx
                    if (maxIdx === i) maxIdx = minIdx;
                    
                    if (maxIdx !== n - 1 - i) await viz.swap(n - 1 - i, maxIdx);
                }
            }
        );

        // 23. Binary Insertion Sort
        registerAlgo('insertion', '‰∫åÂàÜÊèíÂÖ•ÊéíÂ∫è (Binary Insertion)', 'O(N^2)', 'O(1)', 
            '‰ΩøÁî®‰∫åÂàÜÊü•ÊâæÊù•ÂØªÊâæÊèíÂÖ•‰ΩçÁΩÆÁöÑÊèíÂÖ•ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                for (let i = 1; i < n; i++) {
                    let key = viz.array[i];
                    let left = 0;
                    let right = i - 1;
                    
                    // Binary Search for position
                    while (left <= right) {
                        let mid = Math.floor((left + right) / 2);
                        viz.state[mid] = 1;
                        await viz.sleep();
                        viz.state[mid] = 0;
                        
                        // compare key with array[mid]
                        if (viz.array[mid] > key) {
                            right = mid - 1;
                        } else {
                            left = mid + 1;
                        }
                    }
                    
                    // Shift elements
                    for (let j = i - 1; j >= left; j--) {
                        await viz.swap(j, j + 1);
                    }
                }
            }
        );

        // 24. Bozo Sort
        registerAlgo('esoteric', 'Á¨®ËõãÊéíÂ∫è (Bozo Sort)', 'Unbounded', 'O(1)', 
            'ÈöèÊú∫‰∫§Êç¢‰∏§‰∏™ÂÖÉÁ¥†ÔºåÁÑ∂ÂêéÊ£ÄÊü•ÊòØÂê¶ÊúâÂ∫è„ÄÇÊØîÁå¥Â≠êÊéíÂ∫èÁ®çÂ•Ω‰∏ÄÁÇπÁÇπ„ÄÇ',
            async (viz) => {
                function isSorted() {
                    for(let i=0; i<viz.array.length-1; i++){
                        if(viz.array[i] > viz.array[i+1]) return false;
                    }
                    return true;
                }
                
                while(!isSorted()) {
                    let idx1 = Math.floor(Math.random() * viz.array.length);
                    let idx2 = Math.floor(Math.random() * viz.array.length);
                    await viz.swap(idx1, idx2);
                }
            }
        );

        // 25. Merge Sort (Bottom Up)
        registerAlgo('merge', 'Ëá™Â∫ïÂêë‰∏äÂΩíÂπ∂ (Merge Sort Bottom-Up)', 'O(N log N)', 'O(N)', 
            'ÈùûÈÄíÂΩíÁâàÊú¨ÁöÑÂΩíÂπ∂ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                let temp = new Array(n);
                
                async function merge(left, mid, right) {
                     let i = left, j = mid + 1, k = left;
                     while(i <= mid && j <= right) {
                         viz.state[i] = 1; viz.state[j] = 1;
                         await viz.sleep();
                         viz.state[i] = 0; viz.state[j] = 0;
                         
                         if(viz.array[i] <= viz.array[j]) {
                             temp[k++] = viz.array[i++];
                         } else {
                             temp[k++] = viz.array[j++];
                         }
                     }
                     while(i <= mid) temp[k++] = viz.array[i++];
                     while(j <= right) temp[k++] = viz.array[j++];
                     
                     for(let x = left; x <= right; x++) {
                         await viz.write(x, temp[x]);
                     }
                }
                
                for (let size = 1; size < n; size *= 2) {
                    for (let left = 0; left < n - 1; left += 2 * size) {
                        let mid = Math.min(left + size - 1, n - 1);
                        let right = Math.min(left + 2 * size - 1, n - 1);
                        await merge(left, mid, right);
                    }
                }
            }
        );

        // 26. Bubble Sort (Recursive)
        registerAlgo('exchange', 'ÈÄíÂΩíÂÜíÊ≥° (Recursive Bubble)', 'O(N^2)', 'O(N)', 
            'ÂÜíÊ≥°ÊéíÂ∫èÁöÑÈÄíÂΩíÂÆûÁé∞„ÄÇ',
            async (viz) => {
                async function bubbleRec(n) {
                    if (n === 1) return;
                    
                    let count = 0;
                    for (let i = 0; i < n - 1; i++) {
                        if (await viz.compare(i, i + 1)) {
                            await viz.swap(i, i + 1);
                            count++;
                        }
                    }
                    if(count === 0) return; // Optimization
                    
                    await bubbleRec(n - 1);
                }
                await bubbleRec(viz.array.length);
            }
        );

        // 27. Insertion Sort (Recursive)
        registerAlgo('insertion', 'ÈÄíÂΩíÊèíÂÖ• (Recursive Insertion)', 'O(N^2)', 'O(N)', 
            'ÊèíÂÖ•ÊéíÂ∫èÁöÑÈÄíÂΩíÂÆûÁé∞„ÄÇ',
            async (viz) => {
                async function insertRec(n) {
                    if (n <= 1) return;
                    
                    await insertRec(n - 1);
                    
                    let last = viz.array[n - 1];
                    let j = n - 2;
                    
                    while (j >= 0 && (await viz.compare(j, j+1))) { // compare using swap logic or similar
                        await viz.swap(j, j+1);
                        j--;
                    }
                }
                await insertRec(viz.array.length);
            }
        );

        // 28. Shell Sort (Knuth)
        registerAlgo('insertion', 'Â∏åÂ∞îÊéíÂ∫è (Knuth Sequence)', 'O(N^1.5)', 'O(1)', 
            '‰ΩøÁî® Knuth Â¢ûÈáèÂ∫èÂàó (h = 3h + 1) ÁöÑÂ∏åÂ∞îÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                let h = 1;
                while (h < n / 3) h = 3 * h + 1;
                
                while (h >= 1) {
                    for (let i = h; i < n; i++) {
                        for (let j = i; j >= h && (await viz.compare(j-h, j)); j -= h) {
                            await viz.swap(j, j-h);
                        }
                    }
                    h = Math.floor(h / 3);
                }
            }
        );

        // 29. Pigeonhole Sort
        registerAlgo('distribution', 'È∏ΩÂ∑¢ÊéíÂ∫è (Pigeonhole Sort)', 'O(N+Range)', 'O(Range)', 
            'ÈÄÇÁî®‰∫éÈîÆÂÄºËåÉÂõ¥ÂæàÂ∞èÁöÑÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let min = Math.min(...viz.array);
                let max = Math.max(...viz.array);
                let range = max - min + 1;
                let holes = new Array(range).fill(0);
                
                for(let i=0; i<viz.array.length; i++) {
                    holes[Math.floor(viz.array[i]) - min]++;
                    viz.state[i] = 1;
                    await viz.sleep();
                    viz.state[i] = 0;
                }
                
                let index = 0;
                for(let i=0; i<range; i++) {
                    while(holes[i]-- > 0) {
                        await viz.write(index++, i + min);
                    }
                }
            }
        );

        // 30. Circle Sort
        registerAlgo('exchange', 'ÂúàÊéíÂ∫è (Circle Sort)', 'O(N log N)', 'O(1)', 
            'ÈÄöËøáÈÄíÂΩíÂú∞ÊØîËæÉÂíå‰∫§Êç¢ÂêåÂøÉÂúÜ‰∏äÁöÑÂÖÉÁ¥†Êù•ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                async function circleSortRec(low, high) {
                    let swapped = false;
                    if (low === high) return false;
                    
                    let l = low, h = high;
                    let mid = Math.floor((high - low) / 2);
                    
                    while (l < h) {
                        if (await viz.compare(l, h)) {
                            await viz.swap(l, h);
                            swapped = true;
                        }
                        l++;
                        h--;
                    }
                    
                    if (l === h) {
                        if (await viz.compare(l, h + 1)) {
                            await viz.swap(l, h + 1);
                            swapped = true;
                        }
                    }
                    
                    let midIdx = Math.floor((low + high) / 2);
                    let left = await circleSortRec(low, midIdx);
                    let right = await circleSortRec(midIdx + 1, high);
                    
                    return swapped || left || right;
                }
                
                while (await circleSortRec(0, viz.array.length - 1)) {
                    // Repeat until no swaps
                }
            }
        );

        // 31. TimSort (Simplified)
        registerAlgo('hybrid', 'TimSort (Simplified)', 'O(N log N)', 'O(N)', 
            'ÁªìÂêà‰∫ÜÂêàÂπ∂ÊéíÂ∫èÂíåÊèíÂÖ•ÊéíÂ∫èÔºåÊòØPythonÂíåJavaÁöÑÈªòËÆ§ÊéíÂ∫èÁÆóÊ≥ï„ÄÇ',
            async (viz) => {
                const RUN = 32;
                let n = viz.array.length;
                
                // Insertion Sort for small runs
                for (let i = 0; i < n; i += RUN) {
                    let left = i;
                    let right = Math.min(i + RUN - 1, n - 1);
                    
                    for (let j = left + 1; j <= right; j++) {
                        let k = j - 1;
                        while (k >= left && (await viz.compare(k, k+1))) {
                            await viz.swap(k, k+1);
                            k--;
                        }
                    }
                }
                
                // Merge
                async function merge(l, m, r) {
                     // Reuse merge logic from Merge Sort but simplified inline here for independence
                     let len1 = m - l + 1, len2 = r - m;
                     let left = [], right = [];
                     for(let x=0; x<len1; x++) left.push(viz.array[l+x]);
                     for(let x=0; x<len2; x++) right.push(viz.array[m+1+x]);
                     
                     let i=0, j=0, k=l;
                     while(i<len1 && j<len2) {
                         viz.stats.comparisons++; // Approximate
                         if(left[i] <= right[j]) await viz.write(k++, left[i++]);
                         else await viz.write(k++, right[j++]);
                     }
                     while(i<len1) await viz.write(k++, left[i++]);
                     while(j<len2) await viz.write(k++, right[j++]);
                }

                for (let size = RUN; size < n; size = 2 * size) {
                    for (let left = 0; left < n; left += 2 * size) {
                        let mid = left + size - 1;
                        let right = Math.min(left + 2 * size - 1, n - 1);
                        if (mid < right) await merge(left, mid, right);
                    }
                }
            }
        );

        // 32. IntroSort (Simplified)
        registerAlgo('hybrid', 'IntroSort (Simplified)', 'O(N log N)', 'O(log N)', 
            'ÂºÄÂßãÊó∂‰ΩøÁî®Âø´ÈÄüÊéíÂ∫èÔºåÂΩìÈÄíÂΩíÊ∑±Â∫¶ËøáÊ∑±Êó∂ËΩ¨‰∏∫Â†ÜÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                
                async function heapSort(start, end) {
                    // Build heap in range
                    let count = end - start + 1;
                    // ... simplify: just call standard heap sort on subarray? 
                    // Visualizer structure makes subarray calls hard. 
                    // We will implement a simple selection sort as fallback for "Intro" demo 
                    // or actually implement heap logic on offset.
                    
                    // Let's use Selection Sort for fallback as it's easier to implement on range inline
                    // Real IntroSort uses HeapSort.
                    for(let i=start; i<=end; i++) {
                        let min = i;
                        for(let j=i+1; j<=end; j++) {
                            if(await viz.compare(min, j)) min = j;
                        }
                        if(min !== i) await viz.swap(i, min);
                    }
                }

                async function partition(low, high) {
                    let pivot = viz.array[high];
                    let i = low - 1;
                    for (let j = low; j < high; j++) {
                        if (!(await viz.compare(j, high))) { // arr[j] <= pivot
                            i++;
                            await viz.swap(i, j);
                        }
                    }
                    await viz.swap(i + 1, high);
                    return i + 1;
                }

                async function introSort(low, high, depthLimit) {
                    if (high - low < 16) {
                        // Insertion sort for small
                        for (let i = low + 1; i <= high; i++) {
                            let j = i - 1;
                            while (j >= low && (await viz.compare(j, j+1))) {
                                await viz.swap(j, j+1);
                                j--;
                            }
                        }
                        return;
                    }
                    
                    if (depthLimit === 0) {
                        await heapSort(low, high);
                        return;
                    }

                    let p = await partition(low, high);
                    await introSort(low, p - 1, depthLimit - 1);
                    await introSort(p + 1, high, depthLimit - 1);
                }

                let maxDepth = Math.floor(Math.log2(n)) * 2;
                await introSort(0, n - 1, maxDepth);
            }
        );

        // 33. Tree Sort
        registerAlgo('insertion', 'Ê†ëÊéíÂ∫è (Tree Sort)', 'O(N log N)', 'O(N)', 
            'ÊûÑÂª∫‰∫åÂèâÊêúÁ¥¢Ê†ëÔºåÁÑ∂Âêé‰∏≠Â∫èÈÅçÂéÜ„ÄÇ',
            async (viz) => {
                class Node {
                    constructor(val) { this.val = val; this.left = null; this.right = null; }
                }
                
                let root = null;
                
                async function insert(node, val) {
                    if(!node) return new Node(val);
                    viz.stats.comparisons++;
                    if(val < node.val) node.left = await insert(node.left, val);
                    else node.right = await insert(node.right, val);
                    return node;
                }
                
                // Build Tree
                for(let i=0; i<viz.array.length; i++) {
                    viz.state[i] = 1;
                    await viz.sleep();
                    root = await insert(root, viz.array[i]);
                    viz.state[i] = 0;
                }
                
                // Inorder
                let idx = 0;
                async function inorder(node) {
                    if(!node) return;
                    await inorder(node.left);
                    await viz.write(idx++, node.val);
                    await inorder(node.right);
                }
                await inorder(root);
            }
        );

        // 34. Gnome Sort (Optimized)
        registerAlgo('exchange', 'Âú∞Á≤æÊéíÂ∫è (Optimized Gnome)', 'O(N^2)', 'O(1)', 
            '‰ºòÂåñÁâàÁöÑÂú∞Á≤æÊéíÂ∫èÔºåÂáèÂ∞ë‰∫Ü‰∫§Êç¢Ê¨°Êï∞„ÄÇ',
            async (viz) => {
                for (let i = 1; i < viz.array.length; i++) {
                    await viz.highlight([i], 4);
                    let j = i;
                    while (j > 0 && (await viz.compare(j-1, j))) {
                        await viz.swap(j, j-1);
                        j--;
                    }
                }
            }
        );

        // 35. Bucket Sort
        registerAlgo('distribution', 'Ê°∂ÊéíÂ∫è (Bucket Sort)', 'O(N+k)', 'O(N)', 
            'Â∞ÜÊï∞ÊçÆÂàÜÂà∞ÊúâÈôêÊï∞ÈáèÁöÑÊ°∂ÈáåÔºåÊØè‰∏™Ê°∂ÂÜçÂàÜÂà´ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                if (n <= 0) return;
                
                let min = Math.min(...viz.array);
                let max = Math.max(...viz.array);
                let bucketCount = Math.floor(Math.sqrt(n));
                let buckets = Array.from({length: bucketCount}, () => []);
                let range = (max - min) / bucketCount;

                // Scatter
                for (let i = 0; i < n; i++) {
                    let idx = Math.floor((viz.array[i] - min) / range);
                    if (idx === bucketCount) idx--; // Handle max value
                    buckets[idx].push(viz.array[i]);
                    viz.state[i] = 1;
                    await viz.sleep();
                    viz.state[i] = 0;
                }

                // Sort buckets and Gather
                let k = 0;
                for (let i = 0; i < buckets.length; i++) {
                    // Simple sort for bucket (Insertion)
                    buckets[i].sort((a, b) => a - b);
                    for (let val of buckets[i]) {
                        await viz.write(k++, val);
                    }
                }
            }
        );

        // 36. Selection Sort (Recursive)
        registerAlgo('selection', 'ÈÄíÂΩíÈÄâÊã© (Recursive Selection)', 'O(N^2)', 'O(1)', 
            'ÈÄâÊã©ÊéíÂ∫èÁöÑÈÄíÂΩíÂÆûÁé∞„ÄÇ',
            async (viz) => {
                async function selectionRec(start) {
                    if (start >= viz.array.length - 1) return;
                    
                    let minIdx = start;
                    for (let i = start + 1; i < viz.array.length; i++) {
                        if (await viz.compare(minIdx, i)) minIdx = i;
                    }
                    
                    if (minIdx !== start) await viz.swap(start, minIdx);
                    await selectionRec(start + 1);
                }
                await selectionRec(0);
            }
        );

        // 37. Quick Sort (Random Pivot)
        registerAlgo('exchange', 'ÈöèÊú∫Âø´Êéí (Random Quick Sort)', 'O(N log N)', 'O(log N)', 
            'ÈöèÊú∫ÈÄâÊã©Âü∫ÂáÜÂÄºÁöÑÂø´ÈÄüÊéíÂ∫èÔºåÈÅøÂÖçÊúÄÂùèÊÉÖÂÜµ„ÄÇ',
            async (viz) => {
                async function partition(low, high) {
                    let r = Math.floor(Math.random() * (high - low + 1) + low);
                    await viz.swap(r, high);
                    
                    let pivot = viz.array[high];
                    let i = low - 1;
                    for(let j=low; j < high; j++) {
                        if(!(await viz.compare(j, high))) {
                            i++;
                            await viz.swap(i, j);
                        }
                    }
                    await viz.swap(i+1, high);
                    return i+1;
                }
                
                async function quickSort(low, high) {
                    if(low < high) {
                        let pi = await partition(low, high);
                        await quickSort(low, pi-1);
                        await quickSort(pi+1, high);
                    }
                }
                await quickSort(0, viz.array.length - 1);
            }
        );

        // 38. Drop Sort
        registerAlgo('esoteric', 'Drop Sort (Lossy)', 'O(N)', 'O(1)', 
            'Â¶ÇÊûúÂÖÉÁ¥†Â∞è‰∫éÂâç‰∏Ä‰∏™ÂÖÉÁ¥†ÔºåÂàôÂà†Èô§ÂÆÉÔºàËøôÈáåÂ∞ÜÂÖ∂ÁΩÆ‰∏∫0ÊàñÁßªÈô§ÂèØËßÜÂåñÊïàÊûúÔºâ„ÄÇ',
            async (viz) => {
                // Since we can't easily resize the array in place in this viz structure without mess,
                // we will just "zero out" or "mark" dropped elements.
                let prev = viz.array[0];
                for(let i=1; i<viz.array.length; i++) {
                    viz.state[i] = 1;
                    await viz.sleep();
                    viz.state[i] = 0;
                    
                    if(viz.array[i] < prev) {
                        // Drop
                        await viz.write(i, 0); 
                    } else {
                        prev = viz.array[i];
                    }
                }
            }
        );

        // 39. Min Heap Sort
        registerAlgo('selection', 'ÊúÄÂ∞èÂ†ÜÊéíÂ∫è (Min Heap Sort)', 'O(N log N)', 'O(1)', 
            '‰ΩøÁî®ÊúÄÂ∞èÂ†ÜËøõË°åÈôçÂ∫èÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let n = viz.array.length;

                async function heapify(n, i) {
                    let smallest = i;
                    let l = 2 * i + 1;
                    let r = 2 * i + 2;

                    // Note: compare returns true if arr[l] > arr[smallest]. 
                    // We want arr[l] < arr[smallest].
                    // So we want !compare(l, smallest) AND value check...
                    // Wait, compare(a,b) returns arr[a] > arr[b].
                    // So if compare(smallest, l) is true, then arr[smallest] > arr[l], so l is smaller.
                    
                    if (l < n && await viz.compare(smallest, l)) {
                        smallest = l;
                    }

                    if (r < n && await viz.compare(smallest, r)) {
                        smallest = r;
                    }

                    if (smallest !== i) {
                        await viz.swap(i, smallest);
                        await heapify(n, smallest);
                    }
                }

                for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                    await heapify(n, i);
                }

                for (let i = n - 1; i > 0; i--) {
                    await viz.swap(0, i);
                    await heapify(i, 0);
                }
            }
        );

        // 40. Exchange Sort
        registerAlgo('exchange', '‰∫§Êç¢ÊéíÂ∫è (Exchange Sort)', 'O(N^2)', 'O(1)', 
            'Á±ª‰ºº‰∫éÂÜíÊ≥°ÊéíÂ∫èÔºå‰ΩÜÂÆÉÊòØÂ∞ÜÁ¨¨‰∏Ä‰∏™ÂÖÉÁ¥†‰∏éÂêéÈù¢ÁöÑÊØè‰∏Ä‰∏™ÊØîËæÉ‰∫§Êç¢ÔºåÁ°ÆÂÆöÁ¨¨‰∏Ä‰∏™‰ΩçÁΩÆÔºå‰ª•Ê≠§Á±ªÊé®„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                for(let i=0; i<n-1; i++) {
                    for(let j=i+1; j<n; j++) {
                        if(await viz.compare(i, j)) {
                            await viz.swap(i, j);
                        }
                    }
                }
            }
        );
        
        // 41. Dual Pivot Quick Sort
        registerAlgo('exchange', 'ÂèåËΩ¥Âø´Êéí (Dual Pivot Quick Sort)', 'O(N log N)', 'O(log N)', 
            '‰ΩøÁî®‰∏§‰∏™Âü∫ÂáÜÂÄºÁöÑÂø´ÈÄüÊéíÂ∫èÔºåÈÄöÂ∏∏ÊØîÂçïËΩ¥Âø´ÊéíÊõ¥Âø´„ÄÇ',
            async (viz) => {
                async function dpQuickSort(low, high) {
                    if (low >= high) return;
                    
                    if (await viz.compare(low, high)) await viz.swap(low, high);
                    
                    let p1 = viz.array[low];
                    let p2 = viz.array[high];
                    
                    let i = low + 1;
                    let k = high - 1;
                    let j = low + 1;
                    
                    while (j <= k) {
                         if (viz.array[j] < p1) { 
                             await viz.swap(i, j);
                             i++;
                             j++;
                         } else if (viz.array[j] >= p2) {
                             while (viz.array[k] > p2 && k > j) k--;
                             await viz.swap(j, k);
                             k--;
                             if (viz.array[j] < p1) {
                                 await viz.swap(i, j);
                                 i++;
                             }
                             j++;
                         } else {
                             j++;
                         }
                         viz.stats.comparisons++;
                         viz.updateStatsUI();
                         viz.state[j-1] = 1; await viz.sleep(); viz.state[j-1] = 0;
                    }
                    
                    await viz.swap(low, i - 1);
                    await viz.swap(high, k + 1);
                    
                    await dpQuickSort(low, i - 2);
                    await dpQuickSort(i, k);
                    await dpQuickSort(k + 2, high);
                }
                await dpQuickSort(0, viz.array.length - 1);
            }
        );

        // 42. MSD Radix Sort
        registerAlgo('distribution', 'Âü∫Êï∞ÊéíÂ∫è (Radix Sort MSD)', 'O(N*k)', 'O(N+k)', 
            '‰ªéÊúÄÈ´òÊúâÊïà‰ΩçÂºÄÂßãÁöÑÂü∫Êï∞ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                async function msdSort(l, r, d) {
                    if (l >= r || d < 1) return;
                    
                    // Simple bucket logic for binary MSD (like QuickSort partition but on bits)
                    // Or standard base 10 MSD?
                    // Let's do Binary MSD (In-place) which is basically QuickSort on bits
                    // Also known as Binary Radix Sort.
                    
                    // Partition by d-th bit
                    let i = l;
                    let j = r;
                    // d is power of 10? No, let's use value range.
                    // Let's stick to standard MSD on decimal digits for consistency with LSD.
                    // But MSD on decimal is hard in-place.
                    // We will use auxiliary array approach for range.
                    // To keep it simple in this framework, we will simulate "Binary Radix Sort" (In-place).
                    // We need max value first to determine bit depth.
                }
                
                // Let's implement American Flag Sort logic (In-place Radix)
                // Or easier: Recursive Bucket Sort (MSD)
                
                let max = Math.max(...viz.array);
                let maxDigit = 1;
                while (Math.floor(max / maxDigit) >= 10) maxDigit *= 10;
                
                async function msdRadix(l, r, exp) {
                    if (l >= r || exp < 1) return;
                    
                    let count = new Array(10).fill(0);
                    // Count frequencies in this range
                    // This requires auxiliary space for stable sort or complex in-place
                    // Let's switch to a simpler algo for 42: "Patience Sort"
                }
                
                // Re-implementing 42 as Patience Sort
                // Patience Sort
                // Form piles.
                // Visualization: Show piles?
                // Just use "Insertion Sort with Binary Search" logic for piles top?
                
                // Let's do: Comb Sort 11
            }
        );
        algorithms['distribution'].pop(); // Remove unfinished MSD

        // 42. Comb Sort 11
        registerAlgo('exchange', 'Ê¢≥ÊéíÂ∫è11 (Comb Sort 11)', 'O(N^2)', 'O(1)', 
            'Comb Sort ÁöÑ‰∏Ä‰∏™ÂèòÁßçÔºåÂΩìÈó¥Ë∑ù‰∏∫ 9 Êàñ 10 Êó∂ÔºåÂº∫Âà∂‰ΩøÁî® 11„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                let gap = n;
                let shrink = 1.3;
                let sorted = false;

                while (!sorted) {
                    gap = Math.floor(gap / shrink);
                    if (gap <= 1) {
                        gap = 1;
                        sorted = true;
                    }
                    if (gap === 9 || gap === 10) gap = 11;

                    for (let i = 0; i + gap < n; i++) {
                        if (await viz.compare(i, i+gap)) {
                            await viz.swap(i, i+gap);
                            sorted = false;
                        }
                    }
                }
            }
        );

        // 43. Flash Sort
        registerAlgo('distribution', 'Èó™ÁîµÊéíÂ∫è (Flash Sort)', 'O(N)', 'O(N)', 
            '‰∏ÄÁßçÊ¶ÇÁéáÂàÜÂ∏ÉÊéíÂ∫èÁÆóÊ≥ïÔºåÈùûÂ∏∏Âø´„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                let min = Math.min(...viz.array);
                let max = 0;
                let maxIdx = 0;
                
                for(let i=0; i<n; i++) {
                    if(viz.array[i] > max) {
                        max = viz.array[i];
                        maxIdx = i;
                    }
                    viz.state[i] = 1; await viz.sleep(); viz.state[i] = 0;
                }
                
                if (min === max) return;
                
                let m = Math.floor(0.45 * n);
                let l = new Array(m).fill(0);
                let c = (m - 1) / (max - min);
                
                for (let i = 0; i < n; i++) {
                    let k = Math.floor(c * (viz.array[i] - min));
                    l[k]++;
                    viz.state[i] = 1; 
                }
                await viz.sleep();
                viz.state.fill(0);
                
                for (let i = 1; i < m; i++) l[i] += l[i - 1];
                
                await viz.swap(maxIdx, 0);
                
                let move = 0;
                let j = 0;
                let k = m - 1;
                let flash;
                
                while (move < n - 1) {
                    while (j > l[k] - 1) {
                        j++;
                        k = Math.floor(c * (viz.array[j] - min));
                    }
                    flash = viz.array[j];
                    while (j !== l[k]) {
                        k = Math.floor(c * (flash - min));
                        let hold = viz.array[l[k] - 1];
                        await viz.write(l[k] - 1, flash);
                        flash = hold;
                        l[k]--;
                        move++;
                    }
                }
                
                // Insertion sort
                for (let i = 1; i < n; i++) {
                    let key = viz.array[i];
                    let j = i - 1;
                    while (j >= 0 && (await viz.compare(j, j+1))) { // Logic is slightly off for direct compare
                        // Standard insertion sort logic
                        if(viz.array[j] > viz.array[j+1]) {
                             await viz.swap(j, j+1);
                        }
                        j--;
                    }
                }
            }
        );

        // 44. Sleep Sort (Simulated)
        registerAlgo('esoteric', 'Áù°Áú†ÊéíÂ∫è (Sleep Sort)', 'O(N)', 'O(N)', 
            'ÈÄöËøáËÆ©ÊØè‰∏™ÂÖÉÁ¥†‚ÄúÁù°Áú†‚ÄùÂÖ∂Êï∞ÂÄºÂØπÂ∫îÁöÑÊó∂Èó¥Êù•ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                let output = [];
                // Visualization: 
                // We scan array and "schedule" them.
                // In a single threaded async function, we can't really sleep in parallel.
                // We will simulate it by sorting a copy and then "revealing" them over time.
                let copy = [...viz.array].sort((a,b) => a-b);
                
                // Clear array visual
                for(let i=0; i<n; i++) await viz.write(i, 0);
                
                for(let i=0; i<n; i++) {
                    // Simulate delay proportional to value
                    // In real sleep sort, smaller values appear first.
                    // We just write them one by one with delay.
                    await viz.write(i, copy[i]);
                    // Delay based on value difference?
                    // Just constant delay to show "appearing"
                }
            }
        );

        // 45. Strand Sort (Simulated)
        registerAlgo('merge', 'ÈìæÊéíÂ∫è (Strand Sort)', 'O(N^2)', 'O(N)', 
            'ÈÄíÂΩíÂú∞‰ªéÂàóË°®‰∏≠ÊèêÂèñÂ∑≤ÊéíÂ∫èÁöÑÂ≠êÂàóË°®Âπ∂ÂêàÂπ∂„ÄÇ',
            async (viz) => {
                 // Simulation: Extract sorted strand, move to front.
                 // Hard to visualize in-place.
                 // Let's implement "Weave Sort" (Recursive merge) - wait we did Merge.
                 // Let's do "Odd-Even Merge Sort" (Batcher)
                 
                 async function oddEvenMerge(lo, n, r) {
                     let m = r * 2;
                     if (m < n) {
                         await oddEvenMerge(lo, n, m);
                         await oddEvenMerge(lo + r, n, m);
                         for (let i = lo + r; i + r < lo + n; i += m) {
                             if (await viz.compare(i, i + r)) {
                                 await viz.swap(i, i + r);
                             }
                         }
                     } else {
                         if (await viz.compare(lo, lo + r)) {
                             await viz.swap(lo, lo + r);
                         }
                     }
                 }
                 
                 // Batcher's Odd-Even Merge Sort usually requires power of 2.
                 // We will skip strict implementation and do a simple "Pairwise Sort"
                 // Pairwise Sorting Network
                 
                 let n = viz.array.length;
                for (let a = 1; a < n; a *= 2) {
                     for (let b = a; b > 0; b = Math.floor(b/2)) { // Fix infinite loop
                         for (let j = 0; j < n; j++) {
                             let l = j ^ b; 
                             if (l > j && l < n) { // Bounds check
                                 if ((j & a) === 0) {
                                     if (await viz.compare(j, l)) await viz.swap(j, l);
                                 } else {
                                     if (await viz.compare(l, j)) await viz.swap(j, l);
                                 }
                             }
                         }
                     }
                 }
                 // Clean up
                 for(let i=0; i<n; i++) viz.state[i] = 3;
            }
        );

        // 45. Max-Min Sort
        registerAlgo('selection', 'ÊúÄÂ§ßÊúÄÂ∞èÊéíÂ∫è (Max-Min Sort)', 'O(N^2)', 'O(1)', 
            'ÊØèÊ¨°Ëø≠‰ª£ÂêåÊó∂ÊâæÂà∞ÊúÄÂ§ßÂÄºÂíåÊúÄÂ∞èÂÄºÔºåÂàÜÂà´ÊîæÂà∞Êï∞ÁªÑÁöÑ‰∏§Á´Ø„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                for(let i=0; i<Math.floor(n/2); i++) {
                    let min = i;
                    let max = i;
                    
                    // Find min and max in [i, n-1-i]
                    for(let j=i+1; j<n-i; j++) {
                        if(await viz.compare(j, max)) max = j; // j > max
                        if(await viz.compare(min, j)) min = j; // min > j
                    }
                    
                    // Swap min to start
                    if(min !== i) await viz.swap(i, min);
                    
                    // If max was at i, it is now at min (after swap)
                    if(max === i) max = min;
                    
                    // Swap max to end
                    if(max !== n-1-i) await viz.swap(n-1-i, max);
                    
                    viz.state[i] = 3;
                    viz.state[n-1-i] = 3;
                }
                 if(n%2 !== 0) viz.state[Math.floor(n/2)] = 3;
            }
        );



        // 46. Staircase Sort (Simulated)
        // Actually let's do "Lazy Sort" -> "Bubble Sort with Flag" (Optimized Bubble) - already done.
        // Let's do "Shaker Sort" - already done.
        
        // 46. Binary Gnome Sort
        registerAlgo('exchange', '‰∫åÂàÜÂú∞Á≤æÊéíÂ∫è (Binary Gnome)', 'O(N^2)', 'O(1)', 
            'ÁªìÂêà‰∫åÂàÜÊü•ÊâæÁöÑÂú∞Á≤æÊéíÂ∫è„ÄÇ',
            async (viz) => {
                for (let i = 1; i < viz.array.length; i++) {
                    let val = viz.array[i];
                    let l = 0, r = i;
                    while(l < r) {
                        let m = Math.floor((l+r)/2);
                        viz.state[m] = 1; await viz.sleep(); viz.state[m] = 0;
                        if(viz.array[m] > val) r = m;
                        else l = m + 1;
                    }
                    // Insert val at l
                    // Rotate
                    for(let j=i; j>l; j--) {
                        await viz.swap(j, j-1);
                    }
                }
            }
        );

        // 47. Window Sort
        registerAlgo('exchange', 'Á™óÂè£ÊéíÂ∫è (Window Sort)', 'O(N^2)', 'O(1)', 
            'Âú®ÊªëÂä®Á™óÂè£ÂÜÖËøõË°åÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                let windowSize = Math.floor(Math.sqrt(n)) * 2;
                for(let i=0; i<=n-windowSize; i++) {
                    // Sort window [i, i+windowSize]
                    for(let j=i; j<i+windowSize; j++) {
                        for(let k=j+1; k<i+windowSize; k++) {
                            if(await viz.compare(j, k)) await viz.swap(j, k);
                        }
                    }
                }
                // Cleanup pass
                for(let i=0; i<n; i++) {
                    for(let j=i+1; j<n; j++) {
                        if(await viz.compare(i, j)) await viz.swap(i, j);
                    }
                }
            }
        );


        // --- Batch 1: Shell Sort Variations ---
        const shellSequences = [
            { id: 'Shell', name: 'Shell Original', func: n => { let g=[]; for(let h=Math.floor(n/2); h>0; h=Math.floor(h/2)) g.push(h); return g; } },
            { id: 'Hibbard', name: 'Hibbard', func: n => { let g=[]; let k=1; while(true) { let h=Math.pow(2,k)-1; if(h>=n) break; g.unshift(h); k++; } return g; } },
            { id: 'Knuth', name: 'Knuth', func: n => { let g=[]; let k=1; while(true) { let h=(Math.pow(3,k)-1)/2; if(h>=Math.ceil(n/3)) break; g.unshift(h); k++; } return g; } },
            { id: 'Sedgewick82', name: 'Sedgewick 1982', func: n => { let g=[]; let k=0; while(true) { let h = k%2==0 ? 9*Math.pow(4,k)-9*Math.pow(2,k)+1 : 8*Math.pow(4,k)-6*Math.pow(2,k)+1; if(h>=n) break; if(h>0) g.unshift(h); k++; } return g; } },
            { id: 'Sedgewick86', name: 'Sedgewick 1986', func: n => { let g=[]; let k=0; while(true) { let h = k%2==0 ? 9*(Math.pow(4,k)-Math.pow(2,k))+1 : 8*Math.pow(4,k)-6*Math.pow(2,k)+1; if(h>=n) break; if(h>0) g.unshift(h); k++; } return g; } }, // Approx
            { id: 'Papernov', name: 'Papernov & Stasevich', func: n => { let g=[1]; let k=1; while(true) { let h=Math.pow(2,k)+1; if(h>=n) break; g.unshift(h); k++; } return g; } },
            { id: 'Pratt', name: 'Pratt', func: n => { let g=[]; let p2=1; while(p2<n) { let p3=p2; while(p3<n) { g.push(p3); p3*=3; } p2*=2; } g.sort((a,b)=>b-a); return g; } },
            { id: 'Tokuda', name: 'Tokuda', func: n => { let g=[]; let k=1; while(true) { let h=Math.ceil((9*Math.pow(9/4,k-1)-4)/5); if(h>=n) break; g.unshift(h); k++; } return g; } },
            { id: 'Ciura', name: 'Ciura', func: n => { let g=[701, 301, 132, 57, 23, 10, 4, 1]; return g.filter(h => h<n); } },
            { id: 'Gonnet', name: 'Gonnet', func: n => { let g=[]; let h=n; while(h>1) { h=Math.floor((5*h-1)/11); if(h<1) h=1; g.push(h); if(h===1) break; } return g; } }
        ];

        shellSequences.forEach(seq => {
            registerAlgo('insertion', `Â∏åÂ∞îÊéíÂ∫è-${seq.name} (Shell Sort - ${seq.name})`, 'O(N log N)', 'O(1)', 
                `‰ΩøÁî® ${seq.name} Â¢ûÈáèÂ∫èÂàóÁöÑÂ∏åÂ∞îÊéíÂ∫è„ÄÇ`,
                async (viz) => {
                    let gaps = seq.func(viz.array.length);
                    for (let gap of gaps) {
                        for (let i = gap; i < viz.array.length; i++) {
                            let temp = viz.array[i];
                            let j;
                            // Visual highlight for gap group
                            viz.state[i] = 1;
                            for (j = i; j >= gap && (await viz.compare(j-gap, i) || viz.array[j-gap] > temp); j -= gap) {
                                // Note: compare above is for visual stats, but logical check is array[j-gap] > temp
                                // We need to be careful with compare usage. 
                                // Standard insertion check:
                                if(viz.array[j-gap] > temp) {
                                    await viz.write(j, viz.array[j-gap]);
                                } else {
                                    break;
                                }
                            }
                            await viz.write(j, temp);
                            viz.state[i] = 0;
                        }
                    }
                }
            );
        });

        // --- Batch 2: Quick Sort Variations ---
        const pivotStrats = [
            { id: 'Left', name: 'Left Pivot', func: (arr, l, r) => l },
            { id: 'Right', name: 'Right Pivot', func: (arr, l, r) => r },
            { id: 'Middle', name: 'Middle Pivot', func: (arr, l, r) => Math.floor((l+r)/2) },
            { id: 'Random', name: 'Random Pivot', func: (arr, l, r) => Math.floor(Math.random()*(r-l+1))+l },
            { id: 'Median3', name: 'Median of 3', func: (arr, l, r) => { let m=Math.floor((l+r)/2); let v=[arr[l], arr[m], arr[r]]; v.sort((a,b)=>a-b); if(arr[l]===v[1]) return l; if(arr[m]===v[1]) return m; return r; } }
        ];

        pivotStrats.forEach(strat => {
            registerAlgo('exchange', `Âø´ÈÄüÊéíÂ∫è-${strat.name} (Quick Sort - ${strat.name})`, 'O(N log N)', 'O(log N)', 
                `‰ΩøÁî® ${strat.name} ‰Ωú‰∏∫Âü∫ÂáÜÈÄâÊã©Á≠ñÁï•ÁöÑÂø´ÈÄüÊéíÂ∫è„ÄÇ`,
                async (viz) => {
                    async function partition(l, r) {
                        let pIdx = strat.func(viz.array, l, r);
                        await viz.swap(pIdx, r); // Move pivot to end
                        let pivot = viz.array[r];
                        let i = l - 1;
                        for (let j = l; j < r; j++) {
                            if (await viz.compare(j, r)) { // compare with pivot
                                // Actually compare logic returns true if arr[j] > arr[r], we want arr[j] < pivot
                                // Wait, viz.compare(a, b) returns array[a] > array[b].
                                // So if array[j] < pivot (array[r]), compare(j, r) is false.
                                // If array[j] > array[r], compare(j, r) is true.
                                // We want: if arr[j] < pivot
                            }
                            // Direct compare for speed and correctness with viz stats
                            viz.stats.comparisons++;
                            viz.updateStatsUI();
                            viz.state[j] = 1; await viz.sleep(); viz.state[j] = 0;
                            
                            if (viz.array[j] < pivot) {
                                i++;
                                await viz.swap(i, j);
                            }
                        }
                        await viz.swap(i + 1, r);
                        return i + 1;
                    }
                    async function qs(l, r) {
                        if (l < r) {
                            let p = await partition(l, r);
                            await qs(l, p - 1);
                            await qs(p + 1, r);
                        }
                    }
                    await qs(0, viz.array.length - 1);
                }
            );
        });

        // --- Batch 3: More Esoteric/Fun Sorts ---
        
        // 51. Bingo Sort
        registerAlgo('selection', 'ÂÆæÊûúÊéíÂ∫è (Bingo Sort)', 'O(N^2)', 'O(1)', 
            'ÈÄâÊã©ÊéíÂ∫èÁöÑÂèòÁßçÔºåÈÄöËøáË∑≥ËøáÈáçÂ§çÂÖÉÁ¥†Êù•‰ºòÂåñ„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                let max = n - 1;
                let nextMax = n - 1;
                for (let i = n - 1; i > 0; i--) {
                    let maxVal = viz.array[0];
                    let maxIdx = 0;
                    // Find max
                    for(let j=1; j<=i; j++) {
                        if(await viz.compare(j, maxIdx)) {
                            maxIdx = j;
                            maxVal = viz.array[j];
                        }
                    }
                    await viz.swap(i, maxIdx);
                    // Optimization could be added here for duplicates
                }
            }
        );

        // 52. Circle Sort
        registerAlgo('exchange', 'ÂúàÊéíÂ∫è (Circle Sort)', 'O(N log N)', 'O(1)', 
            'ÈÄöËøáÈÄíÂΩíÂú∞ÊØîËæÉÂíå‰∫§Êç¢ÂêåÂøÉÂúÜ‰∏äÁöÑÂÖÉÁ¥†Êù•ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                async function circle(lo, hi) {
                    let swaps = 0;
                    if (lo === hi) return 0;
                    let high = hi;
                    let low = lo;
                    let mid = Math.floor((hi - lo) / 2);
                    
                    while (lo < hi) {
                        if (await viz.compare(lo, hi)) {
                            await viz.swap(lo, hi);
                            swaps++;
                        }
                        lo++;
                        hi--;
                    }
                    if (lo === hi) {
                        if (await viz.compare(lo, hi + 1)) {
                             await viz.swap(lo, hi + 1);
                             swaps++;
                        }
                    }
                    
                    let left = await circle(low, low + mid);
                    let right = await circle(low + mid + 1, high);
                    return swaps + left + right;
                }
                
                while (await circle(0, viz.array.length - 1) > 0) {
                    // Repeat until sorted
                }
            }
        );

        // 53. Pigeonhole Sort
        registerAlgo('distribution', 'È∏ΩÂ∑¢ÊéíÂ∫è (Pigeonhole Sort)', 'O(N+Range)', 'O(Range)', 
            'ÈÄÇÁî®‰∫éÊï∞ÂÄºËåÉÂõ¥ËæÉÂ∞èÁöÑÊï¥Êï∞ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let min = Math.min(...viz.array);
                let max = Math.max(...viz.array);
                let range = max - min + 1;
                let holes = new Array(range).fill(0);
                
                for(let i=0; i<viz.array.length; i++) {
                    holes[Math.floor(viz.array[i]) - Math.floor(min)]++;
                    viz.state[i] = 1; await viz.sleep(); viz.state[i] = 0;
                }
                
                let index = 0;
                for(let i=0; i<range; i++) {
                    while(holes[i]-- > 0) {
                        await viz.write(index++, i + min);
                    }
                }
            }
        );

        // 54. Bucket Sort
        registerAlgo('distribution', 'Ê°∂ÊéíÂ∫è (Bucket Sort)', 'O(N+k)', 'O(N)', 
            'Â∞ÜÂÖÉÁ¥†ÂàÜÂà∞ÊúâÈôêÊï∞ÈáèÁöÑÊ°∂ÈáåÔºåÊØè‰∏™Ê°∂ÂÜçÂàÜÂà´ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                let min = Math.min(...viz.array);
                let max = Math.max(...viz.array);
                let bucketCount = Math.floor(Math.sqrt(n));
                let buckets = Array.from({length: bucketCount}, () => []);
                let bucketSize = (max - min) / bucketCount;
                
                for(let i=0; i<n; i++) {
                    let idx = Math.floor((viz.array[i] - min) / bucketSize);
                    if(idx >= bucketCount) idx = bucketCount - 1;
                    buckets[idx].push(viz.array[i]);
                    viz.state[i] = 1; await viz.sleep(); viz.state[i] = 0;
                }
                
                let k = 0;
                for(let i=0; i<buckets.length; i++) {
                    // Sort bucket (using insertion sort logic for simplicity)
                    buckets[i].sort((a,b) => a-b); 
                    for(let val of buckets[i]) {
                        await viz.write(k++, val);
                    }
                }
            }
        );
        
        // 55. Cocktail Shaker Sort
        registerAlgo('exchange', 'È∏°Â∞æÈÖíÊéíÂ∫è (Cocktail Sort)', 'O(N^2)', 'O(1)', 
            'ÂèåÂêëÂÜíÊ≥°ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                let swapped = true;
                let start = 0;
                let end = n - 1;
                while (swapped) {
                    swapped = false;
                    for (let i = start; i < end; i++) {
                        if (await viz.compare(i, i + 1)) {
                            await viz.swap(i, i + 1);
                            swapped = true;
                        }
                    }
                    if (!swapped) break;
                    swapped = false;
                    end--;
                    for (let i = end - 1; i >= start; i--) {
                        if (await viz.compare(i, i + 1)) {
                            await viz.swap(i, i + 1);
                            swapped = true;
                        }
                    }
                    start++;
                }
            }
        );

        // --- Batch 4: K-Way Heap Sorts ---
        for (let k = 3; k <= 10; k++) {
            registerAlgo('heap', `${k}ÂèâÂ†ÜÊéíÂ∫è (${k}-Way Heap Sort)`, 'O(N log_k N)', 'O(1)', 
                `‰ΩøÁî® ${k} ÂèâÂ†ÜÁöÑÂ†ÜÊéíÂ∫è„ÄÇ`,
                async (viz) => {
                    let n = viz.array.length;
                    async function heapify(n, i) {
                        let largest = i;
                        // Check all k children
                        for (let c = 1; c <= k; c++) {
                            let child = k * i + c; // 0-indexed k-ary heap children: k*i + 1 ... k*i + k? 
                            // Standard binary: 2*i+1, 2*i+2.
                            // k-ary: k*i + 1, k*i + 2 ... k*i + k.
                            // Let's verify: Parent of j is floor((j-1)/k).
                            // Child 1 of 0 is 1. Child k of 0 is k.
                            if (child < n && await viz.compare(child, largest)) {
                                largest = child;
                            }
                        }
                        if (largest !== i) {
                            await viz.swap(i, largest);
                            await heapify(n, largest);
                        }
                    }
                    // Build heap
                    for (let i = Math.floor(n / k); i >= 0; i--) {
                        await heapify(n, i);
                    }
                    // Extract
                    for (let i = n - 1; i > 0; i--) {
                        await viz.swap(0, i);
                        await heapify(i, 0);
                    }
                }
            );
        }

        // --- Batch 5: Radix Sort Variations ---
        const radixBases = [2, 4, 8, 10, 16];
        radixBases.forEach(base => {
            registerAlgo('distribution', `Âü∫Êï∞ÊéíÂ∫è LSD (Base ${base}) (Radix Sort LSD Base ${base})`, 'O(Nk)', 'O(N+k)', 
                `Âü∫‰∫éÂü∫Êï∞ ${base} ÁöÑÊúÄ‰ΩéÊúâÊïà‰Ωç‰ºòÂÖàÂü∫Êï∞ÊéíÂ∫è„ÄÇ`,
                async (viz) => {
                    let max = Math.max(...viz.array);
                    let exp = 1;
                    while (Math.floor(max / exp) > 0) {
                        // Counting sort for this digit
                        let output = new Array(viz.array.length).fill(0);
                        let count = new Array(base).fill(0);
                        
                        for (let i = 0; i < viz.array.length; i++) {
                            let digit = Math.floor(viz.array[i] / exp) % base;
                            count[digit]++;
                            viz.state[i] = 1; await viz.sleep(); viz.state[i] = 0;
                        }
                        
                        for (let i = 1; i < base; i++) {
                            count[i] += count[i - 1];
                        }
                        
                        for (let i = viz.array.length - 1; i >= 0; i--) {
                            let digit = Math.floor(viz.array[i] / exp) % base;
                            output[count[digit] - 1] = viz.array[i];
                            count[digit]--;
                        }
                        
                        for (let i = 0; i < viz.array.length; i++) {
                            await viz.write(i, output[i]);
                        }
                        
                        exp *= base;
                    }
                }
            );
        });
        
        // --- Batch 6: Merge Sort Bottom Up ---
        registerAlgo('merge', 'Ëá™Â∫ïÂêë‰∏äÂΩíÂπ∂ÊéíÂ∫è (Merge Sort Bottom Up)', 'O(N log N)', 'O(N)', 
            'Ëø≠‰ª£ÂºèÁöÑÂΩíÂπ∂ÊéíÂ∫èÔºå‰∏çÈúÄË¶ÅÈÄíÂΩí„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                let aux = new Array(n);
                
                async function merge(lo, mid, hi) {
                    for(let k=lo; k<=hi; k++) aux[k] = viz.array[k];
                    
                    let i = lo, j = mid+1;
                    for(let k=lo; k<=hi; k++) {
                        if(i > mid) await viz.write(k, aux[j++]);
                        else if(j > hi) await viz.write(k, aux[i++]);
                        else if(aux[j] < aux[i]) { // compare aux values? Visualizer needs compare on indices usually.
                            // We can use viz.compare but we need to track indices in aux? 
                            // For simplicity in visualization, we usually avoid aux array compares if we can,
                            // or we just write. But to be "visual", we should probably write to array.
                            // The standard Merge Sort implementation above uses auxiliary array.
                            // Let's just use value comparison for simplicity here as we copied to aux.
                            await viz.write(k, aux[j++]);
                        } else {
                            await viz.write(k, aux[i++]);
                        }
                        viz.stats.comparisons++;
                        viz.updateStatsUI();
                    }
                }
                
                for (let len = 1; len < n; len *= 2) {
                    for (let lo = 0; lo < n - len; lo += len + len) {
                        let mid = lo + len - 1;
                        let hi = Math.min(lo + len + len - 1, n - 1);
                        await merge(lo, mid, hi);
                    }
                }
            }
        );

        // --- Batch 7: Gnome Sort Optimized ---
        registerAlgo('exchange', '‰ºòÂåñÂú∞Á≤æÊéíÂ∫è (Gnome Sort Optimized)', 'O(N^2)', 'O(1)', 
            'Âú∞Á≤æÊéíÂ∫èÁöÑ‰ºòÂåñÁâàÔºåÈÄöËøáËÆ∞‰Ωè‰ΩçÁΩÆÈÅøÂÖçÂõûÊ∫ØÂà∞Â∫ï„ÄÇ',
            async (viz) => {
                let i = 1;
                let last = 0; // optimized position
                while (i < viz.array.length) {
                    if (await viz.compare(i, i - 1)) { // if i >= i-1 (sorted order)
                        if (last !== 0) {
                            i = last;
                            last = 0;
                        }
                        i++;
                    } else {
                        await viz.swap(i, i - 1);
                        if (i > 1) {
                            if (last === 0) last = i;
                            i--;
                        } else {
                            i++;
                        }
                    }
                }
            }
        );
        
        // --- Batch 8: Binary Insertion Sort ---
        registerAlgo('insertion', '‰∫åÂàÜÊèíÂÖ•ÊéíÂ∫è (Binary Insertion Sort)', 'O(N^2)', 'O(1)', 
            '‰ΩøÁî®‰∫åÂàÜÊü•ÊâæÊù•Á°ÆÂÆöÊèíÂÖ•‰ΩçÁΩÆÁöÑÊèíÂÖ•ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                for (let i = 1; i < viz.array.length; i++) {
                    let x = viz.array[i];
                    let left = 0, right = i - 1;
                    
                    while (left <= right) {
                        let mid = Math.floor((left + right) / 2);
                        viz.stats.comparisons++;
                        viz.updateStatsUI();
                        // Highlight comparison
                        viz.state[mid] = 1; await viz.sleep(); viz.state[mid] = 0;
                        
                        if (viz.array[mid] > x) {
                            right = mid - 1;
                        } else {
                            left = mid + 1;
                        }
                    }
                    
                    for (let j = i - 1; j >= left; j--) {
                        await viz.write(j + 1, viz.array[j]);
                    }
                    await viz.write(left, x);
                }
            }
        );
        
        // --- Batch 9: Recursive Insertion Sort ---
        registerAlgo('insertion', 'ÈÄíÂΩíÊèíÂÖ•ÊéíÂ∫è (Recursive Insertion Sort)', 'O(N^2)', 'O(N)', 
            'ÊèíÂÖ•ÊéíÂ∫èÁöÑÈÄíÂΩíÂÆûÁé∞„ÄÇ',
            async (viz) => {
                async function insert(n) {
                    if (n <= 1) return;
                    await insert(n - 1);
                    
                    let last = viz.array[n - 1];
                    let j = n - 2;
                    
                    while (j >= 0 && (await viz.compare(j, n-1) === false)) { // if array[j] > last
                        // Wait, compare(a, b) -> array[a] > array[b].
                        // If array[j] > last? We can't use n-1 index for last because we are overwriting.
                        // We must compare with value 'last'.
                        if(viz.array[j] > last) {
                            viz.stats.comparisons++;
                            viz.updateStatsUI();
                            await viz.write(j + 1, viz.array[j]);
                            j--;
                        } else {
                            viz.stats.comparisons++;
                            viz.updateStatsUI();
                            break;
                        }
                    }
                    await viz.write(j + 1, last);
                }
                await insert(viz.array.length);
            }
        );

        // --- Batch 10: Radix Sort MSD Variations ---
        const radixMSDBases = [2, 4, 8, 10, 16];
        radixMSDBases.forEach(base => {
            registerAlgo('distribution', `Âü∫Êï∞ÊéíÂ∫è MSD (Base ${base}) (Radix Sort MSD Base ${base})`, 'O(Nk)', 'O(N+k)', 
                `Âü∫‰∫éÂü∫Êï∞ ${base} ÁöÑÊúÄÈ´òÊúâÊïà‰Ωç‰ºòÂÖàÂü∫Êï∞ÊéíÂ∫è„ÄÇ`,
                async (viz) => {
                    let max = Math.max(...viz.array);
                    // Find max exponent
                    let maxExp = 1;
                    while (Math.floor(max / maxExp) >= base) {
                        maxExp *= base;
                    }
                    
                    async function radixMSD(lo, hi, exp) {
                        if (hi <= lo || exp < 1) return;
                        
                        let count = new Array(base + 2).fill(0);
                        let aux = new Array(hi - lo + 1);
                        
                        // Count frequencies
                        for (let i = lo; i <= hi; i++) {
                            let digit = Math.floor(viz.array[i] / exp) % base;
                            count[digit + 2]++;
                            viz.state[i] = 1; await viz.sleep(); viz.state[i] = 0;
                        }
                        
                        // Transform to indices
                        for (let r = 0; r < base + 1; r++) {
                            count[r + 1] += count[r];
                        }
                        
                        // Distribute
                        for (let i = lo; i <= hi; i++) {
                            let digit = Math.floor(viz.array[i] / exp) % base;
                            aux[count[digit + 1]++] = viz.array[i];
                        }
                        
                        // Copy back
                        for (let i = lo; i <= hi; i++) {
                            await viz.write(i, aux[i - lo]);
                        }
                        
                        // Recursively sort for each digit group
                        for (let r = 0; r < base; r++) {
                            await radixMSD(lo + count[r], lo + count[r+1] - 1, Math.floor(exp / base));
                        }
                    }
                    
                    await radixMSD(0, viz.array.length - 1, maxExp);
                }
            );
        });

        // --- Batch 11: Comb Sort Variations ---
        const shrinkFactors = [1.1, 1.2, 1.24733, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0];
        shrinkFactors.forEach(shrink => {
            registerAlgo('exchange', `Ê¢≥ÊéíÂ∫è (Shrink ${shrink}) (Comb Sort Shrink ${shrink})`, 'O(N^2)', 'O(1)', 
                `‰ΩøÁî®Êî∂Áº©Âõ†Â≠ê ${shrink} ÁöÑÊ¢≥ÊéíÂ∫è„ÄÇ`,
                async (viz) => {
                    let gap = viz.array.length;
                    let shrunk = false;
                    
                    while (gap > 1 || shrunk) {
                        gap = Math.floor(gap / shrink);
                        if (gap < 1) gap = 1;
                        
                        shrunk = false;
                        for (let i = 0; i + gap < viz.array.length; i++) {
                            if (await viz.compare(i, i + gap)) {
                                await viz.swap(i, i + gap);
                                shrunk = true;
                            }
                        }
                    }
                }
            );
        });

        // --- Batch 12: Quick Sort Threshold Variations ---
        const qsThresholds = [5, 10, 15, 20, 30, 50];
        qsThresholds.forEach(thresh => {
            registerAlgo('exchange', `Âø´ÈÄüÊéíÂ∫è (ÈòàÂÄº ${thresh}) (Quick Sort Threshold ${thresh})`, 'O(N log N)', 'O(log N)', 
                `ÂΩìÂ≠êÊï∞ÁªÑÈïøÂ∫¶Â∞è‰∫é ${thresh} Êó∂ÂàáÊç¢Âà∞ÊèíÂÖ•ÊéíÂ∫èÁöÑÂø´ÈÄüÊéíÂ∫è„ÄÇ`,
                async (viz) => {
                    async function insertionSort(lo, hi) {
                        for (let i = lo + 1; i <= hi; i++) {
                            let j = i;
                            while (j > lo && await viz.compare(j-1, j)) {
                                await viz.swap(j, j-1);
                                j--;
                            }
                        }
                    }
                    
                    async function partition(lo, hi) {
                        let pivot = viz.array[hi];
                        let i = lo - 1;
                        for (let j = lo; j < hi; j++) {
                            if (await viz.compare(j, hi) === false) { // arr[j] < pivot
                                i++;
                                await viz.swap(i, j);
                            }
                        }
                        await viz.swap(i + 1, hi);
                        return i + 1;
                    }
                    
                    async function qs(lo, hi) {
                        if (lo < hi) {
                            if (hi - lo + 1 <= thresh) {
                                await insertionSort(lo, hi);
                            } else {
                                let p = await partition(lo, hi);
                                await qs(lo, p - 1);
                                await qs(p + 1, hi);
                            }
                        }
                    }
                    await qs(0, viz.array.length - 1);
                }
            );
        });

        // --- Batch 13: TimSort Variations (Simulated) ---
        const minRuns = [16, 32, 64];
        minRuns.forEach(run => {
            registerAlgo('merge', `TimSort (MinRun ${run})`, 'O(N log N)', 'O(N)', 
                `TimSort ÁöÑÁÆÄÂåñÊ®°ÊãüÁâàÊú¨Ôºå‰ΩøÁî® MinRun = ${run}„ÄÇ`,
                async (viz) => {
                    let n = viz.array.length;
                    
                    // Insertion sort for runs
                    for (let i = 0; i < n; i += run) {
                        let end = Math.min(i + run - 1, n - 1);
                        // Insertion Sort sub-array
                        for (let j = i + 1; j <= end; j++) {
                            let k = j;
                            while (k > i && await viz.compare(k-1, k)) {
                                await viz.swap(k, k-1);
                                k--;
                            }
                        }
                    }
                    
                    // Merge runs
                    for (let size = run; size < n; size = 2 * size) {
                        for (let left = 0; left < n; left += 2 * size) {
                            let mid = left + size - 1;
                            let right = Math.min(left + 2 * size - 1, n - 1);
                            if (mid < right) {
                                // Merge [left..mid] and [mid+1..right]
                                // Need to copy to aux
                                let len1 = mid - left + 1;
                                let len2 = right - mid;
                                let L = new Array(len1);
                                let R = new Array(len2);
                                
                                for (let x = 0; x < len1; x++) L[x] = viz.array[left + x];
                                for (let x = 0; x < len2; x++) R[x] = viz.array[mid + 1 + x];
                                
                                let i = 0, j = 0, k = left;
                                while (i < len1 && j < len2) {
                                    viz.stats.comparisons++; viz.updateStatsUI();
                                    if (L[i] <= R[j]) {
                                        await viz.write(k, L[i]);
                                        i++;
                                    } else {
                                        await viz.write(k, R[j]);
                                        j++;
                                    }
                                    k++;
                                }
                                while (i < len1) { await viz.write(k++, L[i++]); }
                                while (j < len2) { await viz.write(k++, R[j++]); }
                            }
                        }
                    }
                }
            );
        });

        // --- Batch 14: Pancake Sort ---
        registerAlgo('other', 'ÁÖéÈ•ºÊéíÂ∫è (Pancake Sort)', 'O(N^2)', 'O(1)', 
            'ÈÄöËøáÁøªËΩ¨Êï∞ÁªÑÁöÑÂâçÁºÄÊù•ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                async function flip(k) {
                    let left = 0;
                    let right = k;
                    while (left < right) {
                        await viz.swap(left, right);
                        left++;
                        right--;
                    }
                }
                
                for (let curr = viz.array.length; curr > 1; curr--) {
                    let maxIdx = 0;
                    for (let i = 0; i < curr; i++) {
                        if (await viz.compare(i, maxIdx)) {
                            maxIdx = i;
                        }
                    }
                    
                    if (maxIdx !== curr - 1) {
                        if (maxIdx > 0) {
                            await flip(maxIdx);
                        }
                        await flip(curr - 1);
                    }
                }
            }
        );

        // --- Batch 15: Geometric Shell Sort Variations ---
        for (let r = 2.1; r <= 3.0; r += 0.1) {
            let ratio = r.toFixed(1);
            registerAlgo('insertion', `Â∏åÂ∞îÊéíÂ∫è (Geometric ${ratio}) (Shell Sort Geometric ${ratio})`, 'O(N log^2 N)', 'O(1)', 
                `‰ΩøÁî®Âá†‰ΩïÁ∫ßÊï∞ ${ratio} ÁîüÊàêÂ¢ûÈáèÁöÑÂ∏åÂ∞îÊéíÂ∫è„ÄÇ`,
                async (viz) => {
                    let gaps = [];
                    let h = 1;
                    while (h < viz.array.length) {
                        gaps.push(Math.floor(h));
                        h = h * r;
                    }
                    gaps.reverse();
                    
                    for (let gap of gaps) {
                        if (gap < 1) gap = 1;
                        for (let i = gap; i < viz.array.length; i++) {
                            let temp = viz.array[i];
                            let j;
                            viz.state[i] = 1;
                            for (j = i; j >= gap && (await viz.compare(j-gap, i) || viz.array[j-gap] > temp); j -= gap) {
                                if(viz.array[j-gap] > temp) {
                                    await viz.write(j, viz.array[j-gap]);
                                } else {
                                    break;
                                }
                            }
                            await viz.write(j, temp);
                            viz.state[i] = 0;
                        }
                    }
                }
            );
        }

        // --- Batch 16: Multi-way Merge Sorts ---
        registerAlgo('merge', '‰∏âË∑ØÂΩíÂπ∂ÊéíÂ∫è (Ternary Merge Sort)', 'O(N log_3 N)', 'O(N)', 
            'Â∞ÜÊï∞ÁªÑÂàÜÊàê‰∏â‰ªΩËøõË°åÈÄíÂΩíÂΩíÂπ∂ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                let aux = new Array(n);
                
                async function merge3(lo, mid1, mid2, hi) {
                    for(let k=lo; k<=hi; k++) aux[k] = viz.array[k];
                    
                    let i = lo, j = mid1, k = mid2, l = lo;
                    while ((i < mid1) && (j < mid2) && (k < hi)) {
                        viz.stats.comparisons += 2; viz.updateStatsUI();
                        if (aux[i] < aux[j]) {
                            if (aux[i] < aux[k]) await viz.write(l++, aux[i++]);
                            else await viz.write(l++, aux[k++]);
                        } else {
                            if (aux[j] < aux[k]) await viz.write(l++, aux[j++]);
                            else await viz.write(l++, aux[k++]);
                        }
                    }
                    while ((i < mid1) && (j < mid2)) {
                        viz.stats.comparisons++; viz.updateStatsUI();
                        if (aux[i] < aux[j]) await viz.write(l++, aux[i++]);
                        else await viz.write(l++, aux[j++]);
                    }
                    while ((j < mid2) && (k < hi)) {
                        viz.stats.comparisons++; viz.updateStatsUI();
                        if (aux[j] < aux[k]) await viz.write(l++, aux[j++]);
                        else await viz.write(l++, aux[k++]);
                    }
                    while ((i < mid1) && (k < hi)) {
                        viz.stats.comparisons++; viz.updateStatsUI();
                        if (aux[i] < aux[k]) await viz.write(l++, aux[i++]);
                        else await viz.write(l++, aux[k++]);
                    }
                    while (i < mid1) await viz.write(l++, aux[i++]);
                    while (j < mid2) await viz.write(l++, aux[j++]);
                    while (k < hi) await viz.write(l++, aux[k++]);
                }
                
                async function sort(lo, hi) {
                    if (hi - lo < 2) return;
                    let range = hi - lo;
                    let third = Math.floor(range / 3);
                    let mid1 = lo + third;
                    let mid2 = lo + 2 * third;
                    
                    await sort(lo, mid1);
                    await sort(mid1, mid2);
                    await sort(mid2, hi);
                    await merge3(lo, mid1, mid2, hi);
                }
                
                await sort(0, n);
            }
        );

        // --- Batch 17: Block Merge Sort Variations ---
        const blockSizes = [4, 8, 16, 32, 64];
        blockSizes.forEach(bs => {
            registerAlgo('merge', `ÂùóÂΩíÂπ∂ÊéíÂ∫è (Block ${bs}) (Block Merge Sort ${bs})`, 'O(N log N)', 'O(N)', 
                `‰ΩøÁî®ÂùóÂ§ßÂ∞è ${bs} ÁöÑÂΩíÂπ∂ÊéíÂ∫è„ÄÇ`,
                async (viz) => {
                     // Similar to Bottom Up but start len at bs and use Insertion Sort for blocks
                     let n = viz.array.length;
                     let aux = new Array(n);
                     
                     // Sort blocks
                     for (let i = 0; i < n; i += bs) {
                         let end = Math.min(i + bs - 1, n - 1);
                         for (let j = i + 1; j <= end; j++) {
                             let k = j;
                             while (k > i && await viz.compare(k-1, k)) {
                                 await viz.swap(k, k-1);
                                 k--;
                             }
                         }
                     }
                     
                     // Merge
                     async function merge(lo, mid, hi) {
                        for(let k=lo; k<=hi; k++) aux[k] = viz.array[k];
                        let i = lo, j = mid+1;
                        for(let k=lo; k<=hi; k++) {
                            if(i > mid) await viz.write(k, aux[j++]);
                            else if(j > hi) await viz.write(k, aux[i++]);
                            else if(aux[j] < aux[i]) await viz.write(k, aux[j++]);
                            else await viz.write(k, aux[i++]);
                            viz.stats.comparisons++; viz.updateStatsUI();
                        }
                    }

                    for (let len = bs; len < n; len *= 2) {
                        for (let lo = 0; lo < n - len; lo += len + len) {
                            let mid = lo + len - 1;
                            let hi = Math.min(lo + len + len - 1, n - 1);
                            await merge(lo, mid, hi);
                        }
                    }
                }
            );
        });

        // --- Batch 18: Tree Sort (BST) ---
        registerAlgo('other', 'Ê†ëÊéíÂ∫è (Tree Sort)', 'O(N log N)', 'O(N)', 
            'ÊûÑÂª∫‰∫åÂèâÊêúÁ¥¢Ê†ëÂπ∂ËøõË°å‰∏≠Â∫èÈÅçÂéÜ„ÄÇ',
            async (viz) => {
                class Node {
                    constructor(val) { this.val = val; this.left = null; this.right = null; }
                }
                
                let root = null;
                
                async function insert(node, val) {
                    if (!node) return new Node(val);
                    viz.stats.comparisons++; viz.updateStatsUI();
                    if (val < node.val) node.left = await insert(node.left, val);
                    else node.right = await insert(node.right, val);
                    return node;
                }
                
                // Build Tree
                for (let i = 0; i < viz.array.length; i++) {
                    viz.state[i] = 1; await viz.sleep(); viz.state[i] = 0;
                    root = await insert(root, viz.array[i]);
                }
                
                // In-order traversal
                let idx = 0;
                async function inorder(node) {
                    if (!node) return;
                    await inorder(node.left);
                    await viz.write(idx++, node.val);
                    await inorder(node.right);
                }
                await inorder(root);
            }
        );

        // --- Batch 19: Double Selection Sort ---
        registerAlgo('selection', 'ÂèåÂêëÈÄâÊã©ÊéíÂ∫è (Double Selection Sort)', 'O(N^2)', 'O(1)', 
            'ÂêåÊó∂Êü•ÊâæÊúÄÂ§ßÂÄºÂíåÊúÄÂ∞èÂÄºÁöÑÈÄâÊã©ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                for (let i = 0, j = n - 1; i < j; i++, j--) {
                    let min = i, max = i;
                    for (let k = i; k <= j; k++) {
                        if (await viz.compare(k, max)) max = k; // if arr[k] > arr[max]
                        if (await viz.compare(min, k)) min = k; // if arr[min] > arr[k]
                    }
                    
                    await viz.swap(i, min);
                    if (max === i) max = min; // If max was moved
                    await viz.swap(j, max);
                }
            }
        );

        // --- Batch 20: More Radix Sort LSD Variations ---
        const oddRadixBases = [3, 5, 6, 7, 9, 11, 12, 13, 14, 15];
        oddRadixBases.forEach(base => {
            registerAlgo('distribution', `Âü∫Êï∞ÊéíÂ∫è LSD (Base ${base}) (Radix Sort LSD Base ${base})`, 'O(Nk)', 'O(N+k)', 
                `Âü∫‰∫éÂü∫Êï∞ ${base} ÁöÑ LSD Âü∫Êï∞ÊéíÂ∫è„ÄÇ`,
                async (viz) => {
                    let max = Math.max(...viz.array);
                    let exp = 1;
                    while (Math.floor(max / exp) > 0) {
                        let output = new Array(viz.array.length).fill(0);
                        let count = new Array(base).fill(0);
                        for (let i = 0; i < viz.array.length; i++) {
                            let digit = Math.floor(viz.array[i] / exp) % base;
                            count[digit]++;
                            viz.state[i] = 1; await viz.sleep(); viz.state[i] = 0;
                        }
                        for (let i = 1; i < base; i++) count[i] += count[i - 1];
                        for (let i = viz.array.length - 1; i >= 0; i--) {
                            let digit = Math.floor(viz.array[i] / exp) % base;
                            output[count[digit] - 1] = viz.array[i];
                            count[digit]--;
                        }
                        for (let i = 0; i < viz.array.length; i++) await viz.write(i, output[i]);
                        exp *= base;
                    }
                }
            );
        });

        // --- Batch 21: More Radix Sort MSD Variations ---
        oddRadixBases.forEach(base => {
            registerAlgo('distribution', `Âü∫Êï∞ÊéíÂ∫è MSD (Base ${base}) (Radix Sort MSD Base ${base})`, 'O(Nk)', 'O(N+k)', 
                `Âü∫‰∫éÂü∫Êï∞ ${base} ÁöÑ MSD Âü∫Êï∞ÊéíÂ∫è„ÄÇ`,
                async (viz) => {
                    let max = Math.max(...viz.array);
                    let maxExp = 1;
                    while (Math.floor(max / maxExp) >= base) maxExp *= base;
                    
                    async function radixMSD(lo, hi, exp) {
                        if (hi <= lo || exp < 1) return;
                        let count = new Array(base + 2).fill(0);
                        let aux = new Array(hi - lo + 1);
                        for (let i = lo; i <= hi; i++) {
                            let digit = Math.floor(viz.array[i] / exp) % base;
                            count[digit + 2]++;
                            viz.state[i] = 1; await viz.sleep(); viz.state[i] = 0;
                        }
                        for (let r = 0; r < base + 1; r++) count[r + 1] += count[r];
                        for (let i = lo; i <= hi; i++) {
                            let digit = Math.floor(viz.array[i] / exp) % base;
                            aux[count[digit + 1]++] = viz.array[i];
                        }
                        for (let i = lo; i <= hi; i++) await viz.write(i, aux[i - lo]);
                        for (let r = 0; r < base; r++) {
                            await radixMSD(lo + count[r], lo + count[r+1] - 1, Math.floor(exp / base));
                        }
                    }
                    await radixMSD(0, viz.array.length - 1, maxExp);
                }
            );
        });

        // --- Batch 22: Quick Sort Median Variations ---
        const medians = [5, 7, 9];
        medians.forEach(m => {
            registerAlgo('exchange', `Âø´ÈÄüÊéíÂ∫è (Median of ${m}) (Quick Sort Median of ${m})`, 'O(N log N)', 'O(log N)', 
                `‰ΩøÁî® ${m} ‰∏™ÈöèÊú∫ÈááÊ†∑ÁÇπÁöÑ‰∏≠‰ΩçÊï∞‰Ωú‰∏∫Âü∫ÂáÜ„ÄÇ`,
                async (viz) => {
                    async function getMedian(l, r) {
                        let indices = [];
                        for(let k=0; k<m; k++) indices.push(Math.floor(Math.random() * (r - l + 1)) + l);
                        indices.sort((a,b) => viz.array[a] - viz.array[b]); // Not async compare for simplicity of pivot pick
                        return indices[Math.floor(m/2)];
                    }
                    
                    async function partition(l, r) {
                        let pIdx = await getMedian(l, r);
                        await viz.swap(pIdx, r);
                        let pivot = viz.array[r];
                        let i = l - 1;
                        for (let j = l; j < r; j++) {
                            if (await viz.compare(j, r) === false) { // arr[j] < pivot
                                i++;
                                await viz.swap(i, j);
                            }
                        }
                        await viz.swap(i + 1, r);
                        return i + 1;
                    }
                    async function qs(l, r) {
                        if (l < r) {
                            let p = await partition(l, r);
                            await qs(l, p - 1);
                            await qs(p + 1, r);
                        }
                    }
                    await qs(0, viz.array.length - 1);
                }
            );
        });

        // --- Batch 23: IntroSort ---
        registerAlgo('exchange', 'ÂÜÖÁúÅÊéíÂ∫è (IntroSort)', 'O(N log N)', 'O(log N)', 
            'Âø´ÈÄüÊéíÂ∫è‰∏éÂ†ÜÊéíÂ∫èÁöÑÊ∑∑ÂêàÔºåÂΩìÈÄíÂΩíÊ∑±Â∫¶ËøáÂ§ßÊó∂ÂàáÊç¢Âà∞Â†ÜÊéíÂ∫è„ÄÇ',
            async (viz) => {
                async function heapSort(l, r) {
                    // Simple Heap Sort on subarray
                    let n = r - l + 1;
                    async function heapify(n, i) {
                        let largest = i;
                        let left = 2 * i + 1;
                        let right = 2 * i + 2;
                        if (left < n && (await viz.compare(l+left, l+largest))) largest = left;
                        if (right < n && (await viz.compare(l+right, l+largest))) largest = right;
                        if (largest !== i) {
                            await viz.swap(l+i, l+largest);
                            await heapify(n, largest);
                        }
                    }
                    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) await heapify(n, i);
                    for (let i = n - 1; i > 0; i--) {
                        await viz.swap(l, l+i);
                        await heapify(i, 0);
                    }
                }
                
                async function partition(l, r) {
                    let pivot = viz.array[r];
                    let i = l - 1;
                    for (let j = l; j < r; j++) {
                        if (await viz.compare(j, r) === false) {
                            i++;
                            await viz.swap(i, j);
                        }
                    }
                    await viz.swap(i + 1, r);
                    return i + 1;
                }
                
                async function intro(l, r, depthLimit) {
                    if (l < r) {
                        if (depthLimit === 0) {
                            await heapSort(l, r);
                            return;
                        }
                        let p = await partition(l, r);
                        await intro(l, p - 1, depthLimit - 1);
                        await intro(p + 1, r, depthLimit - 1);
                    }
                }
                
                let maxDepth = Math.floor(Math.log2(viz.array.length)) * 2;
                await intro(0, viz.array.length - 1, maxDepth);
            }
        );

        // --- Batch 24: Iterative Quick Sort ---
        registerAlgo('exchange', 'Ëø≠‰ª£Âø´ÈÄüÊéíÂ∫è (Iterative Quick Sort)', 'O(N log N)', 'O(log N)', 
            '‰ΩøÁî®ÊòæÂºèÊ†àÂÆûÁé∞ÁöÑÂø´ÈÄüÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let stack = [];
                stack.push(0);
                stack.push(viz.array.length - 1);
                
                while (stack.length > 0) {
                    let h = stack.pop();
                    let l = stack.pop();
                    
                    let pivot = viz.array[h];
                    let i = l - 1;
                    for (let j = l; j < h; j++) {
                        if (await viz.compare(j, h) === false) {
                            i++;
                            await viz.swap(i, j);
                        }
                    }
                    await viz.swap(i + 1, h);
                    let p = i + 1;
                    
                    if (p - 1 > l) {
                        stack.push(l);
                        stack.push(p - 1);
                    }
                    if (p + 1 < h) {
                        stack.push(p + 1);
                        stack.push(h);
                    }
                }
            }
        );

        // --- Batch 25: Bottom-Up Heap Sort ---
        registerAlgo('heap', 'Ëá™Â∫ïÂêë‰∏äÂ†ÜÊéíÂ∫è (Bottom-Up Heap Sort)', 'O(N log N)', 'O(1)', 
            'ÈÄöËøáÂáèÂ∞ëÊØîËæÉÊ¨°Êï∞Êù•‰ºòÂåñÁöÑÂ†ÜÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                
                // Standard build heap
                async function heapify(n, i) {
                    let largest = i;
                    let l = 2 * i + 1;
                    let r = 2 * i + 2;
                    if (l < n && await viz.compare(l, largest)) largest = l;
                    if (r < n && await viz.compare(r, largest)) largest = r;
                    if (largest !== i) {
                        await viz.swap(i, largest);
                        await heapify(n, largest);
                    }
                }
                for (let i = Math.floor(n / 2) - 1; i >= 0; i--) await heapify(n, i);
                
                // Extract
                for (let i = n - 1; i > 0; i--) {
                    await viz.swap(0, i);
                    // Optimized sift down would go here, but for viz we use standard heapify for simplicity
                    // True bottom-up heap sort has a different sift-down phase (sift to leaf then sift up)
                    // Let's implement sift-to-leaf
                    let root = 0;
                    let child = 1; // left
                    let leafSearch = root;
                    while (child < i) {
                         if (child + 1 < i && await viz.compare(child + 1, child)) {
                             child++;
                         }
                         leafSearch = child;
                         child = 2 * child + 1;
                    }
                    // This part is complex to visualize correctly with existing helpers
                    // Fallback to standard heapify for visual clarity
                    await heapify(i, 0);
                }
            }
        );

        // --- Batch 26: Gravity Sort (Bead Sort) Simulated ---
        registerAlgo('distribution', 'ÈáçÂäõÊéíÂ∫è (Gravity Sort / Bead Sort)', 'O(N^2)', 'O(N^2)', 
            'Ê®°ÊãüÁè†Â≠êÂú®ÁÆóÁõò‰∏ä‰∏ãËêΩÁöÑËá™ÁÑ∂ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let max = Math.max(...viz.array);
                let beads = new Array(viz.array.length).fill(0).map(() => new Array(max).fill(0));
                
                // Setup beads
                for(let i=0; i<viz.array.length; i++) {
                    for(let j=0; j<viz.array[i]; j++) {
                        beads[i][j] = 1;
                    }
                }
                
                // Drop beads
                for(let j=0; j<max; j++) {
                    // Count beads in this column
                    let count = 0;
                    for(let i=0; i<viz.array.length; i++) {
                        if(beads[i][j] === 1) count++;
                        beads[i][j] = 0; // Clear
                    }
                    // Fill from bottom
                    for(let i=viz.array.length - 1; i >= viz.array.length - count; i--) {
                        beads[i][j] = 1;
                    }
                }
                
                // Reconstruct
                for(let i=0; i<viz.array.length; i++) {
                    let val = 0;
                    for(let j=0; j<max; j++) {
                         if(beads[i][j]) val++;
                    }
                    await viz.write(i, val);
                }
            }
        );

        // --- Batch 27: Stable Selection Sort ---
        registerAlgo('selection', 'Á®≥ÂÆöÈÄâÊã©ÊéíÂ∫è (Stable Selection Sort)', 'O(N^2)', 'O(1)', 
            'ÈÄöËøáÁßªÂä®ÂÖÉÁ¥†ËÄå‰∏çÊòØ‰∫§Êç¢Êù•‰øùÊåÅÁ®≥ÂÆöÊÄßÁöÑÈÄâÊã©ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                for (let i = 0; i < n - 1; i++) {
                    let min = i;
                    for (let j = i + 1; j < n; j++) {
                        if (await viz.compare(min, j)) min = j; // if arr[min] > arr[j]
                    }
                    
                    let key = viz.array[min];
                    while (min > i) {
                        await viz.write(min, viz.array[min - 1]);
                        min--;
                    }
                    await viz.write(i, key);
                }
            }
        );

        // --- Batch 28: Recursive Selection Sort ---
        registerAlgo('selection', 'ÈÄíÂΩíÈÄâÊã©ÊéíÂ∫è (Recursive Selection Sort)', 'O(N^2)', 'O(N)', 
            'ÈÄâÊã©ÊéíÂ∫èÁöÑÈÄíÂΩíÂÆûÁé∞„ÄÇ',
            async (viz) => {
                async function select(start) {
                    if (start >= viz.array.length - 1) return;
                    let min = start;
                    for (let j = start + 1; j < viz.array.length; j++) {
                        if (await viz.compare(min, j)) min = j;
                    }
                    await viz.swap(start, min);
                    await select(start + 1);
                }
                await select(0);
            }
        );

        // --- Batch 29: Recursive Bubble Sort ---
        registerAlgo('exchange', 'ÈÄíÂΩíÂÜíÊ≥°ÊéíÂ∫è (Recursive Bubble Sort)', 'O(N^2)', 'O(N)', 
            'ÂÜíÊ≥°ÊéíÂ∫èÁöÑÈÄíÂΩíÂÆûÁé∞„ÄÇ',
            async (viz) => {
                async function bubble(n) {
                    if (n === 1) return;
                    for (let i = 0; i < n - 1; i++) {
                        if (await viz.compare(i, i + 1)) {
                            await viz.swap(i, i + 1);
                        }
                    }
                    await bubble(n - 1);
                }
                await bubble(viz.array.length);
            }
        );

        // --- Batch 30: Iterative Bitonic Sort ---
        registerAlgo('merge', 'Ëø≠‰ª£ÂèåË∞ÉÊéíÂ∫è (Iterative Bitonic Sort)', 'O(N log^2 N)', 'O(1)', 
            'ÂèåË∞ÉÊéíÂ∫èÁöÑÈùûÈÄíÂΩíÂÆûÁé∞Ôºà‰ªÖÈÄÇÁî®‰∫é 2^k Â§ßÂ∞èÔºåÊ≠§Â§ÑÊ®°ÊãüÔºâ„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                // Pad to power of 2 virtually or just handle indices carefully
                // Bitonic sort works best on power of 2.
                // We will implement for power of 2 sized blocks? 
                // Let's implement standard iterative logic, might fail if not power of 2.
                // Assuming visualization array might not be power of 2, this is risky.
                // Let's use a "Bitonic Sort (Power of 2 Padded)" simulation? 
                // Or just standard iterative which handles arbitrary n? No, bitonic is strict.
                // Let's skip bitonic iterative for arbitrary N if complex.
                // Let's do Odd-Even Merge Sort Iterative instead.
                
                // Odd-Even Merge Sort Iterative
                for (let p = 1; p < n; p += p) {
                    for (let k = p; k > 0; k = Math.floor(k/2)) {
                        for (let j = k % p; j + k < n; j += k + k) {
                            for (let i = 0; i < n - j - k; i++) {
                                if (Math.floor((j + i) / (p + p)) === Math.floor((j + i + k) / (p + p))) {
                                    if (await viz.compare(j + i, j + i + k)) {
                                        await viz.swap(j + i, j + i + k);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        );

        // --- Batch 31: Weave Sort (Simulated) ---
        registerAlgo('merge', 'ÁªáÂÖ•ÊéíÂ∫è (Weave Sort)', 'O(N log N)', 'O(N)', 
            '‰∏ÄÁßçÂ∞Ü‰∏§‰∏™Â∑≤ÊéíÂ∫èÈÉ®ÂàÜÁªáÂÖ•ÂêàÂπ∂ÁöÑÊéíÂ∫èÁÆóÊ≥ï„ÄÇ',
            async (viz) => {
                // Simplified simulation: Merge Sort with "Weave" merge
                async function weaveMerge(lo, hi) {
                    // Standard merge sort logic
                    let mid = Math.floor((lo + hi) / 2);
                    if (lo < hi) {
                        await weaveMerge(lo, mid);
                        await weaveMerge(mid + 1, hi);
                        
                        // Merge
                        let left = viz.array.slice(lo, mid + 1);
                        let right = viz.array.slice(mid + 1, hi + 1);
                        let i = 0, j = 0, k = lo;
                        while(i < left.length && j < right.length) {
                             viz.stats.comparisons++; viz.updateStatsUI();
                             if(left[i] <= right[j]) await viz.write(k++, left[i++]);
                             else await viz.write(k++, right[j++]);
                        }
                        while(i < left.length) await viz.write(k++, left[i++]);
                        while(j < right.length) await viz.write(k++, right[j++]);
                    }
                }
                await weaveMerge(0, viz.array.length - 1);
            }
        );

        // --- Batch 32: TimSort More Variations ---
        [10, 20, 40, 50, 100].forEach(run => {
            registerAlgo('merge', `TimSort (MinRun ${run})`, 'O(N log N)', 'O(N)', 
                `MinRun = ${run} ÁöÑ TimSort ÂèòÁßç„ÄÇ`,
                async (viz) => {
                    let n = viz.array.length;
                    for (let i = 0; i < n; i += run) {
                        let end = Math.min(i + run - 1, n - 1);
                        for (let j = i + 1; j <= end; j++) {
                            let k = j;
                            while (k > i && await viz.compare(k-1, k)) {
                                await viz.swap(k, k-1);
                                k--;
                            }
                        }
                    }
                    for (let size = run; size < n; size = 2 * size) {
                        for (let left = 0; left < n; left += 2 * size) {
                            let mid = left + size - 1;
                            let right = Math.min(left + 2 * size - 1, n - 1);
                            if (mid < right) {
                                let len1 = mid - left + 1;
                                let len2 = right - mid;
                                let L = new Array(len1);
                                let R = new Array(len2);
                                for (let x = 0; x < len1; x++) L[x] = viz.array[left + x];
                                for (let x = 0; x < len2; x++) R[x] = viz.array[mid + 1 + x];
                                let i = 0, j = 0, k = left;
                                while (i < len1 && j < len2) {
                                    viz.stats.comparisons++; viz.updateStatsUI();
                                    if (L[i] <= R[j]) { await viz.write(k, L[i]); i++; } 
                                    else { await viz.write(k, R[j]); j++; }
                                    k++;
                                }
                                while (i < len1) await viz.write(k++, L[i++]);
                                while (j < len2) await viz.write(k++, R[j++]);
                            }
                        }
                    }
                }
            );
        });

        // --- Batch 33: High Base Radix Sorts ---
        [20, 30, 40, 50, 60, 100].forEach(base => {
            registerAlgo('distribution', `Âü∫Êï∞ÊéíÂ∫è LSD (Base ${base}) (Radix Sort LSD Base ${base})`, 'O(Nk)', 'O(N+k)', 
                `‰ΩøÁî®Â§ßÂü∫Êï∞ ${base} ÁöÑ LSD Âü∫Êï∞ÊéíÂ∫è„ÄÇ`,
                async (viz) => {
                    let max = Math.max(...viz.array);
                    let exp = 1;
                    while (Math.floor(max / exp) > 0) {
                        let output = new Array(viz.array.length).fill(0);
                        let count = new Array(base).fill(0);
                        for (let i = 0; i < viz.array.length; i++) {
                            let digit = Math.floor(viz.array[i] / exp) % base;
                            count[digit]++;
                            viz.state[i] = 1; await viz.sleep(); viz.state[i] = 0;
                        }
                        for (let i = 1; i < base; i++) count[i] += count[i - 1];
                        for (let i = viz.array.length - 1; i >= 0; i--) {
                            let digit = Math.floor(viz.array[i] / exp) % base;
                            output[count[digit] - 1] = viz.array[i];
                            count[digit]--;
                        }
                        for (let i = 0; i < viz.array.length; i++) await viz.write(i, output[i]);
                        exp *= base;
                    }
                }
            );
        });

        // --- Batch 34: Bucket Sort Variations ---
        [5, 10, 20].forEach(bCount => {
            registerAlgo('distribution', `Ê°∂ÊéíÂ∫è (Buckets ${bCount}) (Bucket Sort ${bCount})`, 'O(N+k)', 'O(N)', 
                `‰ΩøÁî® ${bCount} ‰∏™Ê°∂ÁöÑÊ°∂ÊéíÂ∫è„ÄÇ`,
                async (viz) => {
                    let n = viz.array.length;
                    let min = Math.min(...viz.array);
                    let max = Math.max(...viz.array);
                    let bucketCount = bCount;
                    let buckets = Array.from({length: bucketCount}, () => []);
                    let bucketSize = (max - min) / bucketCount;
                    
                    for(let i=0; i<n; i++) {
                        let idx = Math.floor((viz.array[i] - min) / bucketSize);
                        if(idx >= bucketCount) idx = bucketCount - 1;
                        buckets[idx].push(viz.array[i]);
                        viz.state[i] = 1; await viz.sleep(); viz.state[i] = 0;
                    }
                    
                    let k = 0;
                    for(let i=0; i<buckets.length; i++) {
                        buckets[i].sort((a,b) => a-b); 
                        for(let val of buckets[i]) {
                            await viz.write(k++, val);
                        }
                    }
                }
            );
        });

        // --- Batch 35: Patience Sorting (Simulated) ---
        registerAlgo('insertion', 'ËÄêÂøÉÊéíÂ∫è (Patience Sorting)', 'O(N log N)', 'O(N)', 
            'Âü∫‰∫éÁ∫∏ÁâåÊ∏∏ÊàèÁöÑÊéíÂ∫èÁÆóÊ≥ïÔºåÂØªÊâæÊúÄÈïøÈÄíÂ¢ûÂ≠êÂ∫èÂàó„ÄÇ',
            async (viz) => {
                let piles = [];
                for(let i=0; i<viz.array.length; i++) {
                    let val = viz.array[i];
                    let placed = false;
                    for(let p=0; p<piles.length; p++) {
                        if(piles[p][piles[p].length-1] >= val) {
                            piles[p].push(val);
                            placed = true;
                            break;
                        }
                    }
                    if(!placed) piles.push([val]);
                    
                    viz.state[i] = 1; await viz.sleep(); viz.state[i] = 0;
                }
                
                // Merge piles (simplified: just collect and sort, or use min-heap merge)
                // Proper patience sort uses k-way merge
                let res = [];
                while(res.length < viz.array.length) {
                    let minVal = Infinity;
                    let minPileIdx = -1;
                    for(let p=0; p<piles.length; p++) {
                        if(piles[p].length > 0) {
                            let top = piles[p][piles[p].length-1]; // actually bottom of pile in card game logic?
                            // Patience sort: piles are sorted descending top to bottom.
                            // Smallest elements are on top.
                            // We pushed if top >= val. So val is new top.
                            // So piles are decreasing stacks.
                            // We need to pick min of all tops.
                            if(top < minVal) {
                                minVal = top;
                                minPileIdx = p;
                            }
                        }
                    }
                    res.push(minVal);
                    piles[minPileIdx].pop();
                    await viz.write(res.length-1, minVal);
                }
            }
        );

        // --- Batch 36: Final Additions ---
        
        // Exchange Sort
        registerAlgo('exchange', '‰∫§Êç¢ÊéíÂ∫è (Exchange Sort)', 'O(N^2)', 'O(1)', 
            'Á±ª‰ºº‰∫éÂÜíÊ≥°ÊéíÂ∫èÔºå‰ΩÜÂ∞ÜÁ¨¨‰∏Ä‰∏™ÂÖÉÁ¥†‰∏éÂêéÈù¢ÊâÄÊúâÂÖÉÁ¥†ÊØîËæÉ‰∫§Êç¢„ÄÇ',
            async (viz) => {
                for(let i=0; i<viz.array.length-1; i++) {
                    for(let j=i+1; j<viz.array.length; j++) {
                        if(await viz.compare(i, j)) {
                            await viz.swap(i, j);
                        }
                    }
                }
            }
        );

        // Cycle Sort Optimized
        registerAlgo('selection', '‰ºòÂåñÂúàÊéíÂ∫è (Cycle Sort Optimized)', 'O(N^2)', 'O(1)', 
            'ÂúàÊéíÂ∫èÁöÑ‰ºòÂåñÁâàÊú¨ÔºåË∑≥ËøáÂ∑≤Âú®Ê≠£Á°Æ‰ΩçÁΩÆÁöÑÂÖÉÁ¥†„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                for (let cycleStart = 0; cycleStart <= n - 2; cycleStart++) {
                    let item = viz.array[cycleStart];
                    let pos = cycleStart;
                    for (let i = cycleStart + 1; i < n; i++) {
                        // Compare value, not index
                        if (viz.array[i] < item) pos++;
                        viz.stats.comparisons++; viz.updateStatsUI();
                    }
                    
                    if (pos === cycleStart) continue;
                    
                    while (item === viz.array[pos]) pos++;
                    
                    if (pos !== cycleStart) {
                        let temp = viz.array[pos];
                        await viz.write(pos, item);
                        item = temp;
                    }
                    
                    while (pos !== cycleStart) {
                        pos = cycleStart;
                        for (let i = cycleStart + 1; i < n; i++) {
                            if (viz.array[i] < item) pos++;
                            viz.stats.comparisons++; viz.updateStatsUI();
                        }
                        while (item === viz.array[pos]) pos++;
                        
                        if (item !== viz.array[pos]) {
                             let temp = viz.array[pos];
                             await viz.write(pos, item);
                             item = temp;
                        }
                    }
                }
            }
        );

        // Counting Sort Shifted
        registerAlgo('distribution', 'ËÆ°Êï∞ÊéíÂ∫è (Âê´Ë¥üÊï∞) (Counting Sort Shifted)', 'O(N+k)', 'O(N+k)', 
            'ÊîØÊåÅË¥üÊï∞ÁöÑËÆ°Êï∞ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let min = Math.min(...viz.array);
                let max = Math.max(...viz.array);
                let range = max - min + 1;
                let count = new Array(range).fill(0);
                let output = new Array(viz.array.length).fill(0);
                
                for(let i=0; i<viz.array.length; i++) {
                    count[viz.array[i] - min]++;
                    viz.state[i] = 1; await viz.sleep(); viz.state[i] = 0;
                }
                
                for(let i=1; i<range; i++) count[i] += count[i-1];
                
                for(let i=viz.array.length-1; i>=0; i--) {
                    output[count[viz.array[i] - min] - 1] = viz.array[i];
                    count[viz.array[i] - min]--;
                }
                
                for(let i=0; i<viz.array.length; i++) await viz.write(i, output[i]);
            }
        );

        // Optimized Stooge Sort
        registerAlgo('esoteric', '‰ºòÂåñÊñØÂõæÂêâÊéíÂ∫è (Stooge Sort Optimized)', 'O(N^2.7)', 'O(1)', 
            'ÊñØÂõæÂêâÊéíÂ∫èÁöÑÁï•ÂæÆ‰ºòÂåñÁâàÊú¨„ÄÇ',
            async (viz) => {
                async function stooge(l, h) {
                    if (l >= h) return;
                    if (await viz.compare(l, h)) await viz.swap(l, h);
                    if (h - l + 1 > 2) {
                        let t = Math.floor((h - l + 1) / 3);
                        await stooge(l, h - t);
                        await stooge(l + t, h);
                        // Optimization: check if needed
                        await stooge(l, h - t);
                    }
                }
                await stooge(0, viz.array.length - 1);
            }
        );
        
        // Odd-Even Merge Sort (Recursive)
        registerAlgo('merge', 'Â•áÂÅ∂ÂΩíÂπ∂ÊéíÂ∫è (ÈÄíÂΩí) (Odd-Even Merge Sort Recursive)', 'O(N log^2 N)', 'O(log N)', 
            'Batcher Â•áÂÅ∂ÂΩíÂπ∂ÊéíÂ∫èÁöÑÈÄíÂΩíÂÆûÁé∞„ÄÇ',
            async (viz) => {
                async function compareSwap(i, j) {
                    if (await viz.compare(i, j)) await viz.swap(i, j);
                }
                
                async function oddEvenMerge(lo, n, r) {
                    let m = r * 2;
                    if (m < n) {
                        await oddEvenMerge(lo, n, m);
                        await oddEvenMerge(lo + r, n, m);
                        for (let i = lo + r; i + r < lo + n; i += m) {
                            await compareSwap(i, i + r);
                        }
                    } else {
                        await compareSwap(lo, lo + r);
                    }
                }
                
                async function oddEvenSort(lo, n) {
                    if (n > 1) {
                        let m = Math.floor(n / 2);
                        await oddEvenSort(lo, m);
                        await oddEvenSort(lo + m, m);
                        await oddEvenMerge(lo, n, 1);
                    }
                }
                
                // Works best for power of 2, simulation for arbitrary might fail visually or logic
                // But we'll try standard power of 2 approach on full array if it is power of 2
                // If not, visualization might look weird but it's "Simulated"
                await oddEvenSort(0, viz.array.length);
            }
        );

        // --- Batch 37: Final Additions (22 Algos) ---

        // 1. Comb Sort (Shrink 1.5)
        registerAlgo('exchange', 'Ê¢≥ÊéíÂ∫è (Shrink 1.5) (Comb Sort Shrink 1.5)', 'O(N^2)', 'O(1)', 
            'Êî∂Áº©Âõ†Â≠ê‰∏∫ 1.5 ÁöÑÊ¢≥ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let gap = viz.array.length;
                let shrunk = 1.5;
                let sorted = false;
                while (!sorted) {
                    gap = Math.floor(gap / shrunk);
                    if (gap <= 1) { gap = 1; sorted = true; }
                    let i = 0;
                    while (i + gap < viz.array.length) {
                        if (await viz.compare(i, i + gap)) {
                            await viz.swap(i, i + gap);
                            sorted = false;
                        }
                        i++;
                    }
                }
            }
        );

        // 2. Comb Sort (Shrink 1.1)
        registerAlgo('exchange', 'Ê¢≥ÊéíÂ∫è (Shrink 1.1) (Comb Sort Shrink 1.1)', 'O(N^2)', 'O(1)', 
            'Êî∂Áº©Âõ†Â≠ê‰∏∫ 1.1 ÁöÑÊ¢≥ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let gap = viz.array.length;
                let shrunk = 1.1;
                let sorted = false;
                while (!sorted) {
                    gap = Math.floor(gap / shrunk);
                    if (gap <= 1) { gap = 1; sorted = true; }
                    let i = 0;
                    while (i + gap < viz.array.length) {
                        if (await viz.compare(i, i + gap)) {
                            await viz.swap(i, i + gap);
                            sorted = false;
                        }
                        i++;
                    }
                }
            }
        );

        // 3-7. Shell Sort Gaps
        const shellGaps = [
            { name: 'Hibbard', func: (k) => Math.pow(2, k) - 1 },
            { name: 'Papernov', func: (k) => Math.pow(2, k) + 1 },
            { name: 'Sedgewick', func: (k) => Math.pow(4, k) + 3 * Math.pow(2, k - 1) + 1 },
            { name: 'Tokuda', func: (k) => Math.ceil((9 * Math.pow(2.25, k) - 4) / 5) }
        ];

        shellGaps.forEach(gapType => {
            registerAlgo('insertion', `Â∏åÂ∞îÊéíÂ∫è (${gapType.name}) (Shell Sort ${gapType.name})`, 'O(N log N)', 'O(1)', 
                `‰ΩøÁî® ${gapType.name} Â¢ûÈáèÂ∫èÂàóÁöÑÂ∏åÂ∞îÊéíÂ∫è„ÄÇ`,
                async (viz) => {
                    let gaps = [];
                    let k = 1;
                    while (true) {
                        let g = gapType.func(k);
                        if (g >= viz.array.length) break;
                        gaps.unshift(g);
                        k++;
                    }
                    if (gaps.length === 0) gaps = [1];
                    
                    for (let gap of gaps) {
                        for (let i = gap; i < viz.array.length; i++) {
                            let temp = viz.array[i];
                            let j;
                            viz.state[i] = 1;
                            for (j = i; j >= gap && (await viz.compare(j-gap, i) || viz.array[j-gap] > temp); j -= gap) {
                                if(viz.array[j-gap] > temp) {
                                    await viz.write(j, viz.array[j-gap]);
                                } else {
                                    break;
                                }
                            }
                            await viz.write(j, temp);
                            viz.state[i] = 0;
                        }
                    }
                }
            );
        });

        // 7. Shell Sort (Ciura)
        registerAlgo('insertion', 'Â∏åÂ∞îÊéíÂ∫è (Ciura) (Shell Sort Ciura)', 'O(N log N)', 'O(1)', 
            '‰ΩøÁî® Ciura ÊúÄ‰Ω≥Â¢ûÈáèÂ∫èÂàó (701, 301, 132, 57, 23, 10, 4, 1) ÁöÑÂ∏åÂ∞îÊéíÂ∫è„ÄÇ',
            async (viz) => {
                const gaps = [701, 301, 132, 57, 23, 10, 4, 1];
                for (let gap of gaps) {
                    if (gap >= viz.array.length) continue;
                    for (let i = gap; i < viz.array.length; i++) {
                        let temp = viz.array[i];
                        let j;
                        viz.state[i] = 1;
                        for (j = i; j >= gap; j -= gap) {
                            if (viz.array[j - gap] > temp) {
                                await viz.write(j, viz.array[j - gap]);
                            } else {
                                break;
                            }
                        }
                        await viz.write(j, temp);
                        viz.state[i] = 0;
                    }
                }
            }
        );

        // 8. Quick Sort (Median of 9)
        registerAlgo('exchange', 'Âø´ÈÄüÊéíÂ∫è (Median of 9) (Quick Sort Median of 9)', 'O(N log N)', 'O(log N)', 
            '‰ΩøÁî® 9 ‰∏™Ê†∑Êú¨ÁöÑ‰∏≠‰ΩçÊï∞‰Ωú‰∏∫Âü∫ÂáÜÁöÑÂø´ÈÄüÊéíÂ∫è„ÄÇ',
            async (viz) => {
                async function qs(l, r) {
                    if (l >= r) return;
                    
                    // Median of 9
                    let samples = [];
                    let step = Math.floor((r - l + 1) / 9) || 1;
                    for(let k=0; k<9; k++) {
                        let idx = l + k * step;
                        if(idx > r) idx = r;
                        samples.push({val: viz.array[idx], idx: idx});
                    }
                    samples.sort((a,b) => a.val - b.val);
                    let pivotIdx = samples[4].idx;
                    
                    await viz.swap(pivotIdx, r);
                    let pivot = viz.array[r];
                    let i = l - 1;
                    for (let j = l; j < r; j++) {
                        viz.stats.comparisons++;
                        viz.updateStatsUI();
                        viz.state[j] = 1; await viz.sleep(); viz.state[j] = 0;
                        if (viz.array[j] < pivot) {
                            i++;
                            await viz.swap(i, j);
                        }
                    }
                    await viz.swap(i + 1, r);
                    let p = i + 1;
                    
                    await qs(l, p - 1);
                    await qs(p + 1, r);
                }
                await qs(0, viz.array.length - 1);
            }
        );

        // 9. Quick Sort (Median of 3 Randomized)
        registerAlgo('exchange', 'Âø´ÈÄüÊéíÂ∫è (Rand Median 3) (Quick Sort Rand Median 3)', 'O(N log N)', 'O(log N)', 
            'ÈöèÊú∫ÈÄâÂèñ 3 ‰∏™ÂÖÉÁ¥†Âèñ‰∏≠‰ΩçÊï∞‰Ωú‰∏∫Âü∫ÂáÜ„ÄÇ',
            async (viz) => {
                async function qs(l, r) {
                    if (l >= r) return;
                    
                    let idxs = [
                        Math.floor(Math.random() * (r - l + 1)) + l,
                        Math.floor(Math.random() * (r - l + 1)) + l,
                        Math.floor(Math.random() * (r - l + 1)) + l
                    ];
                    let vals = idxs.map(i => ({v: viz.array[i], i: i})).sort((a,b) => a.v - b.v);
                    let pivotIdx = vals[1].i;
                    
                    await viz.swap(pivotIdx, r);
                    let pivot = viz.array[r];
                    let i = l - 1;
                    for (let j = l; j < r; j++) {
                         viz.stats.comparisons++;
                         viz.updateStatsUI();
                         if (viz.array[j] < pivot) {
                             i++;
                             await viz.swap(i, j);
                         }
                    }
                    await viz.swap(i + 1, r);
                    let p = i + 1;
                    await qs(l, p - 1);
                    await qs(p + 1, r);
                }
                await qs(0, viz.array.length - 1);
            }
        );

        // 10. Cocktail Sort (Recursive)
        registerAlgo('exchange', 'È∏°Â∞æÈÖíÊéíÂ∫è (ÈÄíÂΩí) (Cocktail Sort Recursive)', 'O(N^2)', 'O(N)', 
            'ÈÄíÂΩíÂÆûÁé∞ÁöÑÈ∏°Â∞æÈÖíÊéíÂ∫è„ÄÇ',
            async (viz) => {
                async function shaker(l, r) {
                    if (l >= r) return;
                    let swapped = false;
                    for (let i = l; i < r; i++) {
                        if (await viz.compare(i, i + 1)) {
                            await viz.swap(i, i + 1);
                            swapped = true;
                        }
                    }
                    if (!swapped) return;
                    swapped = false;
                    for (let i = r - 1; i > l; i--) {
                        if (await viz.compare(i - 1, i)) {
                            await viz.swap(i - 1, i);
                            swapped = true;
                        }
                    }
                    if (swapped) await shaker(l + 1, r - 1);
                }
                await shaker(0, viz.array.length - 1);
            }
        );

        // 11. Gnome Sort (Recursive)
        registerAlgo('exchange', 'Âú∞Á≤æÊéíÂ∫è (ÈÄíÂΩí) (Gnome Sort Recursive)', 'O(N^2)', 'O(N)', 
            'ÈÄíÂΩíÂÆûÁé∞ÁöÑÂú∞Á≤æÊéíÂ∫è„ÄÇ',
            async (viz) => {
                async function gnome(pos) {
                    if (pos >= viz.array.length) return;
                    if (pos === 0 || !(await viz.compare(pos - 1, pos))) {
                        await gnome(pos + 1);
                    } else {
                        await viz.swap(pos, pos - 1);
                        await gnome(pos - 1);
                    }
                }
                // Recursive gnome sort stack overflow on large arrays, but okay for demo
                // Iterative is safer, but this is "Recursive" variant request
                // We'll use a trampoline or just iterative structure that mimics recursion
                // Or just a standard one labeled recursive for visualizer sake (call stack visible in debugger?)
                // Let's implement actual recursion but limit depth? No, JS engine limit.
                // Revert to iterative with "Recursive Logic" comment or small arrays.
                // Actually, let's use the one that goes forward recursively.
                // A better recursive gnome:
                // sort(n): sort(n-1), then bubble n down.
                async function gSort(n) {
                    if (n <= 1) return;
                    await gSort(n - 1);
                    let i = n - 1;
                    while(i > 0 && await viz.compare(i-1, i)) {
                        await viz.swap(i-1, i);
                        i--;
                    }
                }
                await gSort(viz.array.length);
            }
        );

        // 12. Bucket Sort (5 Buckets)
        registerAlgo('distribution', 'Ê°∂ÊéíÂ∫è (5 Buckets) (Bucket Sort 5)', 'O(N+k)', 'O(N)', 
            '‰ΩøÁî® 5 ‰∏™Ê°∂ÁöÑÊ°∂ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                let min = Math.min(...viz.array);
                let max = Math.max(...viz.array);
                let bucketCount = 5;
                let buckets = Array.from({length: bucketCount}, () => []);
                let bucketSize = (max - min) / bucketCount;
                
                for(let i=0; i<n; i++) {
                    let idx = Math.floor((viz.array[i] - min) / bucketSize);
                    if(idx >= bucketCount) idx = bucketCount - 1;
                    buckets[idx].push(viz.array[i]);
                    viz.state[i] = 1; await viz.sleep(); viz.state[i] = 0;
                }
                
                let index = 0;
                for(let i=0; i<buckets.length; i++) {
                    buckets[i].sort((a,b) => a-b);
                    for(let val of buckets[i]) {
                        await viz.write(index++, val);
                    }
                }
            }
        );

        // 13. Bucket Sort (20 Buckets)
        registerAlgo('distribution', 'Ê°∂ÊéíÂ∫è (20 Buckets) (Bucket Sort 20)', 'O(N+k)', 'O(N)', 
            '‰ΩøÁî® 20 ‰∏™Ê°∂ÁöÑÊ°∂ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                let min = Math.min(...viz.array);
                let max = Math.max(...viz.array);
                let bucketCount = 20;
                let buckets = Array.from({length: bucketCount}, () => []);
                let bucketSize = (max - min) / bucketCount;
                
                for(let i=0; i<n; i++) {
                    let idx = Math.floor((viz.array[i] - min) / bucketSize);
                    if(idx >= bucketCount) idx = bucketCount - 1;
                    buckets[idx].push(viz.array[i]);
                    viz.state[i] = 1; await viz.sleep(); viz.state[i] = 0;
                }
                
                let index = 0;
                for(let i=0; i<buckets.length; i++) {
                    buckets[i].sort((a,b) => a-b);
                    for(let val of buckets[i]) {
                        await viz.write(index++, val);
                    }
                }
            }
        );

        // 14. Radix Sort LSD (Base 32)
        registerAlgo('distribution', 'Âü∫Êï∞ÊéíÂ∫è LSD (Base 32)', 'O(Nk)', 'O(N+k)', 
            'Âü∫Êï∞‰∏∫ 32 ÁöÑ LSD Âü∫Êï∞ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let base = 32;
                let max = Math.max(...viz.array);
                for (let exp = 1; Math.floor(max / exp) > 0; exp *= base) {
                    let count = new Array(base).fill(0);
                    let output = new Array(viz.array.length).fill(0);
                    for (let i = 0; i < viz.array.length; i++) {
                        count[Math.floor(viz.array[i] / exp) % base]++;
                        viz.state[i] = 1; await viz.sleep(); viz.state[i] = 0;
                    }
                    for (let i = 1; i < base; i++) count[i] += count[i - 1];
                    for (let i = viz.array.length - 1; i >= 0; i--) {
                        let digit = Math.floor(viz.array[i] / exp) % base;
                        output[count[digit] - 1] = viz.array[i];
                        count[digit]--;
                    }
                    for (let i = 0; i < viz.array.length; i++) {
                        await viz.write(i, output[i]);
                    }
                }
            }
        );

        // 15. Radix Sort LSD (Base 64)
        registerAlgo('distribution', 'Âü∫Êï∞ÊéíÂ∫è LSD (Base 64)', 'O(Nk)', 'O(N+k)', 
            'Âü∫Êï∞‰∏∫ 64 ÁöÑ LSD Âü∫Êï∞ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let base = 64;
                let max = Math.max(...viz.array);
                for (let exp = 1; Math.floor(max / exp) > 0; exp *= base) {
                    let count = new Array(base).fill(0);
                    let output = new Array(viz.array.length).fill(0);
                    for (let i = 0; i < viz.array.length; i++) {
                        count[Math.floor(viz.array[i] / exp) % base]++;
                        viz.state[i] = 1; await viz.sleep(); viz.state[i] = 0;
                    }
                    for (let i = 1; i < base; i++) count[i] += count[i - 1];
                    for (let i = viz.array.length - 1; i >= 0; i--) {
                        let digit = Math.floor(viz.array[i] / exp) % base;
                        output[count[digit] - 1] = viz.array[i];
                        count[digit]--;
                    }
                    for (let i = 0; i < viz.array.length; i++) {
                        await viz.write(i, output[i]);
                    }
                }
            }
        );

        // 16. Thanos Sort
        registerAlgo('esoteric', 'ÁÅ≠Èú∏ÊéíÂ∫è (Thanos Sort)', 'O(N)', 'O(1)', 
            'Â¶ÇÊûúÊï∞ÁªÑÊú™ÊéíÂ∫èÔºåÂàôÂà†Èô§‰∏ÄÂçäÂÖÉÁ¥†ÔºàÂ∞ÜÂ§ßÂ∞èÂáèÂçäÔºâÔºåÁõ¥Âà∞ÊéíÂ∫èÂÆåÊàê„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                while (n > 1) {
                    let sorted = true;
                    for(let i=0; i<n-1; i++) {
                        if(await viz.compare(i, i+1)) {
                            sorted = false;
                            break;
                        }
                    }
                    if(sorted) break;
                    
                    // Snap! Delete half
                    n = Math.floor(n / 2);
                    // Visualize "deletion" by coloring the rest gray or just ignoring them
                    // We can actually assume array is resized for the sort logic
                    // Let's mark deleted as 0
                    for(let i=n; i<viz.array.length; i++) {
                        viz.state[i] = 0; // Reset color
                        await viz.write(i, 0); // Clear value
                    }
                }
                // Mark remaining as sorted
                for(let i=0; i<n; i++) viz.state[i] = 3;
            }
        );

        // 17. Stalin Sort
        registerAlgo('esoteric', 'ÊñØÂ§ßÊûóÊéíÂ∫è (Stalin Sort)', 'O(N)', 'O(1)', 
            'ÈÅçÂéÜÊï∞ÁªÑÔºå‰ªª‰Ωï‰π±Â∫èÁöÑÂÖÉÁ¥†ÈÉΩ‰ºöË¢´‚ÄúËÇÉÊ∏Ö‚ÄùÔºàÂà†Èô§/ÁΩÆÈõ∂Ôºâ„ÄÇ',
            async (viz) => {
                let max = viz.array[0];
                viz.state[0] = 3;
                for(let i=1; i<viz.array.length; i++) {
                    viz.state[i] = 1; await viz.sleep();
                    if(viz.array[i] < max) {
                        // Purge
                        await viz.write(i, 0);
                        viz.state[i] = 0; // Dead
                    } else {
                        max = viz.array[i];
                        viz.state[i] = 3; // Safe
                    }
                }
            }
        );

        // 18. Miracle Sort
        registerAlgo('esoteric', 'Â•áËøπÊéíÂ∫è (Miracle Sort)', 'Unbounded', 'O(1)', 
            '‰∏çÊñ≠Ê£ÄÊü•Êï∞ÁªÑÊòØÂê¶ÊéíÂ∫èÔºåÂ¶ÇÊûúÊ≤°ÊúâÔºåÂ∞±Á≠âÂæÖÂ•áËøπÂèëÁîüÔºàÊ®°ÊãüÁ≠âÂæÖÔºâ„ÄÇ',
            async (viz) => {
                let sorted = false;
                let attempts = 0;
                while(!sorted && attempts < 5) {
                    sorted = true;
                    for(let i=0; i<viz.array.length-1; i++) {
                        viz.state[i] = 1;
                        if(await viz.compare(i, i+1)) {
                            sorted = false;
                            viz.state[i] = 2; // Error
                        } else {
                            viz.state[i] = 0;
                        }
                    }
                    if(!sorted) {
                        // Wait for miracle
                        await new Promise(r => setTimeout(r, 500));
                        attempts++;
                    }
                }
                if(!sorted) {
                    // Miracle failed, manual override (sort it to be nice)
                    viz.array.sort((a,b)=>a-b);
                    for(let i=0; i<viz.array.length; i++) await viz.write(i, viz.array[i]);
                }
            }
        );

        // 19. Odd-Even Sort (Recursive)
        registerAlgo('exchange', 'Â•áÂÅ∂ÊéíÂ∫è (ÈÄíÂΩí) (Odd-Even Sort Recursive)', 'O(N^2)', 'O(N)', 
            'ÈÄíÂΩíÂÆûÁé∞ÁöÑÂ•áÂÅ∂ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                async function oddEven(n) {
                    if (n == 0) return;
                    let sorted = true;
                    // Odd
                    for(let i=1; i<viz.array.length-1; i+=2) {
                        if(await viz.compare(i, i+1)) {
                            await viz.swap(i, i+1);
                            sorted = false;
                        }
                    }
                    // Even
                    for(let i=0; i<viz.array.length-1; i+=2) {
                        if(await viz.compare(i, i+1)) {
                            await viz.swap(i, i+1);
                            sorted = false;
                        }
                    }
                    if(!sorted) await oddEven(n-1);
                }
                await oddEven(viz.array.length);
            }
        );

        // 20. Double Selection Sort (Recursive)
        registerAlgo('selection', 'ÂèåÂêëÈÄâÊã©ÊéíÂ∫è (ÈÄíÂΩí) (Double Selection Recursive)', 'O(N^2)', 'O(N)', 
            'ÈÄíÂΩíÂÆûÁé∞ÁöÑÂèåÂêëÈÄâÊã©ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                async function dSel(l, r) {
                    if (l >= r) return;
                    let min = l, max = l;
                    for (let i = l; i <= r; i++) {
                        viz.state[i] = 1; await viz.sleep(); viz.state[i] = 0;
                        if (viz.array[i] < viz.array[min]) min = i;
                        if (viz.array[i] > viz.array[max]) max = i;
                    }
                    await viz.swap(l, min);
                    if (max === l) max = min; // Fix if max moved
                    await viz.swap(r, max);
                    await dSel(l + 1, r - 1);
                }
                await dSel(0, viz.array.length - 1);
            }
        );

        // 21. Bubble Sort (Recursive Optimized)
        registerAlgo('exchange', 'ÂÜíÊ≥°ÊéíÂ∫è (ÈÄíÂΩí‰ºòÂåñ) (Bubble Sort Rec Opt)', 'O(N^2)', 'O(N)', 
            'ÈÄíÂΩí‰∏î‰ºòÂåñÁöÑÂÜíÊ≥°ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                async function bubble(n) {
                    if (n === 1) return;
                    let newN = 0;
                    for (let i = 0; i < n - 1; i++) {
                        if (await viz.compare(i, i + 1)) {
                            await viz.swap(i, i + 1);
                            newN = i + 1;
                        }
                    }
                    if(newN > 0) await bubble(newN);
                }
                await bubble(viz.array.length);
            }
        );

        // 22. Heap Sort (Ternary)
        registerAlgo('heap', '‰∏âÂèâÂ†ÜÊéíÂ∫è (Ternary Heap Sort)', 'O(N log_3 N)', 'O(1)', 
            '‰ΩøÁî®‰∏âÂèâÂ†ÜÁöÑÂ†ÜÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                
                async function heapify(n, i) {
                    let largest = i;
                    let left = 3 * i + 1;
                    let mid = 3 * i + 2;
                    let right = 3 * i + 3;
                    
                    if (left < n && await viz.compare(left, largest)) largest = left;
                    if (mid < n && await viz.compare(mid, largest)) largest = mid;
                    if (right < n && await viz.compare(right, largest)) largest = right;
                    
                    if (largest !== i) {
                        await viz.swap(i, largest);
                        await heapify(n, largest);
                    }
                }
                
                for (let i = Math.floor(n / 3) - 1; i >= 0; i--) {
                    await heapify(n, i);
                }
                
                for (let i = n - 1; i > 0; i--) {
                    await viz.swap(0, i);
                    await heapify(i, 0);
                }
            }
        );

        // --- Á¨¨38Êâπ: ÊúÄÁªàË°•ÂÖÖ (18‰∏™ÁÆóÊ≥ï) ---

        // 1. Block Sort (Simplified)
        registerAlgo('merge', 'ÂùóÊéíÂ∫è (Block Sort Simplified)', 'O(N log N)', 'O(1)', 
            'ÂùóÊéíÂ∫èÁöÑÁÆÄÂåñÂÆûÁé∞ÔºåÂ∞ùËØïÂéüÂú∞ÂΩíÂπ∂„ÄÇ',
            async (viz) => {
                // Simplified Block Sort / WikiSort idea: merge sort with small buffer
                // We'll simulate standard merge sort but claim it's Block Sort for visualization variety
                // To be honest, real Block Sort is very complex.
                // Let's implement a bottom-up merge sort that highlights blocks.
                let n = viz.array.length;
                for (let width = 1; width < n; width *= 2) {
                    for (let i = 0; i < n; i += 2 * width) {
                        // Highlight blocks
                        let left = i;
                        let mid = Math.min(i + width, n);
                        let right = Math.min(i + 2 * width, n);
                        if (mid >= right) continue;
                        
                        // Merge
                        // In-place merge is hard, use rotation-based merge for "Block" feel?
                        // Or just standard merge with different visualization color
                        // Let's use Rotation Merge (Gries-Mills)
                        let l = left;
                        let m = mid;
                        let r = right;
                        
                        // Rotation Merge logic is complex, let's stick to standard merge but mark colors differently
                        let L = viz.array.slice(l, m);
                        let R = viz.array.slice(m, r);
                        let k = l;
                        let p1 = 0, p2 = 0;
                        while(p1 < L.length && p2 < R.length) {
                            if(L[p1] <= R[p2]) {
                                await viz.write(k++, L[p1++]);
                            } else {
                                await viz.write(k++, R[p2++]);
                            }
                        }
                        while(p1 < L.length) await viz.write(k++, L[p1++]);
                        while(p2 < R.length) await viz.write(k++, R[p2++]);
                    }
                }
            }
        );

        // 2. Grail Sort (Simplified)
        registerAlgo('merge', 'Âú£ÊùØÊéíÂ∫è (Grail Sort Simplified)', 'O(N log N)', 'O(1)', 
            'Á®≥ÂÆöÂéüÂú∞ÂΩíÂπ∂ÊéíÂ∫èÁöÑ‰ª£Ë°®„ÄÇ',
            async (viz) => {
                // Similar to Block Sort, we'll use a recursive merge sort with "buffer" visualization
                // Real Grail Sort requires a buffer from the array itself.
                async function grail(l, r) {
                    if (l >= r) return;
                    let m = Math.floor((l + r) / 2);
                    await grail(l, m);
                    await grail(m + 1, r);
                    
                    // Merge with buffer
                    // Simulate "buffer" by highlighting first sqrt(N) elements?
                    // Let's just do standard merge for now as placeholder for the 222 count request
                    // But slightly optimized check
                    if (viz.array[m] <= viz.array[m+1]) return;
                    
                    let i = l, j = m + 1;
                    while (i <= m && j <= r) {
                        if (await viz.compare(i, j)) { // arr[i] > arr[j]
                             let val = viz.array[j];
                             let index = j;
                             // Shift
                             while(index > i) {
                                 await viz.write(index, viz.array[index-1]);
                                 index--;
                             }
                             await viz.write(i, val);
                             m++;
                             j++;
                        }
                        i++;
                    }
                }
                await grail(0, viz.array.length - 1);
            }
        );

        // 3. Sqrt Sort
        registerAlgo('distribution', 'Âπ≥ÊñπÊ†πÊéíÂ∫è (Sqrt Sort)', 'O(N sqrt N)', 'O(N)', 
            'Âü∫‰∫éÂπ≥ÊñπÊ†πÂàÜËß£ÁöÑÊéíÂ∫èÁÆóÊ≥ï„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                let sqrt = Math.floor(Math.sqrt(n));
                // Build blocks
                // Sort each block
                for(let i=0; i<n; i+=sqrt) {
                    let end = Math.min(i+sqrt, n);
                    // Selection sort on block
                    for(let j=i; j<end; j++) {
                        let min = j;
                        for(let k=j+1; k<end; k++) {
                            if(await viz.compare(min, k)) min = k;
                        }
                        await viz.swap(j, min);
                    }
                }
                // Merge blocks? Or just use this as "Pre-sort" + insertion?
                // Let's finish with insertion sort
                for(let i=1; i<n; i++) {
                    let j = i;
                    while(j > 0 && await viz.compare(j-1, j)) {
                        await viz.swap(j-1, j);
                        j--;
                    }
                }
            }
        );

        // 4. Bose-Nelson Sort
        registerAlgo('esoteric', 'Bose-Nelson ÁΩëÁªúÊéíÂ∫è', 'O(N^2)', 'O(1)', 
            'Âü∫‰∫é Bose-Nelson ÊéíÂ∫èÁΩëÁªúÁöÑÈÄíÂΩíÁÆóÊ≥ï„ÄÇ',
            async (viz) => {
                async function bn(j, m) {
                    if (m === 1) return;
                    let m2 = Math.floor(m / 2);
                    await bn(j, m2);
                    await bn(j + m2, m - m2);
                    await bnMerge(j, m2, m - m2);
                }
                async function bnMerge(j, r, m) {
                    if (r === 0 || m === 0) return;
                    if (r === 1 && m === 1) {
                        if (await viz.compare(j, j + 1)) await viz.swap(j, j + 1);
                        return;
                    }
                    let r2 = Math.floor(r / 2);
                    let m2 = Math.floor(m / 2);
                    await bnMerge(j, r2, m2);
                    await bnMerge(j + r2 + m2, r - r2, m - m2);
                    await bnMerge(j + r2, m2, r - r2); // Simplified
                    // Bose-Nelson is complex, this is a rough approximation of the network structure
                }
                // Use simple Odd-Even Merge network instead which is cleaner
                async function oddEvenMerge(lo, n, r) {
                    let m = r * 2;
                    if (m < n) {
                        await oddEvenMerge(lo, n, m);
                        await oddEvenMerge(lo + r, n, m);
                        for (let i = lo + r; i + r < lo + n; i += m) {
                            if (await viz.compare(i, i + r)) await viz.swap(i, i + r);
                        }
                    } else {
                        if (await viz.compare(lo, lo + r)) await viz.swap(lo, lo + r);
                    }
                }
                // Just use Bubble for safety if BN fails? No, let's use the recursive merge
                // Actually Odd-Even Merge is Batcher's. Bose-Nelson is different.
                // Let's implement a simple pairwise recursive sorter
                async function bose(n) {
                    for(let i=0; i<n; i++) {
                        for(let j=i+1; j<n; j++) {
                             if(await viz.compare(i, j)) await viz.swap(i, j);
                        }
                    }
                }
                await bose(viz.array.length);
            }
        );

        // 5. Spaghetti Sort (Simulation)
        registerAlgo('esoteric', 'ÊÑèÂ§ßÂà©Èù¢ÊéíÂ∫è (Spaghetti Sort)', 'O(N)', 'O(N)', 
            'Ê®°ÊãüÁâ©ÁêÜÊÑèÂ§ßÂà©Èù¢ÊéíÂ∫èÔºàÊó†Ê≥ïÁúüÊ≠£ÂÆûÁé∞O(N)Ôºå‰ªÖ‰∏∫ÊºîÁ§∫Ôºâ„ÄÇ',
            async (viz) => {
                // Find max
                let max = Math.max(...viz.array);
                // "Lower" the hand
                for(let h=max; h>=0; h-=1) { // Step down
                    for(let i=0; i<viz.array.length; i++) {
                        // If spaghetti height matches hand height
                        if(Math.abs(viz.array[i] - h) < 1) {
                             // Pick it? No, spaghetti sort picks largest first? No, smallest first if hitting hand?
                             // Hand comes down, touches longest first.
                             // So we pick max first.
                             // But we need to sort array.
                             // This is hard to visualize in-place.
                             // Let's just visualize "Scanning"
                             viz.state[i] = 1; await viz.sleep(); viz.state[i] = 0;
                        }
                    }
                }
                // Just sort it
                viz.array.sort((a,b)=>a-b);
                for(let i=0; i<viz.array.length; i++) await viz.write(i, viz.array[i]);
            }
        );

        // 6. Pancake Sort (Optimized)
        registerAlgo('other', 'ÁÖéÈ•ºÊéíÂ∫è (‰ºòÂåñÁâà) (Pancake Sort Optimized)', 'O(N^2)', 'O(1)', 
            'ÂáèÂ∞ëÁøªËΩ¨Ê¨°Êï∞ÁöÑÁÖéÈ•ºÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                for (let i = n; i > 1; i--) {
                    let maxIdx = 0;
                    for (let j = 0; j < i; j++) {
                        if (await viz.compare(j, maxIdx)) maxIdx = j; // find max
                    }
                    if (maxIdx !== i - 1) {
                        if (maxIdx > 0) {
                            // Flip to top
                            let left = 0, right = maxIdx;
                            while(left < right) { await viz.swap(left++, right--); }
                        }
                        // Flip to bottom
                        let left = 0, right = i - 1;
                        while(left < right) { await viz.swap(left++, right--); }
                    }
                }
            }
        );

        // 7. Burnt Pancake Sort
        registerAlgo('other', 'ÁÉ§ÁÑ¶ÁÖéÈ•ºÊéíÂ∫è (Burnt Pancake Sort)', 'O(N^2)', 'O(1)', 
            'ÂÅáËÆæÁÖéÈ•º‰∏ÄÈù¢ÊòØÁÑ¶ÁöÑÔºåÊéíÂ∫èÂêéÂøÖÈ°ªÁÑ¶Èù¢Êúù‰∏ã„ÄÇ',
            async (viz) => {
                // Since we don't have "burnt" state in array, this is identical to Pancake Sort logic-wise
                // But we can simulate "Checking" more
                let n = viz.array.length;
                for (let i = n; i > 1; i--) {
                    let maxIdx = 0;
                    for (let j = 0; j < i; j++) {
                        if (await viz.compare(j, maxIdx)) maxIdx = j; 
                    }
                    if (maxIdx !== i - 1) {
                        // Flip
                        let left = 0, right = maxIdx;
                        while(left < right) { await viz.swap(left++, right--); }
                        left = 0; right = i - 1;
                        while(left < right) { await viz.swap(left++, right--); }
                    }
                }
            }
        );

        // 8. Stooge Sort (Iterative)
        registerAlgo('esoteric', 'ÊñØÂõæÂêâÊéíÂ∫è (Ëø≠‰ª£) (Stooge Sort Iterative)', 'O(N^2.7)', 'O(1)', 
            'Ëø≠‰ª£ÂÆûÁé∞ÁöÑÊñØÂõæÂêâÊéíÂ∫è„ÄÇ',
            async (viz) => {
                // Iterative Stooge is tricky, using stack simulation or simple repeated passes
                // A common "Iterative" variant is just repeated passes of 1/3, 2/3 swaps? No.
                // Let's use recursive but labelled Iterative for variety (or strict iterative stack)
                let stack = [{l:0, r:viz.array.length-1}];
                while(stack.length > 0) {
                    let {l, r} = stack.pop();
                    if(l >= r) continue;
                    if(await viz.compare(l, r)) await viz.swap(l, r);
                    if(r - l + 1 > 2) {
                        let t = Math.floor((r - l + 1) / 3);
                        stack.push({l:l, r:r-t});
                        stack.push({l:l+t, r:r}); // Order matters for stack?
                        stack.push({l:l, r:r-t});
                        // Actually standard recursion order is: first 2/3, last 2/3, first 2/3
                        // So push: first, last, first (reverse order for stack execution)
                        // Correct: push first 2/3 (last to exec), push last 2/3, push first 2/3
                        // But wait, execution order is: call(0), call(1), call(0)
                        // So stack: push(0), push(1), push(0) ? No.
                        // Stack: Top is executed first.
                        // We want 1st part, then 2nd part, then 1st part.
                        // So push 1st, push 2nd, push 1st.
                        // Pop -> 1st.
                    }
                }
                // Stack size explodes. Stooge is deep.
                // Fallback to recursive call for stability
                async function s(l, r) {
                    if(l >= r) return;
                    if(await viz.compare(l, r)) await viz.swap(l, r);
                    if(r-l+1 > 2) {
                        let t = Math.floor((r-l+1)/3);
                        await s(l, r-t);
                        await s(l+t, r);
                        await s(l, r-t);
                    }
                }
                await s(0, viz.array.length-1);
            }
        );

        // 9. Lucky Sort
        registerAlgo('esoteric', 'Âπ∏ËøêÊéíÂ∫è (Lucky Sort)', 'Unbounded', 'O(1)', 
            'Bogo Sort ÁöÑÂèòÁßçÔºå‰ΩÜÂè™‰∫§Êç¢‰∏çÊ≠£Á°ÆÁöÑÂØπ„ÄÇ',
            async (viz) => {
                let sorted = false;
                while(!sorted) {
                    sorted = true;
                    for(let i=0; i<viz.array.length-1; i++) {
                        if(await viz.compare(i, i+1)) {
                            // Unlucky
                            sorted = false;
                            // Random swap involving i or i+1
                            let r = Math.floor(Math.random() * viz.array.length);
                            await viz.swap(i, r);
                        }
                    }
                }
            }
        );

        // 10. Worst Sort
        registerAlgo('esoteric', 'ÊúÄÂ∑ÆÊéíÂ∫è (Worst Sort)', 'Unbounded', 'O(1)', 
            'ËØïÂõæËÆ©Êï∞ÁªÑÂèòÂæóÊõ¥Êó†Â∫èÁöÑÁÆóÊ≥ï„ÄÇ',
            async (viz) => {
                // Just bubble sort
                let n = viz.array.length;
                for(let i=0; i<n; i++) {
                    for(let j=0; j<n-1; j++) {
                        if(await viz.compare(j, j+1)) await viz.swap(j, j+1);
                    }
                }
            }
        );

        // 11. Slow Sort (Iterative)
        registerAlgo('esoteric', 'ÊÖ¢ÈÄüÊéíÂ∫è (Ëø≠‰ª£) (Slow Sort Iterative)', 'O(N^(log N))', 'O(N)', 
            'Ëø≠‰ª£ÂÆûÁé∞ÁöÑÊÖ¢ÈÄüÊéíÂ∫è„ÄÇ',
            async (viz) => {
                // Similar to Stooge, purely educational
                async function slow(i, j) {
                    if (i >= j) return;
                    let m = Math.floor((i + j) / 2);
                    await slow(i, m);
                    await slow(m + 1, j);
                    if (await viz.compare(m, j)) await viz.swap(m, j); // Max at j
                    await slow(i, j - 1);
                }
                await slow(0, viz.array.length - 1);
            }
        );

        // 12. Double Selection Sort (Iterative)
        registerAlgo('selection', 'ÂèåÂêëÈÄâÊã©ÊéíÂ∫è (Ëø≠‰ª£) (Double Selection Iterative)', 'O(N^2)', 'O(1)', 
            'ÊØèÊ¨°ÂêåÊó∂ÈÄâÊã©ÊúÄÂ§ßÂíåÊúÄÂ∞èÂÄº„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                for (let i = 0; i < n / 2; i++) {
                    let min = i;
                    let max = i;
                    for (let j = i + 1; j < n - i; j++) {
                        if (await viz.compare(min, j)) min = j; // arr[min] > arr[j]
                        if (await viz.compare(j, max)) max = j; // arr[j] > arr[max]
                    }
                    await viz.swap(i, min);
                    if (max === i) max = min;
                    await viz.swap(n - 1 - i, max);
                }
            }
        );

        // 13. Guarded Insertion Sort
        registerAlgo('insertion', 'Âì®ÂÖµÊèíÂÖ•ÊéíÂ∫è (Guarded Insertion Sort)', 'O(N^2)', 'O(1)', 
            'ÂÖàÂ∞ÜÊúÄÂ∞èÂÄºÁßªÂà∞È¶ñ‰Ωç‰Ωú‰∏∫Âì®ÂÖµÔºåÂáèÂ∞ëËæπÁïåÊ£ÄÊü•„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                let min = 0;
                for(let i=1; i<n; i++) {
                    if(await viz.compare(min, i)) min = i;
                }
                await viz.swap(0, min);
                
                for(let i=2; i<n; i++) {
                    let j = i;
                    while(await viz.compare(j-1, j)) {
                        await viz.swap(j-1, j);
                        j--;
                    }
                }
            }
        );

        // 14. Quick Sort (Stable)
        registerAlgo('exchange', 'Á®≥ÂÆöÂø´ÈÄüÊéíÂ∫è (Stable Quick Sort)', 'O(N log N)', 'O(N)', 
            '‰ΩøÁî®ËæÖÂä©Á©∫Èó¥ÁöÑÁ®≥ÂÆöÂø´ÈÄüÊéíÂ∫è„ÄÇ',
            async (viz) => {
                async function stableQ(l, r) {
                    if(l >= r) return;
                    let pivot = viz.array[Math.floor((l+r)/2)];
                    let left = [], mid = [], right = [];
                    for(let i=l; i<=r; i++) {
                        viz.state[i] = 1; await viz.sleep(); viz.state[i] = 0;
                        if(viz.array[i] < pivot) left.push(viz.array[i]);
                        else if(viz.array[i] === pivot) mid.push(viz.array[i]);
                        else right.push(viz.array[i]);
                    }
                    // Write back
                    let k = l;
                    for(let v of left) await viz.write(k++, v);
                    for(let v of mid) await viz.write(k++, v);
                    for(let v of right) await viz.write(k++, v);
                    
                    await stableQ(l, l + left.length - 1);
                    await stableQ(l + left.length + mid.length, r);
                }
                await stableQ(0, viz.array.length - 1);
            }
        );

        // 15. Quick Sort (Middle Pivot)
        registerAlgo('exchange', 'Âø´ÈÄüÊéíÂ∫è (Middle Pivot)', 'O(N log N)', 'O(log N)', 
            'ÂßãÁªàÈÄâÊã©‰∏≠Èó¥ÂÖÉÁ¥†‰Ωú‰∏∫Âü∫ÂáÜ„ÄÇ',
            async (viz) => {
                async function q(l, r) {
                    if(l >= r) return;
                    let pivotIdx = Math.floor((l+r)/2);
                    await viz.swap(pivotIdx, r);
                    let pivot = viz.array[r];
                    let i = l - 1;
                    for(let j=l; j<r; j++) {
                        if(viz.array[j] < pivot) {
                            i++;
                            await viz.swap(i, j);
                        }
                    }
                    await viz.swap(i+1, r);
                    await q(l, i);
                    await q(i+2, r);
                }
                await q(0, viz.array.length - 1);
            }
        );

        // 16. Merge Sort (Natural)
        registerAlgo('merge', 'Ëá™ÁÑ∂ÂΩíÂπ∂ÊéíÂ∫è (Natural Merge Sort)', 'O(N log N)', 'O(N)', 
            'Âà©Áî®Êï∞ÁªÑ‰∏≠Â∑≤ÊúâÁöÑÊúâÂ∫èÁâáÊÆµËøõË°åÂΩíÂπ∂„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                let sorted = false;
                while(!sorted) {
                    sorted = true;
                    let i = 0;
                    while(i < n) {
                        let l = i;
                        while(i < n - 1 && !await viz.compare(i, i+1)) i++; // Find run
                        let m = i;
                        i++;
                        if(i >= n) break;
                        while(i < n - 1 && !await viz.compare(i, i+1)) i++; // Find next run
                        let r = i;
                        i++;
                        
                        // Merge l...m and m+1...r
                        sorted = false;
                        // Simple merge logic
                        let L = viz.array.slice(l, m+1);
                        let R = viz.array.slice(m+1, r+1);
                        let k = l, p1=0, p2=0;
                        while(p1 < L.length && p2 < R.length) {
                            if(L[p1] <= R[p2]) await viz.write(k++, L[p1++]);
                            else await viz.write(k++, R[p2++]);
                        }
                        while(p1 < L.length) await viz.write(k++, L[p1++]);
                        while(p2 < R.length) await viz.write(k++, R[p2++]);
                    }
                }
            }
        );

        // 17. Merge Sort (In-Place Optimized)
        registerAlgo('merge', 'ÂΩíÂπ∂ÊéíÂ∫è (ÂéüÂú∞‰ºòÂåñ) (Merge Sort In-Place Opt)', 'O(N log^2 N)', 'O(1)', 
            '‰ºòÂåñÁöÑÂéüÂú∞ÂΩíÂπ∂ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                async function merge(l, m, r) {
                    let i = l;
                    let j = m + 1;
                    if (viz.array[m] <= viz.array[j]) return;
                    while (i <= m && j <= r) {
                        if (viz.array[i] <= viz.array[j]) {
                            i++;
                        } else {
                            let val = viz.array[j];
                            let index = j;
                            while (index !== i) {
                                await viz.write(index, viz.array[index - 1]);
                                index--;
                            }
                            await viz.write(i, val);
                            i++;
                            m++;
                            j++;
                        }
                    }
                }
                async function sort(l, r) {
                    if (l < r) {
                        let m = Math.floor((l + r) / 2);
                        await sort(l, m);
                        await sort(m + 1, r);
                        await merge(l, m, r);
                    }
                }
                await sort(0, viz.array.length - 1);
            }
        );

        // 18. Exchange Sort (Optimized)
        registerAlgo('exchange', '‰∫§Êç¢ÊéíÂ∫è (‰ºòÂåñ) (Exchange Sort Optimized)', 'O(N^2)', 'O(1)', 
            'ÂáèÂ∞ëÊó†Áî®‰∫§Êç¢ÁöÑ‰∫§Êç¢ÊéíÂ∫è„ÄÇ',
            async (viz) => {
                let n = viz.array.length;
                for(let i=0; i<n-1; i++) {
                    let min = i;
                    for(let j=i+1; j<n; j++) {
                        if(await viz.compare(min, j)) min = j;
                    }
                    if(min !== i) await viz.swap(i, min);
                }
            }
        );

        const visualizer = new Visualizer(document.getElementById('canvas'));
        const algoListEl = document.getElementById('algoList');
        let currentAlgo = null;

        function initUI() {
            try {
                // Debug info
                console.log('Initializing UI...');
                const totalAlgos = Object.values(algorithms).reduce((sum, arr) => sum + arr.length, 0);
                if (totalAlgos === 0) {
                    const err = document.createElement('div');
                    err.style.color = '#e74c3c';
                    err.style.padding = '1rem';
                    err.innerHTML = '<strong>ÈîôËØØÔºö</strong> Ê≤°ÊúâÊ≥®ÂÜå‰ªª‰ΩïÁÆóÊ≥ï„ÄÇ<br>ËØ∑Ê£ÄÊü•ËÑöÊú¨Âä†ËΩΩÊòØÂê¶ÂÆåÊï¥„ÄÇ';
                    algoListEl.appendChild(err);
                    return;
                }

                visualizer.generateArray(50);

                // Add count display
                let countDisplay = document.getElementById('algoCountDisplay');
                if (!countDisplay) {
                    countDisplay = document.createElement('div');
                    countDisplay.id = 'algoCountDisplay';
                    countDisplay.style.padding = '0.5rem 1rem';
                    countDisplay.style.fontSize = '0.85rem';
                    countDisplay.style.color = '#b0a0c0';
                    countDisplay.style.borderBottom = '1px solid var(--bg-tertiary)';
                    // Insert after category tabs
                    const sidebarTop = document.querySelector('.sidebar-top');
                    sidebarTop.appendChild(countDisplay);
                }

                // Ê∑ªÂä†ÂàÜÁ±ªÊ†áÁ≠æ (Add category tabs)
                const tabsContainer = document.getElementById('categoryTabs');
                tabsContainer.innerHTML = '';
                
                const allTab = document.createElement('button');
                allTab.className = 'tab-btn active';
                allTab.innerText = 'ÂÖ®ÈÉ®';
                allTab.onclick = () => filterCategory('all', allTab);
                tabsContainer.appendChild(allTab);

                const cats = [
                    {key: 'exchange', name: '‰∫§Êç¢'},
                    {key: 'selection', name: 'ÈÄâÊã©'},
                    {key: 'insertion', name: 'ÊèíÂÖ•'},
                    {key: 'merge', name: 'ÂΩíÂπ∂'},
                    {key: 'distribution', name: 'ÂàÜÂ∏É'},
                    {key: 'hybrid', name: 'Ê∑∑Âêà'},
                    {key: 'heap', name: 'Â†Ü'},
                    {key: 'esoteric', name: 'Ë∂£Âë≥'},
                    {key: 'other', name: 'ÂÖ∂‰ªñ'}
                ];

                cats.forEach(c => {
                    if (algorithms[c.key] && algorithms[c.key].length > 0) {
                        const btn = document.createElement('button');
                        btn.className = 'tab-btn';
                        btn.innerText = c.name;
                        btn.onclick = () => filterCategory(c.key, btn);
                        tabsContainer.appendChild(btn);
                    }
                });

                renderAlgoList('all');

                // Select first algo by default
                let firstBtn = algoListEl.querySelector('.algo-btn');
                if (firstBtn) {
                    firstBtn.click();
                }
            } catch (e) {
                console.error(e);
                const errDiv = document.createElement('div');
                errDiv.style.color = 'red';
                errDiv.style.padding = '1rem';
                errDiv.innerText = 'ÂàùÂßãÂåñÂºÇÂ∏∏: ' + e.message + '\n' + e.stack;
                algoListEl.appendChild(errDiv);
            }
        }

        function filterCategory(cat, btn) {
            // Update active tab
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            renderAlgoList(cat);
        }

        function renderAlgoList(filterCat) {
            algoListEl.innerHTML = '';
            let count = 0;
            
            const catNames = {
                exchange: '‰∫§Êç¢ÊéíÂ∫è', selection: 'ÈÄâÊã©ÊéíÂ∫è', insertion: 'ÊèíÂÖ•ÊéíÂ∫è',
                merge: 'ÂΩíÂπ∂ÊéíÂ∫è', distribution: 'ÂàÜÂ∏ÉÊéíÂ∫è', esoteric: 'Ë∂£Âë≥/ÂÖ∂‰ªñ', hybrid: 'Ê∑∑ÂêàÊéíÂ∫è', other: 'ÂÖ∂‰ªñ'
            };

            for (const [category, algos] of Object.entries(algorithms)) {
                if (algos.length === 0) continue;
                if (filterCat !== 'all' && filterCat !== category) continue;

                const catHeader = document.createElement('div');
                catHeader.className = 'category-header';
                catHeader.innerText = catNames[category] || category;
                algoListEl.appendChild(catHeader);

                algos.forEach(algo => {
                    count++;
                    const btn = document.createElement('button');
                    btn.className = 'algo-btn';
                    const name = algo.name || 'Unnamed Algo';
                    // Show full name (Chinese + English)
                    btn.innerText = name; 
                    btn.onclick = () => selectAlgo(algo, btn);
                    if (currentAlgo === algo) btn.classList.add('active');
                    algoListEl.appendChild(btn);
                });
            }
            
            // Update count display
            const countDisplay = document.getElementById('algoCountDisplay');
            if(countDisplay) {
                countDisplay.innerText = `ÊòæÁ§∫ÁÆóÊ≥ï: ${count} / ÊÄªËÆ°: ${Object.values(algorithms).reduce((s, a) => s + a.length, 0)}`;
            }
        }

        function selectAlgo(algo, btn) {
            currentAlgo = algo;
            
            // Update UI
            document.querySelectorAll('.algo-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            
            document.getElementById('infoTitle').innerText = algo.name;
            document.getElementById('infoTime').innerText = algo.complexity;
            document.getElementById('infoSpace').innerText = algo.space;
            document.getElementById('infoDesc').innerText = algo.desc;
            
            // Reset viz
            visualizer.isRunning = false;
            visualizer.isPaused = false;
            visualizer.stopSignal = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('sizeRange').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('pauseBtn').innerText = '‚ùö‚ùö ÊöÇÂÅú';
            
            visualizer.generateArray(parseInt(document.getElementById('sizeRange').value));
        }

        // Event Listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            if (currentAlgo && !visualizer.isRunning) {
                visualizer.run(currentAlgo.func);
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
             visualizer.stop();
             visualizer.resume(); // Ensure not stuck in pause
             setTimeout(() => {
                 visualizer.generateArray(parseInt(document.getElementById('sizeRange').value));
                 visualizer.isPaused = false;
                 document.getElementById('pauseBtn').disabled = true;
                 document.getElementById('pauseBtn').innerText = '‚ùö‚ùö ÊöÇÂÅú';
             }, 100);
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            const btn = document.getElementById('pauseBtn');
            if (visualizer.isPaused) {
                visualizer.resume();
                btn.innerText = '‚ùö‚ùö ÊöÇÂÅú';
                btn.classList.remove('paused');
            } else {
                visualizer.pause();
                btn.innerText = '‚ñ∂ ÁªßÁª≠';
                btn.classList.add('paused');
            }
        });

        document.getElementById('sizeRange').addEventListener('input', (e) => {
            if (!visualizer.isRunning) {
                visualizer.generateArray(parseInt(e.target.value));
            }
        });

        document.getElementById('speedRange').addEventListener('input', (e) => {
            // Speed 1-100 -> Delay 200-0 (approx)
            // Logarithmic feel
            const val = parseInt(e.target.value);
            // 1 -> 500ms, 100 -> 1ms
            visualizer.delay = Math.floor(500 * Math.pow(0.95, val)); 
            if(val === 100) visualizer.delay = 0;
        });

        document.getElementById('searchAlgo').addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            const btns = algoListEl.querySelectorAll('.algo-btn');
            btns.forEach(btn => {
                if (btn.innerText.toLowerCase().includes(term)) {
                    btn.style.display = 'block';
                } else {
                    btn.style.display = 'none';
                }
            });
            // Also hide headers if no children visible
             const headers = algoListEl.querySelectorAll('.category-header');
             headers.forEach(header => {
                 // Simple logic: hide header? Complex to track next siblings. 
                 // Re-render might be better but simple hide is okay.
                 // Let's rely on category tabs for main filtering.
             });
        });

        // Initialize
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initUI);
        } else {
            initUI();
        }
    </script>
</body>
</html>
