<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç»ˆæå›¾ç‰‡åŠ å¯†å·¥å…·ç®± (Ultimate Image Crypto)</title>
    <style>
        :root {
            --bg-dark: #0f0a15;
            --bg-panel: #1a1625;
            --primary: #a855f7;
            --primary-hover: #9333ea;
            --text-main: #e9d5ff;
            --text-muted: #a78bfa;
            --border: #2e2a3e;
            --success: #10b981;
            --sidebar-width: 260px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-dark);
            color: var(--text-main);
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            width: var(--sidebar-width);
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 20px;
            flex-shrink: 0;
        }

        .logo {
            font-size: 1.2rem;
            font-weight: 800;
            color: var(--primary);
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            gap: 10px;
            text-shadow: 0 0 10px rgba(168, 85, 247, 0.3);
        }

        .nav-btn {
            background: transparent;
            border: none;
            color: var(--text-muted);
            padding: 12px 16px;
            text-align: left;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.95rem;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .nav-btn:hover {
            background: rgba(168, 85, 247, 0.1);
            color: var(--text-main);
        }

        .nav-btn.active {
            background: var(--primary);
            color: white;
            box-shadow: 0 4px 12px rgba(168, 85, 247, 0.4);
        }

        /* Main Content */
        .main-content {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            position: relative;
        }

        .tool-section {
            display: none;
            max-width: 1000px;
            margin: 0 auto;
            animation: fadeIn 0.3s ease;
        }

        .tool-section.active { display: block; }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h1 { margin-bottom: 10px; font-size: 2rem; }
        p.subtitle { color: var(--text-muted); margin-bottom: 30px; }

        /* Cards & Containers */
        .card {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 24px;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        /* Controls */
        .control-group { margin-bottom: 20px; }
        .control-group label { display: block; margin-bottom: 8px; color: var(--text-muted); font-size: 0.9rem; }
        
        input[type="text"], input[type="number"], select {
            width: 100%;
            padding: 10px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: white;
            font-family: inherit;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: var(--bg-dark);
            border-radius: 3px;
            appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
        }

        .btn {
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { background: var(--primary-hover); }
        .btn-success { background: var(--success); color: white; text-decoration: none; }
        .btn-outline { background: transparent; border: 1px solid var(--border); color: var(--text-muted); }
        .btn-outline:hover { border-color: var(--text-main); color: var(--text-main); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .file-upload {
            border: 2px dashed var(--border);
            padding: 30px;
            text-align: center;
            border-radius: 12px;
            cursor: pointer;
            transition: 0.2s;
        }
        .file-upload:hover { border-color: var(--primary); background: rgba(99, 102, 241, 0.05); }

        /* Preview Area */
        .preview-container {
            margin-top: 20px;
            text-align: center;
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 12px;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .preview-img {
            max-width: 100%;
            max-height: 400px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            display: none;
            margin: 0 auto 15px;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 10px;
        }
        .tab {
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            color: var(--text-muted);
            font-weight: 600;
        }
        .tab.active {
            background: var(--bg-dark);
            color: var(--primary);
        }

        canvas { display: none; }
    </style>
</head>
<body>

<!-- Sidebar -->
<div class="sidebar">
    <div class="logo">
        <span>ğŸ›¡ï¸</span> å›¾ç‰‡åŠ å¯†å·¥å…·ç®±
    </div>
    <button class="nav-btn active" onclick="showTool('gilbert')">
        <span>ğŸ…</span> å‰å°”ä¼¯ç‰¹æ··æ·†
    </button>
    <button class="nav-btn" onclick="showTool('visual')">
        <span>ğŸ”</span> è§†è§‰åŠ å¯† & éšå†™
    </button>
</div>

<!-- Main Content -->
<div class="main-content">

    <!-- Gilbert Tool -->
    <div id="tool-gilbert" class="tool-section active">
        <h1>å‰å°”ä¼¯ç‰¹åƒç´ æ··æ·† (Gilbert Shuffle)</h1>
        <p class="subtitle">åŸºäº <strong>Chaos Theory (æ··æ²Œç†è®º)</strong> ä¸ <strong>Space-Filling Curves (ç©ºé—´å¡«å……æ›²çº¿)</strong> çš„æ— æŸåƒç´ ç½®ä¹±ç®—æ³•ã€‚</p>
        
        <div class="card">
            <div class="control-group">
                <label>åŠ å¯†å¯†é’¥ (Seed Key)</label>
                <input type="number" id="gb-key" value="123456" placeholder="è¯·è¾“å…¥æ•°å­—å¯†é’¥ (Enter numeric seed)...">
            </div>
            
            <div class="grid-2">
                <button class="btn btn-primary" id="gb-btn-enc">ğŸ”’ åŠ å¯†å›¾ç‰‡ (Encrypt)</button>
                <button class="btn btn-outline" id="gb-btn-dec">ğŸ”“ è§£å¯†å›¾ç‰‡ (Decrypt)</button>
            </div>
        </div>

        <div class="card">
            <input type="file" id="gb-input" accept="image/*" style="display: none;">
            <div class="file-upload" onclick="document.getElementById('gb-input').click()">
                <p>ç‚¹å‡»ä¸Šä¼ å›¾ç‰‡ æˆ– æ‹–æ‹½è‡³æ­¤ (Upload Image)</p>
            </div>
            
            <div class="preview-container">
                <img id="gb-img-preview" class="preview-img">
                <a id="gb-download" class="btn btn-success" style="display: none;">ğŸ’¾ ä¿å­˜å›¾ç‰‡ (Save Image)</a>
            </div>
        </div>
    </div>

    <!-- Visual Encryption Tool -->
    <div id="tool-visual" class="tool-section">
        <h1>è§†è§‰åŠ å¯† & æ¨¡ç³Šéšå†™ (Visual Crypto & Stego)</h1>
        <p class="subtitle">åŸºäº <strong>Visual Secret Sharing (è§†è§‰ç§˜å¯†å…±äº«)</strong> æ–¹æ¡ˆä¸ <strong>LSB (æœ€ä½æœ‰æ•ˆä½)</strong> éšå†™æœ¯ã€‚</p>

        <div class="tabs">
            <div class="tab active" onclick="switchVisualTab('enc')">åŠ å¯† (Encryption / Split)</div>
            <div class="tab" onclick="switchVisualTab('dec')">è§£å¯† (Decryption / Merge)</div>
        </div>

        <!-- Encrypt Tab -->
        <div id="visual-enc" class="visual-tab-content">
            <div class="card grid-2">
                <div>
                    <div class="control-group">
                        <label>æ ¸å¿ƒç®—æ³• (Core Algorithm)</label>
                        <select id="vs-algo">
                            <option value="arithmetic">æ ‡å‡†è§†è§‰åŠ å¯† (Arithmetic Secret Sharing)</option>
                            <option value="lsb">LSB éšå†™æœ¯ (LSB Steganography)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>è§†è§‰å±‚æ ·å¼ (Mask Style)</label>
                        <select id="vs-style">
                            <option value="mosaic">é©¬èµ›å…‹ (Mosaic / Pixelation)</option>
                            <option value="blur">é«˜æ–¯æ¨¡ç³Š (Gaussian Blur)</option>
                            <option value="dot">åŠè°ƒç‚¹é˜µ (Halftone Dot)</option>
                            <option value="stripe">çº¿æ€§æ¡çº¹ (Linear Stripe)</option>
                            <option value="cross">ç½‘æ ¼çº¹ç† (Crosshatching)</option>
                            <option value="edge">è¾¹ç¼˜æ£€æµ‹ (Sobel Edge Detection)</option>
                            <option value="invert">åè‰² (Negative Inversion)</option>
                        </select>
                    </div>
                </div>
                <div>
                    <div class="control-group">
                        <label>æ ·å¼å¼ºåº¦ (Kernel Size / Radius): <span id="vs-val-1">10</span></label>
                        <input type="range" id="vs-param-1" min="1" max="50" value="10">
                    </div>
                    <div class="control-group">
                        <label>åŠ å¯†/å™ªç‚¹å¼ºåº¦ (Noise Intensity): <span id="vs-val-2">30</span></label>
                        <input type="range" id="vs-param-2" min="0" max="100" value="30">
                    </div>
                </div>
            </div>

            <div class="card">
                <input type="file" id="vs-input-a" accept="image/*" style="display: none;">
                <button class="btn btn-primary" style="width: 100%; margin-bottom: 20px;" onclick="document.getElementById('vs-input-a').click()">
                    ğŸ“¸ ä¸Šä¼ åŸå›¾ A (Source Image)
                </button>

                <div class="grid-2">
                    <div class="preview-container">
                        <h3>è§†è§‰å±‚ B (Visual Share / Public Mask)</h3>
                        <img id="vs-img-b" class="preview-img">
                        <a id="vs-dl-b" class="btn btn-success" style="display: none;">ä¸‹è½½ B å›¾ (Download Share B)</a>
                    </div>
                    <div class="preview-container">
                        <h3>å¯†é’¥å±‚ C (Key Share / Private Key)</h3>
                        <img id="vs-img-c" class="preview-img">
                        <a id="vs-dl-c" class="btn btn-success" style="display: none;">ä¸‹è½½ C å›¾ (Download Share C)</a>
                    </div>
                </div>
            </div>
        </div>

        <!-- Decrypt Tab -->
        <div id="visual-dec" class="visual-tab-content" style="display: none;">
            <div class="card">
                <div class="control-group">
                    <label>è§£å¯†ç®—æ³• (Decryption Algorithm)</label>
                    <select id="vs-algo-dec">
                        <option value="arithmetic">æ ‡å‡†è§†è§‰åŠ å¯† (Arithmetic Secret Sharing)</option>
                        <option value="lsb">LSB éšå†™æœ¯ (LSB Steganography)</option>
                    </select>
                </div>
                
                <div class="grid-2">
                    <div class="file-upload" onclick="document.getElementById('vs-input-b').click()">
                        <p>1. ä¸Šä¼ è§†è§‰å›¾ B (Upload Share B)</p>
                        <input type="file" id="vs-input-b" accept="image/*" style="display: none;">
                    </div>
                    <div class="file-upload" onclick="document.getElementById('vs-input-c').click()">
                        <p>2. ä¸Šä¼ å¯†é’¥å›¾ C (Upload Share C)</p>
                        <input type="file" id="vs-input-c" accept="image/*" style="display: none;">
                    </div>
                </div>
                
                <div style="text-align: center; margin: 20px 0;">
                    <button id="vs-btn-dec" class="btn btn-primary" disabled>ğŸ”„ å¼€å§‹åˆå¹¶è§£å¯† (Merge & Decrypt)</button>
                    <p id="vs-err" style="color: #ef4444; margin-top: 10px; display: none;">âŒ å›¾ç‰‡å°ºå¯¸ä¸ä¸€è‡´ (Image Dimensions Mismatch)</p>
                </div>

                <div class="preview-container">
                    <h3>è¿˜åŸç»“æœ A (Restored Result)</h3>
                    <img id="vs-img-result" class="preview-img">
                    <a id="vs-dl-result" class="btn btn-success" style="display: none;">ä¸‹è½½è¿˜åŸå›¾ (Download Result)</a>
                </div>
            </div>
        </div>
    </div>

</div>

<!-- Shared Canvas -->
<canvas id="main-cvs"></canvas>

<script>
// --- Navigation ---
function showTool(id) {
    document.querySelectorAll('.tool-section').forEach(el => el.classList.remove('active'));
    document.querySelectorAll('.nav-btn').forEach(el => el.classList.remove('active'));
    document.getElementById('tool-' + id).classList.add('active');
    event.currentTarget.classList.add('active');
}

function switchVisualTab(mode) {
    document.querySelectorAll('.visual-tab-content').forEach(el => el.style.display = 'none');
    document.querySelectorAll('.tab').forEach(el => el.classList.remove('active'));
    document.getElementById('visual-' + mode).style.display = 'block';
    event.currentTarget.classList.add('active');
}

// --- Utils ---
const cvs = document.getElementById('main-cvs');
const ctx = cvs.getContext('2d', { willReadFrequently: true });

function loadImage(file) {
    return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    });
}

function download(linkId, dataUrl, filename) {
    const a = document.getElementById(linkId);
    a.href = dataUrl;
    a.download = filename;
    a.style.display = 'inline-flex';
}

// ==========================================
// TOOL 1: Gilbert Shuffle
// ==========================================
(function(){
    const imgPreview = document.getElementById("gb-img-preview");
    const keyInput = document.getElementById("gb-key");
    const dlBtn = document.getElementById("gb-download");
    const fileInput = document.getElementById("gb-input");

    function gilbert2d(width, height) {
        const coordinates = [];
        if (width >= height) generate2d(0, 0, width, 0, 0, height, coordinates);
        else generate2d(0, 0, 0, height, width, 0, coordinates);
        return coordinates;
    }

    function generate2d(x, y, ax, ay, bx, by, coordinates) {
        const w = Math.abs(ax + ay), h = Math.abs(bx + by);
        const dax = Math.sign(ax), day = Math.sign(ay);
        const dbx = Math.sign(bx), dby = Math.sign(by);
        if (h === 1) {
            for (let i = 0; i < w; i++) { coordinates.push([x, y]); x += dax; y += day; }
            return;
        }
        if (w === 1) {
            for (let i = 0; i < h; i++) { coordinates.push([x, y]); x += dbx; y += dby; }
            return;
        }
        let ax2 = Math.floor(ax / 2), ay2 = Math.floor(ay / 2);
        let bx2 = Math.floor(bx / 2), by2 = Math.floor(by / 2);
        const w2 = Math.abs(ax2 + ay2), h2 = Math.abs(bx2 + by2);
        if (2 * w > 3 * h) {
            if ((w2 % 2) && (w > 2)) { ax2 += dax; ay2 += day; }
            generate2d(x, y, ax2, ay2, bx, by, coordinates);
            generate2d(x + ax2, y + ay2, ax - ax2, ay - ay2, bx, by, coordinates);
        } else {
            if ((h2 % 2) && (h > 2)) { bx2 += dbx; by2 += dby; }
            generate2d(x, y, bx2, by2, ax2, ay2, coordinates);
            generate2d(x + bx2, y + by2, ax, ay, bx - bx2, by - by2, coordinates);
            generate2d(x + (ax - dax) + (bx2 - dbx), y + (ay - day) + (by2 - dby), -bx2, -by2, -(ax - ax2), -(ay - ay2), coordinates);
        }
    }

    async function process(isEncrypt) {
        if (!fileInput.files[0]) return alert("è¯·å…ˆä¸Šä¼ å›¾ç‰‡");
        const img = await loadImage(fileInput.files[0]);
        
        cvs.width = img.width; cvs.height = img.height;
        ctx.drawImage(img, 0, 0);
        const srcData = ctx.getImageData(0, 0, cvs.width, cvs.height);
        const destData = ctx.createImageData(cvs.width, cvs.height);
        
        const curve = gilbert2d(cvs.width, cvs.height);
        const key = parseInt(keyInput.value) || 0;
        const total = cvs.width * cvs.height;
        const offset = Math.round(((Math.sqrt(5) - 1) / 2 * total) + key) % total;

        for(let i=0; i<total; i++) {
            const p1 = curve[i];
            const p2 = curve[(i + offset) % total];
            const idx1 = (p1[1] * cvs.width + p1[0]) * 4;
            const idx2 = (p2[1] * cvs.width + p2[0]) * 4;
            
            if(isEncrypt) {
                destData.data.set(srcData.data.slice(idx1, idx1+4), idx2);
            } else {
                destData.data.set(srcData.data.slice(idx2, idx2+4), idx1);
            }
        }
        
        ctx.putImageData(destData, 0, 0);
        const res = cvs.toDataURL();
        imgPreview.src = res;
        imgPreview.style.display = 'block';
        download("gb-download", res, (isEncrypt?"gb_enc_":"gb_dec_") + Date.now() + ".png");
    }

    fileInput.onchange = async () => {
        const img = await loadImage(fileInput.files[0]);
        imgPreview.src = img.src;
        imgPreview.style.display = 'block';
        dlBtn.style.display = 'none';
    };
    
    document.getElementById("gb-btn-enc").onclick = () => process(true);
    document.getElementById("gb-btn-dec").onclick = () => process(false);
})();

// ==========================================
// TOOL 2: Unified Visual Crypto
// ==========================================
(function(){
    // UI Elements
    const p1 = document.getElementById('vs-param-1');
    const p2 = document.getElementById('vs-param-2');
    const v1 = document.getElementById('vs-val-1');
    const v2 = document.getElementById('vs-val-2');
    
    p1.oninput = () => v1.innerText = p1.value;
    p2.oninput = () => v2.innerText = p2.value;

    let sourceImg = null;
    let decB = null, decC = null;

    document.getElementById('vs-input-a').onchange = async (e) => {
        sourceImg = await loadImage(e.target.files[0]);
        runEncrypt();
    };

    ['vs-algo', 'vs-style', 'vs-param-1', 'vs-param-2'].forEach(id => {
        document.getElementById(id).onchange = runEncrypt;
    });

    async function runEncrypt() {
        if(!sourceImg) return;
        
        const algo = document.getElementById('vs-algo').value;
        const style = document.getElementById('vs-style').value;
        const size = parseInt(p1.value);
        const noise = parseInt(p2.value);

        cvs.width = sourceImg.width;
        cvs.height = sourceImg.height;
        ctx.drawImage(sourceImg, 0, 0);
        const origData = ctx.getImageData(0, 0, cvs.width, cvs.height);

        // 1. Generate Visual Share B
        const bData = generateVisualEffect(origData, style, size);
        ctx.putImageData(bData, 0, 0);
        const urlB = cvs.toDataURL();
        document.getElementById('vs-img-b').src = urlB;
        document.getElementById('vs-img-b').style.display = 'block';
        download('vs-dl-b', urlB, 'visual_B.png');

        // 2. Generate Key Share C
        const cData = generateKeyShare(algo, origData, bData, noise);
        ctx.putImageData(cData, 0, 0);
        const urlC = cvs.toDataURL();
        document.getElementById('vs-img-c').src = urlC;
        document.getElementById('vs-img-c').style.display = 'block';
        download('vs-dl-c', urlC, 'key_C.png');
    }

    function generateVisualEffect(src, style, param) {
        const w = src.width, h = src.height;
        const out = new ImageData(w, h);
        const d = src.data;
        const od = out.data;
        
        // Helper: Get pixel
        const getPx = (x, y) => {
            if(x<0||x>=w||y<0||y>=h) return [0,0,0,0];
            const i = (y*w+x)*4;
            return [d[i], d[i+1], d[i+2], d[i+3]];
        };

        if(style === 'blur') {
            // Fast Box Blur
            const r = Math.max(1, Math.floor(param/2));
            for(let y=0; y<h; y++) {
                for(let x=0; x<w; x++) {
                    let sr=0, sg=0, sb=0, cnt=0;
                    for(let dy=-r; dy<=r; dy+=2) { // step 2 for speed
                        for(let dx=-r; dx<=r; dx+=2) {
                            const px = getPx(x+dx, y+dy);
                            if(px[3]>0) { sr+=px[0]; sg+=px[1]; sb+=px[2]; cnt++; }
                        }
                    }
                    const i = (y*w+x)*4;
                    od[i] = cnt?sr/cnt:0; od[i+1] = cnt?sg/cnt:0; od[i+2] = cnt?sb/cnt:0; od[i+3] = 255;
                }
            }
        } else if(style === 'mosaic') {
            const bs = Math.max(2, param);
            for(let y=0; y<h; y+=bs) {
                for(let x=0; x<w; x+=bs) {
                    let sr=0, sg=0, sb=0, cnt=0;
                    for(let dy=0; dy<bs && y+dy<h; dy++) {
                        for(let dx=0; dx<bs && x+dx<w; dx++) {
                            const px = getPx(x+dx, y+dy);
                            sr+=px[0]; sg+=px[1]; sb+=px[2]; cnt++;
                        }
                    }
                    const r=sr/cnt, g=sg/cnt, b=sb/cnt;
                    for(let dy=0; dy<bs && y+dy<h; dy++) {
                        for(let dx=0; dx<bs && x+dx<w; dx++) {
                            const i = ((y+dy)*w+(x+dx))*4;
                            od[i]=r; od[i+1]=g; od[i+2]=b; od[i+3]=255;
                        }
                    }
                }
            }
        } else if(style === 'edge') {
             for(let y=0; y<h; y++) {
                for(let x=0; x<w; x++) {
                    const i = (y*w+x)*4;
                    const p = getPx(x,y);
                    const pr = getPx(x+1,y);
                    const pd = getPx(x,y+1);
                    const val = (Math.abs(p[0]-pr[0]) + Math.abs(p[0]-pd[0])) * (param/5);
                    od[i]=od[i+1]=od[i+2]=Math.min(255, val); od[i+3]=255;
                }
             }
        } else if(style === 'invert') {
             for(let i=0; i<d.length; i+=4) {
                 od[i]=255-d[i]; od[i+1]=255-d[i+1]; od[i+2]=255-d[i+2]; od[i+3]=255;
             }
        } else {
            // Pattern based (Dot, Stripe, Cross)
            const s = Math.max(2, param);
            for(let y=0; y<h; y++) {
                for(let x=0; x<w; x++) {
                    const i = (y*w+x)*4;
                    let keep = false;
                    if(style === 'stripe') keep = (y % s < s/2);
                    else if(style === 'cross') keep = (x % s < 1 || y % s < 1);
                    else if(style === 'dot') {
                         const cx = (x%s - s/2), cy = (y%s - s/2);
                         keep = (cx*cx + cy*cy < (s/3)*(s/3));
                    }
                    
                    if(keep) {
                        od[i]=d[i]; od[i+1]=d[i+1]; od[i+2]=d[i+2]; od[i+3]=255;
                    } else {
                        // Fill white or average
                        od[i]=240; od[i+1]=240; od[i+2]=240; od[i+3]=255;
                    }
                }
            }
        }
        return out;
    }

    function generateKeyShare(algo, A, B, noiseLevel) {
        const w = A.width, h = A.height;
        const C = new ImageData(w, h);
        
        for(let i=0; i<A.data.length; i+=4) {
            if(algo === 'arithmetic') {
                // Safefor Logic: C = (A - B + Noise) % 256
                // Added 512 to ensure positive before mod
                const n = Math.floor(Math.random() * noiseLevel * 2) - noiseLevel; 
                C.data[i]   = (A.data[i]   - B.data[i]   + n + 512) % 256;
                C.data[i+1] = (A.data[i+1] - B.data[i+1] + n + 512) % 256;
                C.data[i+2] = (A.data[i+2] - B.data[i+2] + n + 512) % 256;
                C.data[i+3] = 255;
            } else {
                // LSB Steganography Logic (Deepseek)
                // C is pure noise visually
                C.data[i]   = Math.floor(Math.random() * 256);
                C.data[i+1] = Math.floor(Math.random() * 256);
                C.data[i+2] = Math.floor(Math.random() * 256);
                
                // Calculate diff
                const dR = Math.floor((A.data[i] - B.data[i] + 255)/2);
                const dG = Math.floor((A.data[i+1] - B.data[i+1] + 255)/2);
                const dB = Math.floor((A.data[i+2] - B.data[i+2] + 255)/2);
                
                // Hide diff in last 2 bits of C
                C.data[i]   = (C.data[i] & 0xFC) | ((dR >> 6) & 0x03);
                C.data[i+1] = (C.data[i+1] & 0xFC) | ((dG >> 6) & 0x03);
                C.data[i+2] = (C.data[i+2] & 0xFC) | ((dB >> 6) & 0x03);
                
                // Store recovery info in Alpha
                // High 4 bits: Random key (omitted for simplicity here), Low 4 bits: Noise factor? 
                // Let's just store the rest of the Diff in Alpha for higher quality recovery
                // Or stick to the original Deepseek logic which was complex?
                // Simplified: Store high bits of Diff in Alpha to maximize quality
                // Alpha = R_high(2) | G_high(2) | B_high(2) | 11
                const rH = (dR >> 4) & 0x03;
                const gH = (dG >> 4) & 0x03;
                const bH = (dB >> 4) & 0x03;
                C.data[i+3] = (rH << 4) | (gH << 2) | bH | 192; // Ensure alpha > 192
            }
        }
        return C;
    }

    // Decryption Logic
    const inpB = document.getElementById('vs-input-b');
    const inpC = document.getElementById('vs-input-c');
    const btnDec = document.getElementById('vs-btn-dec');

    inpB.onchange = (e) => loadDecPart(e, 'B');
    inpC.onchange = (e) => loadDecPart(e, 'C');

    async function loadDecPart(e, type) {
        if(!e.target.files[0]) return;
        const img = await loadImage(e.target.files[0]);
        if(type === 'B') decB = img; else decC = img;
        checkDecReady();
    }

    function checkDecReady() {
        if(decB && decC) {
            if(decB.naturalWidth !== decC.naturalWidth || decB.naturalHeight !== decC.naturalHeight) {
                document.getElementById('vs-err').style.display = 'block';
                btnDec.disabled = true;
            } else {
                document.getElementById('vs-err').style.display = 'none';
                btnDec.disabled = false;
            }
        }
    }

    btnDec.onclick = () => {
        if (!decB || !decC) return;
        if (decB.naturalWidth !== decC.naturalWidth || decB.naturalHeight !== decC.naturalHeight) {
            alert("âŒ é”™è¯¯ï¼šä¸¤å¼ å›¾ç‰‡å°ºå¯¸ä¸ä¸€è‡´ï¼Œæ— æ³•è§£å¯†ï¼\nè¯·ç¡®ä¿ä¸Šä¼ äº†æ­£ç¡®çš„è§†è§‰å›¾(B)å’Œå¯†é’¥å›¾(C)ã€‚");
            return;
        }

        cvs.width = decB.naturalWidth; cvs.height = decB.naturalHeight;
        ctx.drawImage(decB, 0, 0);
        const bData = ctx.getImageData(0, 0, cvs.width, cvs.height);
        ctx.drawImage(decC, 0, 0);
        const cData = ctx.getImageData(0, 0, cvs.width, cvs.height);
        const aData = ctx.createImageData(cvs.width, cvs.height);
        
        const algo = document.getElementById('vs-algo-dec').value;
        const noise = parseInt(p2.value); // Use current slider for decryption noise reduction if needed

        for(let i=0; i<bData.data.length; i+=4) {
            if(algo === 'arithmetic') {
                // A = (B + C - Noise) % 256
                // Reconstruct deterministic noise
                const noiseBase = Math.floor(Math.abs(Math.sin(i) * 10000));
                const n = (noiseBase % (noise * 2 + 1)) - noise;

                aData.data[i]   = (bData.data[i]   + cData.data[i]   - n - 512 + 2560) % 256;
                aData.data[i+1] = (bData.data[i+1] + cData.data[i+1] - n - 512 + 2560) % 256;
                aData.data[i+2] = (bData.data[i+2] + cData.data[i+2] - n - 512 + 2560) % 256;
                aData.data[i+3] = 255;
            } else {
                // LSB Restore
                // Recover Diff
                // Low bits from RGB channels
                const dRl = (cData.data[i] & 0x03) << 6;
                const dGl = (cData.data[i+1] & 0x03) << 6;
                const dBl = (cData.data[i+2] & 0x03) << 6;
                
                // High bits from Alpha
                const alpha = cData.data[i+3];
                const dRh = ((alpha >> 4) & 0x03) << 4;
                const dGh = ((alpha >> 2) & 0x03) << 4;
                const dBh = (alpha & 0x03) << 4;

                // Reconstruct Diff (Approximate since we lost some precision)
                const diffR = (dRl | dRh) * 2 - 255;
                const diffG = (dGl | dGh) * 2 - 255;
                const diffB = (dBl | dBh) * 2 - 255;
                
                aData.data[i]   = Math.min(255, Math.max(0, bData.data[i] + diffR));
                aData.data[i+1] = Math.min(255, Math.max(0, bData.data[i+1] + diffG));
                aData.data[i+2] = Math.min(255, Math.max(0, bData.data[i+2] + diffB));
                aData.data[i+3] = 255;
            }
        }
        
        ctx.putImageData(aData, 0, 0);
        const res = cvs.toDataURL();
        const resImg = document.getElementById('vs-img-result');
        resImg.src = res;
        resImg.style.display = 'block';
        download('vs-dl-result', res, 'restored.png');
    };

})();
</script>
</body>
</html>
