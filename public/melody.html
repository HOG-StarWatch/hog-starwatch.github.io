<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ—‹å¾‹ç”Ÿæˆå™¨ (Melody)</title>
    <style>
        :root {
            --primary-color: #bb86fc;
            --secondary-color: #3700b3;
            --accent-color: #03dac6;
            --bg-gradient: linear-gradient(135deg, #120024 0%, #2a003f 100%);
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-blur: blur(12px);
            --text-color: #e0e0e0;
        }

        body {
            background: var(--bg-gradient);
            color: var(--text-color);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        .container {
            width: 100%;
            max-width: 900px;
            background: var(--glass-bg);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            display: flex;
            flex-direction: column;
        }

        h1, h2, h3 {
            color: var(--primary-color);
            text-shadow: 0 0 10px rgba(187, 134, 252, 0.3);
            margin-top: 0;
            text-align: center;
        }

        h1 { margin-bottom: 30px; letter-spacing: 2px; }
        h2 { font-size: 1.2rem; margin-bottom: 15px; text-align: left; border-bottom: 1px solid var(--glass-border); padding-bottom: 5px; }

        .control-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 30px; /* Adjusted margin */
            padding-top: 20px;
            border-top: 1px solid var(--glass-border);
        }

        .panel-section {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid var(--glass-border);
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
            color: #ccc;
        }

        input[type="number"], input[type="text"], select {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            color: #fff;
            box-sizing: border-box;
            transition: all 0.3s ease;
        }

        /* Fix for Dropdown visibility */
        select option {
            background-color: #1e1e1e;
            color: #fff;
        }

        input[type="number"]:focus, input[type="text"]:focus, select:focus {
            outline: none;
            border-color: var(--primary-color);
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 8px rgba(187, 134, 252, 0.2);
        }

        /* Range Slider Styling */
        input[type="range"] {
            -webkit-appearance: none;
			appearance: none;
            width: 100%;
            background: transparent;
            margin: 10px 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
        }

        .button-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px; /* Changed from top to bottom margin */
        }

        button {
            padding: 12px 20px;
            background: linear-gradient(45deg, var(--secondary-color), #6200ea);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(98, 0, 234, 0.4);
            background: linear-gradient(45deg, #6200ea, var(--primary-color));
        }

        button:active {
            transform: translateY(1px);
        }

        #melodyDisplay {
            margin-bottom: 20px; /* Spacing below display */
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            word-wrap: break-word;
            min-height: 50px;
            border: 1px solid var(--glass-border);
            font-size: 1.1rem;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            width: 100%;
            height: 150px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-bottom: 20px; /* Spacing below canvas */
            border: 1px solid var(--glass-border);
        }

        .adsr-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }
        
        .adsr-control {
            text-align: center;
        }

        .radio-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .radio-group label {
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        /* Toast notification */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--primary-color);
            color: black;
            padding: 10px 20px;
            border-radius: 20px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 1000;
            font-weight: bold;
        }
        .toast.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸµ éœ“è™¹æ—‹å¾‹ç”Ÿæˆå™¨ (Neon Melody)</h1>
        
        <!-- Result Display Area (Top) -->
        <div id="melodyDisplay">ç‚¹å‡»â€œç”Ÿæˆæ—‹å¾‹â€å¼€å§‹...</div>
        <canvas id="visualizer" width="800" height="150"></canvas>

        <!-- Action Buttons (Middle) -->
        <div class="button-grid">
            <button id="generate">ğŸ² ç”Ÿæˆæ—‹å¾‹</button>
            <button id="play">â–¶ æ’­æ”¾</button>
            <button id="stop">â¹ åœæ­¢</button>
            <button id="download">â¬‡ ä¸‹è½½WAV</button>
            <button id="save">ğŸ’¾ ä¿å­˜</button>
            <button id="load">ğŸ“‚ åŠ è½½</button>
        </div>

        <!-- Settings Panel (Bottom) -->
        <div class="control-panel">
            <!-- Global Settings -->
            <div class="panel-section">
                <h2>åŸºç¡€è®¾ç½®</h2>
                <div class="input-group">
                    <label for="bpm">BPM (é€Ÿåº¦): <span id="bpmVal">120</span></label>
                    <input type="range" id="bpm" min="40" max="240" value="120">
                </div>
                <div class="input-group">
                    <label for="volume">æ€»éŸ³é‡: <span id="volVal">50%</span></label>
                    <input type="range" id="volume" min="0" max="100" value="50">
                </div>
                <div class="input-group">
                    <label>æ³¢å½¢ (éŸ³è‰²):</label>
                    <div class="radio-group">
                        <label><input type="radio" name="tone" value="sine" checked> æ­£å¼¦</label>
                        <label><input type="radio" name="tone" value="triangle"> ä¸‰è§’</label>
                        <label><input type="radio" name="tone" value="square"> æ–¹æ³¢</label>
                        <label><input type="radio" name="tone" value="sawtooth"> é”¯é½¿</label>
                    </div>
                </div>
            </div>

            <!-- Melody Generation Logic -->
            <div class="panel-section">
                <h2>æ—‹å¾‹ç®—æ³•</h2>
                <div class="input-group">
                    <label for="scaleRoot">æ ¹éŸ³:</label>
                    <select id="scaleRoot">
                        <option value="C">C</option>
                        <option value="C#">C# / Db</option>
                        <option value="D">D</option>
                        <option value="D#">D# / Eb</option>
                        <option value="E">E</option>
                        <option value="F">F</option>
                        <option value="F#">F# / Gb</option>
                        <option value="G">G</option>
                        <option value="G#">G# / Ab</option>
                        <option value="A">A</option>
                        <option value="A#">A# / Bb</option>
                        <option value="B">B</option>
                    </select>
                </div>
                <div class="input-group">
                    <label for="scaleType">è°ƒå¼:</label>
                    <select id="scaleType">
                        <option value="major">å¤§è°ƒ (Major)</option>
                        <option value="minor">å°è°ƒ (Minor)</option>
                        <option value="pentatonicMajor">å¤§è°ƒäº”å£° (Pentatonic Major)</option>
                        <option value="pentatonicMinor">å°è°ƒäº”å£° (Pentatonic Minor)</option>
                        <option value="blues">è“è°ƒ (Blues)</option>
                        <option value="chromatic">åŠéŸ³é˜¶ (Chromatic)</option>
                    </select>
                </div>
                <div class="input-group">
                    <label for="noteCount">éŸ³ç¬¦æ•°é‡: <span id="countVal">16</span></label>
                    <input type="range" id="noteCount" min="4" max="64" value="16" step="4">
                </div>
                <div class="input-group">
                    <label for="octaveRange">è·¨è¶Šå…«åº¦: 2</label>
                    <input type="range" id="octaveRange" min="1" max="3" value="2">
                </div>
            </div>

            <!-- ADSR Envelope -->
            <div class="panel-section">
                <h2>ADSR åŒ…ç»œ (éŸ³æ•ˆè´¨æ„Ÿ)</h2>
                <div class="adsr-grid">
                    <div class="adsr-control">
                        <label>A</label>
                        <input type="range" id="attack" min="0" max="2" step="0.05" value="0.05" title="Attack (èµ·éŸ³)">
                    </div>
                    <div class="adsr-control">
                        <label>D</label>
                        <input type="range" id="decay" min="0" max="2" step="0.05" value="0.2" title="Decay (è¡°å‡)">
                    </div>
                    <div class="adsr-control">
                        <label>S</label>
                        <input type="range" id="sustain" min="0" max="1" step="0.1" value="0.5" title="Sustain (å»¶éŸ³)">
                    </div>
                    <div class="adsr-control">
                        <label>R</label>
                        <input type="range" id="release" min="0" max="3" step="0.1" value="0.5" title="Release (é‡ŠéŸ³)">
                    </div>
                </div>
                <div style="font-size: 0.8rem; color: #aaa; margin-top: 10px; text-align: center;">
                    èµ·éŸ³ - è¡°å‡ - å»¶éŸ³ç”µå¹³ - é‡ŠéŸ³
                </div>
            </div>

            <!-- Manual Input (Moved to Settings) -->
            <div class="panel-section">
                <h2>æ‰‹åŠ¨è¾“å…¥</h2>
                <div class="input-group">
                    <label for="manualInput">è‡ªå®šä¹‰æ—‹å¾‹ (é€—å·åˆ†éš”):</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="manualInput" placeholder="C4, E4, G4...">
                        <button id="setMelody" style="width: auto; padding: 10px 15px;">åº”ç”¨</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="toast" class="toast">æ¶ˆæ¯æç¤º</div>

    <script>
        // --- æ ¸å¿ƒæ•°æ®ä¸é…ç½® ---
        const NOTE_FREQUENCIES = {};
        const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        
        // åˆå§‹åŒ–é¢‘ç‡è¡¨ (C0 to B8)
        function initFrequencies() {
            const A4 = 440;
            for (let i = 0; i < 9; i++) {
                for (let j = 0; j < 12; j++) {
                    const noteName = NOTE_NAMES[j] + i;
                    // Formula: f = 440 * 2^((n-69)/12), where n is MIDI note number. A4 is 69.
                    // C0 is 12.
                    const midiNote = 12 + i * 12 + j;
                    const freq = A4 * Math.pow(2, (midiNote - 69) / 12);
                    NOTE_FREQUENCIES[noteName] = freq;
                }
            }
        }
        initFrequencies();

        // è°ƒå¼é—´éš” (åŠéŸ³æ•°)
        const SCALES = {
            major: [0, 2, 4, 5, 7, 9, 11],
            minor: [0, 2, 3, 5, 7, 8, 10],
            pentatonicMajor: [0, 2, 4, 7, 9],
            pentatonicMinor: [0, 3, 5, 7, 10],
            blues: [0, 3, 5, 6, 7, 10],
            chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
        };

        let currentMelody = [];
        let isPlaying = false;
        let audioCtx = null;
        let masterGain = null;
        let activeOscillators = [];
        let animationId = null;

        // --- UI äº¤äº’ç»‘å®š ---
        const elements = {
            bpm: document.getElementById('bpm'),
            bpmVal: document.getElementById('bpmVal'),
            volume: document.getElementById('volume'),
            volVal: document.getElementById('volVal'),
            noteCount: document.getElementById('noteCount'),
            countVal: document.getElementById('countVal'),
            scaleRoot: document.getElementById('scaleRoot'),
            scaleType: document.getElementById('scaleType'),
            octaveRange: document.getElementById('octaveRange'),
            melodyDisplay: document.getElementById('melodyDisplay'),
            canvas: document.getElementById('visualizer'),
            adsr: {
                a: document.getElementById('attack'),
                d: document.getElementById('decay'),
                s: document.getElementById('sustain'),
                r: document.getElementById('release')
            }
        };

        // æ›´æ–°æ˜¾ç¤ºæ•°å€¼
        elements.bpm.addEventListener('input', (e) => elements.bpmVal.innerText = e.target.value);
        elements.volume.addEventListener('input', (e) => {
            elements.volVal.innerText = e.target.value + '%';
            if(masterGain) masterGain.gain.setTargetAtTime(e.target.value / 100, audioCtx.currentTime, 0.1);
        });
        elements.noteCount.addEventListener('input', (e) => elements.countVal.innerText = e.target.value);

        // --- æ ¸å¿ƒé€»è¾‘ ---

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioCtx.createGain();
                masterGain.connect(audioCtx.destination);
                masterGain.gain.value = elements.volume.value / 100;
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        // è·å–å¯ç”¨éŸ³ç¬¦æ± 
        function getScaleNotes(root, scaleType, octaves) {
            const rootIndex = NOTE_NAMES.indexOf(root);
            const intervals = SCALES[scaleType];
            let pool = [];

            // åŸºç¡€å…«åº¦ä»3å¼€å§‹ (C3 - B5 èŒƒå›´æ¯”è¾ƒå¥½å¬)
            const startOctave = 3;
            
            for (let o = 0; o < octaves; o++) {
                const currentOctave = startOctave + o;
                intervals.forEach(interval => {
                    const noteIndex = (rootIndex + interval) % 12;
                    const octaveShift = Math.floor((rootIndex + interval) / 12);
                    const finalOctave = currentOctave + octaveShift;
                    const noteName = NOTE_NAMES[noteIndex] + finalOctave;
                    if (NOTE_FREQUENCIES[noteName]) {
                        pool.push(noteName);
                    }
                });
            }
            return pool;
        }

        // ç”Ÿæˆæ—‹å¾‹
        document.getElementById('generate').addEventListener('click', () => {
            const count = parseInt(elements.noteCount.value);
            const root = elements.scaleRoot.value;
            const type = elements.scaleType.value;
            const octaves = parseInt(elements.octaveRange.value);
            
            const pool = getScaleNotes(root, type, octaves);
            currentMelody = [];
            
            // ç®€å•çš„éšæœºæ¸¸èµ°ç®—æ³•ï¼Œè®©æ—‹å¾‹æ›´è¿è´¯
            let lastIndex = Math.floor(Math.random() * pool.length);
            
            for (let i = 0; i < count; i++) {
                // 70% æ¦‚ç‡åœ¨é™„è¿‘ç§»åŠ¨ï¼Œ30% æ¦‚ç‡å¤§è·³
                if (Math.random() > 0.3) {
                    const step = Math.floor(Math.random() * 5) - 2; // -2 to 2
                    lastIndex = Math.max(0, Math.min(pool.length - 1, lastIndex + step));
                } else {
                    lastIndex = Math.floor(Math.random() * pool.length);
                }
                currentMelody.push(pool[lastIndex]);
            }
            
            displayMelody();
            visualizeMelodyStatic();
            showToast("æ—‹å¾‹å·²ç”Ÿæˆ! ğŸ¹");
        });

        // è®¾ç½®è‡ªå®šä¹‰æ—‹å¾‹
        document.getElementById('setMelody').addEventListener('click', () => {
            const input = document.getElementById('manualInput').value;
            const notes = input.split(/[,ï¼Œ\s]+/).map(n => n.trim().toUpperCase());
            const validNotes = notes.filter(n => NOTE_FREQUENCIES[n]);
            
            if (validNotes.length > 0) {
                currentMelody = validNotes;
                displayMelody();
                visualizeMelodyStatic();
                showToast("è‡ªå®šä¹‰æ—‹å¾‹å·²åº”ç”¨ âœ…");
            } else {
                showToast("æ— æ•ˆçš„éŸ³ç¬¦æ ¼å¼! âŒ");
            }
        });

        function displayMelody() {
            elements.melodyDisplay.innerText = currentMelody.join(' - ');
        }

        // --- æ’­æ”¾æ§åˆ¶ ---

        function getADSR() {
            return {
                a: parseFloat(elements.adsr.a.value),
                d: parseFloat(elements.adsr.d.value),
                s: parseFloat(elements.adsr.s.value),
                r: parseFloat(elements.adsr.r.value)
            };
        }

        document.getElementById('play').addEventListener('click', async () => {
            if (isPlaying) return;
            if (currentMelody.length === 0) {
                showToast("è¯·å…ˆç”Ÿæˆæ—‹å¾‹!");
                return;
            }
            
            initAudio();
            isPlaying = true;
            activeOscillators = [];
            
            const bpm = parseInt(elements.bpm.value);
            const beatDuration = 60 / bpm; // ç§’/æ‹
            const adsr = getADSR();
            const toneType = document.querySelector('input[name="tone"]:checked').value;

            // ç®€å•çš„è°ƒåº¦å™¨
            let startTime = audioCtx.currentTime + 0.1; // å»¶è¿Ÿä¸€ç‚¹å¼€å§‹

            currentMelody.forEach((note, index) => {
                const freq = NOTE_FREQUENCIES[note];
                const osc = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                
                osc.type = toneType;
                osc.frequency.value = freq;
                
                osc.connect(gainNode);
                gainNode.connect(masterGain);
                
                const noteStart = startTime + index * beatDuration;
                // é˜²æ­¢é‡å å¤ªå‰å®³ï¼Œé™åˆ¶æŒç»­æ—¶é—´
                const noteDuration = beatDuration * 0.9; 

                // ADSR åº”ç”¨
                // Attack
                gainNode.gain.setValueAtTime(0, noteStart);
                gainNode.gain.linearRampToValueAtTime(1, noteStart + adsr.a);
                // Decay & Sustain
                gainNode.gain.linearRampToValueAtTime(adsr.s, noteStart + adsr.a + adsr.d);
                
                // Release (åœ¨éŸ³ç¬¦ç»“æŸæ—¶)
                // å¦‚æœéŸ³ç¬¦æœ¬èº«æ—¶é•¿çŸ­äº A+Dï¼Œè¿™ä¼šæœ‰é—®é¢˜ï¼Œè¿™é‡Œç®€åŒ–å¤„ç†ï¼š
                // é‡Šæ”¾é˜¶æ®µå¼€å§‹æ—¶é—´ = éŸ³ç¬¦ç†è®ºç»“æŸæ—¶é—´
                const releaseStart = noteStart + Math.max(noteDuration, adsr.a + adsr.d);
                gainNode.gain.setValueAtTime(adsr.s, releaseStart);
                gainNode.gain.exponentialRampToValueAtTime(0.001, releaseStart + adsr.r);

                osc.start(noteStart);
                osc.stop(releaseStart + adsr.r + 0.1); // ç¨å¾®å¤šç»™ç‚¹æ—¶é—´æ¸…ç†
                
                activeOscillators.push(osc);
                
                // ç®€å•çš„å¯è§†åŒ–é«˜äº®å›è°ƒ
                setTimeout(() => {
                    if(isPlaying) visualizeHighlight(index);
                }, (noteStart - audioCtx.currentTime) * 1000);
            });

            // æ’­æ”¾ç»“æŸå›è°ƒ
            const totalTime = currentMelody.length * beatDuration + adsr.r + 1;
            setTimeout(() => {
                if(isPlaying) {
                    isPlaying = false;
                    showToast("æ’­æ”¾ç»“æŸ ğŸ");
                }
            }, totalTime * 1000);
        });

        document.getElementById('stop').addEventListener('click', () => {
            if (!isPlaying) return;
            activeOscillators.forEach(osc => {
                try { osc.stop(); } catch(e){}
            });
            activeOscillators = [];
            isPlaying = false;
            showToast("å·²åœæ­¢ â¹");
        });

        // --- ä¸‹è½½ WAV ---
        document.getElementById('download').addEventListener('click', () => {
            if (currentMelody.length === 0) return showToast("æ²¡æœ‰æ—‹å¾‹å¯ä¸‹è½½");
            
            // ç¦»çº¿æ¸²æŸ“
            const bpm = parseInt(elements.bpm.value);
            const beatDuration = 60 / bpm;
            const adsr = getADSR();
            const toneType = document.querySelector('input[name="tone"]:checked').value;
            // è®¡ç®—æ€»æ—¶é•¿ (æœ€åä¸€ä¸ªéŸ³ç¬¦å¼€å§‹æ—¶é—´ + è¶³å¤Ÿé•¿çš„å°¾éŸ³)
            const totalDuration = currentMelody.length * beatDuration + adsr.a + adsr.d + adsr.r + 2;
            
            // æ ‡å‡†é‡‡æ ·ç‡
            const sampleRate = 44100;
            const offlineCtx = new OfflineAudioContext(1, sampleRate * totalDuration, sampleRate);
            
            currentMelody.forEach((note, index) => {
                const freq = NOTE_FREQUENCIES[note];
                const osc = offlineCtx.createOscillator();
                const gainNode = offlineCtx.createGain();
                
                osc.type = toneType;
                osc.frequency.value = freq;
                
                osc.connect(gainNode);
                gainNode.connect(offlineCtx.destination);
                
                const noteStart = index * beatDuration;
                const noteDuration = beatDuration * 0.9;
                
                gainNode.gain.setValueAtTime(0, noteStart);
                gainNode.gain.linearRampToValueAtTime(1, noteStart + adsr.a);
                gainNode.gain.linearRampToValueAtTime(adsr.s, noteStart + adsr.a + adsr.d);
                
                const releaseStart = noteStart + Math.max(noteDuration, adsr.a + adsr.d);
                gainNode.gain.setValueAtTime(adsr.s, releaseStart);
                gainNode.gain.exponentialRampToValueAtTime(0.001, releaseStart + adsr.r);
                
                osc.start(noteStart);
                osc.stop(releaseStart + adsr.r + 0.1);
            });
            
            offlineCtx.startRendering().then(buffer => {
                const wav = audioBufferToWav(buffer);
                const blob = new Blob([new Uint8Array(wav)], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = `neon_melody_${Date.now()}.wav`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                showToast("ä¸‹è½½å·²å¼€å§‹ ğŸ“¥");
            });
        });

        // --- å¯è§†åŒ– ---
        const ctx = elements.canvas.getContext('2d');
        
        function visualizeMelodyStatic() {
            const w = elements.canvas.width;
            const h = elements.canvas.height;
            ctx.clearRect(0, 0, w, h);
            
            if (currentMelody.length === 0) return;
            
            const step = w / currentMelody.length;
            const barWidth = step * 0.6;
            
            ctx.fillStyle = 'rgba(187, 134, 252, 0.5)';
            ctx.strokeStyle = '#03dac6';
            
            // æ‰¾å‡ºæœ€é«˜æœ€ä½éŸ³ï¼Œç”¨äºå½’ä¸€åŒ–é«˜åº¦
            // ç®€å•å¤„ç†ï¼šC3(130Hz) - C6(1046Hz)
            const minFreq = 130;
            const maxFreq = 1050;
            
            currentMelody.forEach((note, i) => {
                const freq = NOTE_FREQUENCIES[note];
                // Log scale for better visual
                const percent = (Math.log2(freq) - Math.log2(minFreq)) / (Math.log2(maxFreq) - Math.log2(minFreq));
                const barHeight = Math.max(10, percent * h * 0.8);
                const x = i * step + (step - barWidth) / 2;
                const y = h - barHeight;
                
                // ç»˜åˆ¶æ¡å½¢
                ctx.fillStyle = `hsl(${260 + percent * 60}, 70%, 60%)`;
                ctx.fillRect(x, y, barWidth, barHeight);
                
                // ç»˜åˆ¶éŸ³å
                ctx.fillStyle = '#fff';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(note, x + barWidth/2, h - 5);
            });
        }
        
        function visualizeHighlight(currentIndex) {
            // é‡ç»˜å¹¶é«˜äº®å½“å‰éŸ³ç¬¦
            visualizeMelodyStatic(); // å…ˆé‡ç½®
            
            const w = elements.canvas.width;
            const h = elements.canvas.height;
            const step = w / currentMelody.length;
            const barWidth = step * 0.6;
            
            const x = currentIndex * step + (step - barWidth) / 2;
            
            // ç»˜åˆ¶é«˜äº®å…‰æŸ±
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(x - 5, 0, barWidth + 10, h);
            ctx.restore();
        }

        // --- è¾…åŠ©åŠŸèƒ½ ---
        function showToast(msg) {
            const toast = document.getElementById('toast');
            toast.innerText = msg;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2000);
        }

        // ä¿å­˜/åŠ è½½ (Local Storage)
        document.getElementById('save').addEventListener('click', () => {
            if(currentMelody.length === 0) return showToast("ç©ºæ—‹å¾‹æ— æ³•ä¿å­˜");
            const data = {
                melody: currentMelody,
                bpm: elements.bpm.value,
                scaleRoot: elements.scaleRoot.value,
                scaleType: elements.scaleType.value
            };
            localStorage.setItem('neon_melody_save', JSON.stringify(data));
            showToast("å·²ä¿å­˜è‡³æµè§ˆå™¨ç¼“å­˜ ğŸ’¾");
        });

        document.getElementById('load').addEventListener('click', () => {
            const saved = localStorage.getItem('neon_melody_save');
            if(saved) {
                const data = JSON.parse(saved);
                currentMelody = data.melody;
                elements.bpm.value = data.bpm;
                elements.bpmVal.innerText = data.bpm;
                elements.scaleRoot.value = data.scaleRoot || 'C';
                elements.scaleType.value = data.scaleType || 'major';
                
                displayMelody();
                visualizeMelodyStatic();
                showToast("å·²åŠ è½½å­˜æ¡£ ğŸ“‚");
            } else {
                showToast("æœªæ‰¾åˆ°å­˜æ¡£ âŒ");
            }
        });

        // AudioBuffer to WAV helper (Standard implementation)
        function audioBufferToWav(buffer) {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = 1; // PCM
            const bitDepth = 16;
            
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;
            
            const data = buffer.getChannelData(0); // Only support mono/left for simplicity here, loop for multi
            const bufferLength = data.length;
            const byteRate = sampleRate * blockAlign;
            const waveDataLength = bufferLength * blockAlign;
            const chunkSize = 36 + waveDataLength;
            
            const bufferArray = new ArrayBuffer(chunkSize + 8);
            const view = new DataView(bufferArray);
            
            const writeString = (view, offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            let offset = 0;
            writeString(view, offset, 'RIFF'); offset += 4;
            view.setUint32(offset, chunkSize, true); offset += 4;
            writeString(view, offset, 'WAVE'); offset += 4;
            writeString(view, offset, 'fmt '); offset += 4;
            view.setUint32(offset, 16, true); offset += 4; // Subchunk1Size
            view.setUint16(offset, format, true); offset += 2;
            view.setUint16(offset, numChannels, true); offset += 2;
            view.setUint32(offset, sampleRate, true); offset += 4;
            view.setUint32(offset, byteRate, true); offset += 4;
            view.setUint16(offset, blockAlign, true); offset += 2;
            view.setUint16(offset, bitDepth, true); offset += 2;
            writeString(view, offset, 'data'); offset += 4;
            view.setUint32(offset, waveDataLength, true); offset += 4;
            
            // Write PCM data
            for (let i = 0; i < bufferLength; i++) {
                let sample = data[i];
                // Clip
                sample = Math.max(-1, Math.min(1, sample));
                // Scale to 16-bit
                sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                view.setInt16(offset, sample, true);
                offset += 2;
            }
            
            return bufferArray;
        }

        // åˆå§‹ç©ºçŠ¶æ€å¯è§†åŒ–
        visualizeMelodyStatic();

    </script>
</body>
</html>
