<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>文件破坏工具</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            color: #e2d9f3;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .container {
            max-width: 800px;
            width: 100%;
            background: rgba(20, 15, 45, 0.85);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            margin-top: 20px;
            border: 1px solid #4a2c8d;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            background: linear-gradient(to right, #9d50bb, #6e48aa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .subtitle {
            text-align: center;
            margin-bottom: 30px;
            color: #b8a9d9;
            font-size: 1.1rem;
        }
        
        .warning {
            background: rgba(157, 80, 187, 0.2);
            border-left: 5px solid #9d50bb;
            padding: 15px;
            margin-bottom: 25px;
            border-radius: 5px;
            color: #e2d9f3;
        }
        
        .upload-area {
            border: 3px dashed #6e48aa;
            border-radius: 10px;
            padding: 40px 20px;
            text-align: center;
            margin-bottom: 25px;
            transition: all 0.3s;
            cursor: pointer;
            background: rgba(110, 72, 170, 0.1);
        }
        
        .upload-area:hover {
            background: rgba(110, 72, 170, 0.2);
            border-color: #9d50bb;
        }
        
        .upload-area.dragover {
            background: rgba(157, 80, 187, 0.2);
            border-color: #c86bfa;
        }
        
        .upload-icon {
            font-size: 60px;
            margin-bottom: 15px;
            color: #9d50bb;
        }
        
        .file-input {
            display: none;
        }
        
        .file-info {
            background: rgba(110, 72, 170, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 25px;
            display: none;
            border: 1px solid #6e48aa;
        }
        
        .file-info.active {
            display: block;
        }
        
        .controls {
            margin-bottom: 25px;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #c86bfa;
        }
        
        select, button {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: none;
            font-size: 1rem;
        }
        
        select {
            background: #2d1b69;
            color: #e2d9f3;
            cursor: pointer;
            border: 1px solid #6e48aa;
        }
        
        select option {
            background: #2d1b69;
            color: #e2d9f3;
        }
        
        button {
            background: linear-gradient(to right, #9d50bb, #6e48aa);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
            border: 1px solid #9d50bb;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(157, 80, 187, 0.4);
            background: linear-gradient(to right, #c86bfa, #9d50bb);
        }
        
        button:disabled {
            background: #4a3c6e;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            border: 1px solid #5d4a8a;
        }
        
        .progress-container {
            margin: 20px 0;
            display: none;
        }
        
        .progress-container.active {
            display: block;
        }
        
        .progress-bar {
            height: 10px;
            background: #2d1b69;
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 10px;
            border: 1px solid #6e48aa;
        }
        
        .progress {
            height: 100%;
            background: linear-gradient(to right, #9d50bb, #c86bfa);
            width: 0%;
            transition: width 0.3s;
        }
        
        .progress-text {
            text-align: center;
            font-size: 0.9rem;
            color: #b8a9d9;
        }
        
        .result {
            background: rgba(110, 72, 170, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            display: none;
            border: 1px solid #6e48aa;
        }
        
        .result.active {
            display: block;
        }
        
        .comparison {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }
        
        .original, .corrupted {
            width: 48%;
            padding: 10px;
            border-radius: 5px;
        }
        
        .original {
            background: rgba(46, 204, 113, 0.2);
            border-left: 3px solid #2ecc71;
        }
        
        .corrupted {
            background: rgba(231, 76, 60, 0.2);
            border-left: 3px solid #e74c3c;
        }
        
        .hash-display {
            font-family: monospace;
            word-break: break-all;
            font-size: 0.85rem;
            margin-top: 5px;
            background: rgba(0, 0, 0, 0.3);
            padding: 5px;
            border-radius: 3px;
            color: #e2d9f3;
        }
        
        footer {
            margin-top: 30px;
            text-align: center;
            font-size: 0.9rem;
            color: rgba(226, 217, 243, 0.7);
        }
        
        @media (max-width: 600px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            .comparison {
                flex-direction: column;
            }
            
            .original, .corrupted {
                width: 100%;
                margin-bottom: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>文件破坏工具</h1>
        
        <div class="warning">
            <strong>警告：</strong> 此工具将永久损坏您的文件。请确保您拥有文件的合法权限，并且已备份重要数据。使用此工具造成的任何数据损失，开发者概不负责。
        </div>
        
        <div class="upload-area" id="uploadArea">
            <div class="upload-icon">📁</div>
            <h3>点击或拖放文件到这里</h3>
            <p>支持任何类型的文件</p>
            <input type="file" id="fileInput" class="file-input">
        </div>
        
        <div class="file-info" id="fileInfo">
            <h3>文件信息</h3>
            <p><strong>文件名：</strong> <span id="fileName"></span></p>
            <p><strong>文件类型：</strong> <span id="fileType"></span></p>
            <p><strong>文件大小：</strong> <span id="fileSize"></span></p>
            <p><strong>MD5哈希值：</strong> <span id="fileHash"></span></p>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label for="corruptionLevel">破坏强度：</label>
                <select id="corruptionLevel">
                    <option value="low">轻微破坏（修改10%数据）</option>
                    <option value="medium" selected>中等破坏（修改50%数据）</option>
                    <option value="high">完全破坏（修改90%数据）</option>
                </select>
            </div>
            
            <button id="corruptBtn" disabled>破坏文件</button>
        </div>
        
        <div class="progress-container" id="progressContainer">
            <div class="progress-bar">
                <div class="progress" id="progressBar"></div>
            </div>
            <div class="progress-text" id="progressText">计算MD5中...</div>
        </div>
        
        <div class="result" id="result">
            <h3>破坏完成</h3>
            <div class="comparison">
                <div class="original">
                    <h4>原始文件</h4>
                    <p><strong>大小：</strong> <span id="originalSize"></span></p>
                    <p><strong>MD5：</strong></p>
                    <div class="hash-display" id="originalHash"></div>
                </div>
                <div class="corrupted">
                    <h4>已破坏文件</h4>
                    <p><strong>大小：</strong> <span id="corruptedSize"></span></p>
                    <p><strong>MD5：</strong></p>
                    <div class="hash-display" id="corruptedHash"></div>
                </div>
            </div>
            <button id="downloadBtn">下载已破坏的文件</button>
        </div>
    </div>

    <script>
        // MD5计算函数
        function md5(input) {
            function rotateLeft(lValue, iShiftBits) {
                return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
            }

            function addUnsigned(lX, lY) {
                const lX8 = (lX & 0x80000000);
                const lY8 = (lY & 0x80000000);
                const lX4 = (lX & 0x40000000);
                const lY4 = (lY & 0x40000000);
                const lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);
                
                if (lX4 & lY4) {
                    return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
                }
                if (lX4 | lY4) {
                    if (lResult & 0x40000000) {
                        return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
                    } else {
                        return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
                    }
                } else {
                    return (lResult ^ lX8 ^ lY8);
                }
            }

            function F(x, y, z) {
                return (x & y) | ((~x) & z);
            }

            function G(x, y, z) {
                return (x & z) | (y & (~z));
            }

            function H(x, y, z) {
                return x ^ y ^ z;
            }

            function I(x, y, z) {
                return y ^ (x | (~z));
            }

            function FF(a, b, c, d, x, s, ac) {
                a = addUnsigned(a, addUnsigned(addUnsigned(F(b, c, d), x), ac));
                return addUnsigned(rotateLeft(a, s), b);
            }

            function GG(a, b, c, d, x, s, ac) {
                a = addUnsigned(a, addUnsigned(addUnsigned(G(b, c, d), x), ac));
                return addUnsigned(rotateLeft(a, s), b);
            }

            function HH(a, b, c, d, x, s, ac) {
                a = addUnsigned(a, addUnsigned(addUnsigned(H(b, c, d), x), ac));
                return addUnsigned(rotateLeft(a, s), b);
            }

            function II(a, b, c, d, x, s, ac) {
                a = addUnsigned(a, addUnsigned(addUnsigned(I(b, c, d), x), ac));
                return addUnsigned(rotateLeft(a, s), b);
            }

            function convertToWordArray(input) {
                let lWordCount;
                const lMessageLength = input.length;
                const lNumberOfWords_temp1 = lMessageLength + 8;
                const lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
                const lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
                const lWordArray = Array(lNumberOfWords - 1);
                let lBytePosition = 0;
                let lByteCount = 0;
                
                while (lByteCount < lMessageLength) {
                    lWordCount = (lByteCount - (lByteCount % 4)) / 4;
                    lBytePosition = (lByteCount % 4) * 8;
                    lWordArray[lWordCount] = (lWordArray[lWordCount] | (input.charCodeAt(lByteCount) << lBytePosition));
                    lByteCount++;
                }
                
                lWordCount = (lByteCount - (lByteCount % 4)) / 4;
                lBytePosition = (lByteCount % 4) * 8;
                lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 << lBytePosition);
                lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
                lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
                
                return lWordArray;
            }

            function wordToHex(lValue) {
                let WordToHexValue = "", WordToHexValue_temp = "", lByte, lCount;
                
                for (lCount = 0; lCount <= 3; lCount++) {
                    lByte = (lValue >>> (lCount * 8)) & 255;
                    WordToHexValue_temp = "0" + lByte.toString(16);
                    WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length - 2, 2);
                }
                
                return WordToHexValue;
            }

            let x = Array();
            let k, AA, BB, CC, DD, a, b, c, d;
            const S11 = 7, S12 = 12, S13 = 17, S14 = 22;
            const S21 = 5, S22 = 9, S23 = 14, S24 = 20;
            const S31 = 4, S32 = 11, S33 = 16, S34 = 23;
            const S41 = 6, S42 = 10, S43 = 15, S44 = 21;

            x = convertToWordArray(input);

            a = 0x67452301;
            b = 0xEFCDAB89;
            c = 0x98BADCFE;
            d = 0x10325476;

            for (k = 0; k < x.length; k += 16) {
                AA = a;
                BB = b;
                CC = c;
                DD = d;
                a = FF(a, b, c, d, x[k + 0], S11, 0xD76AA478);
                d = FF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);
                c = FF(c, d, a, b, x[k + 2], S13, 0x242070DB);
                b = FF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);
                a = FF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);
                d = FF(d, a, b, c, x[k + 5], S12, 0x4787C62A);
                c = FF(c, d, a, b, x[k + 6], S13, 0xA8304613);
                b = FF(b, c, d, a, x[k + 7], S14, 0xFD469501);
                a = FF(a, b, c, d, x[k + 8], S11, 0x698098D8);
                d = FF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);
                c = FF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);
                b = FF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);
                a = FF(a, b, c, d, x[k + 12], S11, 0x6B901122);
                d = FF(d, a, b, c, x[k + 13], S12, 0xFD987193);
                c = FF(c, d, a, b, x[k + 14], S13, 0xA679438E);
                b = FF(b, c, d, a, x[k + 15], S14, 0x49B40821);
                a = GG(a, b, c, d, x[k + 1], S21, 0xF61E2562);
                d = GG(d, a, b, c, x[k + 6], S22, 0xC040B340);
                c = GG(c, d, a, b, x[k + 11], S23, 0x265E5A51);
                b = GG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);
                a = GG(a, b, c, d, x[k + 5], S21, 0xD62F105D);
                d = GG(d, a, b, c, x[k + 10], S22, 0x2441453);
                c = GG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);
                b = GG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);
                a = GG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);
                d = GG(d, a, b, c, x[k + 14], S22, 0xC33707D6);
                c = GG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);
                b = GG(b, c, d, a, x[k + 8], S24, 0x455A14ED);
                a = GG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);
                d = GG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);
                c = GG(c, d, a, b, x[k + 7], S23, 0x676F02D9);
                b = GG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);
                a = HH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);
                d = HH(d, a, b, c, x[k + 8], S32, 0x8771F681);
                c = HH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);
                b = HH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);
                a = HH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);
                d = HH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);
                c = HH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);
                b = HH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);
                a = HH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);
                d = HH(d, a, b, c, x[k + 0], S32, 0xEAA127FA);
                c = HH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);
                b = HH(b, c, d, a, x[k + 6], S34, 0x4881D05);
                a = HH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);
                d = HH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);
                c = HH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);
                b = HH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);
                a = II(a, b, c, d, x[k + 0], S41, 0xF4292244);
                d = II(d, a, b, c, x[k + 7], S42, 0x432AFF97);
                c = II(c, d, a, b, x[k + 14], S43, 0xAB9423A7);
                b = II(b, c, d, a, x[k + 5], S44, 0xFC93A039);
                a = II(a, b, c, d, x[k + 12], S41, 0x655B59C3);
                d = II(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);
                c = II(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);
                b = II(b, c, d, a, x[k + 1], S44, 0x85845DD1);
                a = II(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);
                d = II(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);
                c = II(c, d, a, b, x[k + 6], S43, 0xA3014314);
                b = II(b, c, d, a, x[k + 13], S44, 0x4E0811A1);
                a = II(a, b, c, d, x[k + 4], S41, 0xF7537E82);
                d = II(d, a, b, c, x[k + 11], S42, 0xBD3AF235);
                c = II(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);
                b = II(b, c, d, a, x[k + 9], S44, 0xEB86D391);
                a = addUnsigned(a, AA);
                b = addUnsigned(b, BB);
                c = addUnsigned(c, CC);
                d = addUnsigned(d, DD);
            }

            return wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d);
        }

        // 计算ArrayBuffer的MD5
        function arrayBufferToMD5(arrayBuffer) {
            const uint8Array = new Uint8Array(arrayBuffer);
            let binaryString = '';
            
            for (let i = 0; i < uint8Array.length; i++) {
                binaryString += String.fromCharCode(uint8Array[i]);
            }
            
            return md5(binaryString);
        }

        document.addEventListener('DOMContentLoaded', function() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            const fileInfo = document.getElementById('fileInfo');
            const fileName = document.getElementById('fileName');
            const fileType = document.getElementById('fileType');
            const fileSize = document.getElementById('fileSize');
            const fileHash = document.getElementById('fileHash');
            const corruptionLevel = document.getElementById('corruptionLevel');
            const corruptBtn = document.getElementById('corruptBtn');
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const result = document.getElementById('result');
            const originalSize = document.getElementById('originalSize');
            const originalHash = document.getElementById('originalHash');
            const corruptedSize = document.getElementById('corruptedSize');
            const corruptedHash = document.getElementById('corruptedHash');
            const downloadBtn = document.getElementById('downloadBtn');
            
            let selectedFile = null;
            let corruptedFile = null;
            let originalFileHash = '';
            
            // 上传区域点击事件
            uploadArea.addEventListener('click', () => {
                fileInput.click();
            });
            
            // 拖放功能
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });
            
            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                
                if (e.dataTransfer.files.length) {
                    handleFile(e.dataTransfer.files[0]);
                }
            });
            
            // 文件选择事件
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length) {
                    handleFile(e.target.files[0]);
                }
            });
            
            // 处理选择的文件
            function handleFile(file) {
                selectedFile = file;
                
                // 显示文件信息
                fileName.textContent = file.name;
                fileType.textContent = file.type || '未知类型';
                fileSize.textContent = formatFileSize(file.size);
                fileHash.textContent = '计算中...';
                
                fileInfo.classList.add('active');
                corruptBtn.disabled = true;
                
                // 隐藏之前的结果
                result.classList.remove('active');
                
                // 计算原始文件的MD5
                progressContainer.classList.add('active');
                progressBar.style.width = '0%';
                progressText.textContent = '计算MD5中...';
                
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const arrayBuffer = e.target.result;
                    
                    // 模拟计算进度
                    let progress = 0;
                    const progressInterval = setInterval(() => {
                        progress += 5;
                        progressBar.style.width = progress + '%';
                        
                        if (progress >= 100) {
                            clearInterval(progressInterval);
                            
                            // 计算MD5
                            originalFileHash = arrayBufferToMD5(arrayBuffer);
                            fileHash.textContent = originalFileHash;
                            
                            progressContainer.classList.remove('active');
                            corruptBtn.disabled = false;
                        }
                    }, 50);
                };
                
                reader.readAsArrayBuffer(file);
            }
            
            // 破坏文件按钮点击事件
            corruptBtn.addEventListener('click', () => {
                if (!selectedFile) return;
                
                // 显示加载状态
                corruptBtn.textContent = '破坏中...';
                corruptBtn.disabled = true;
                
                // 模拟处理时间
                setTimeout(() => {
                    corruptFile(selectedFile);
                }, 500);
            });
            
            // 破坏文件函数
            function corruptFile(file) {
                progressContainer.classList.add('active');
                progressBar.style.width = '0%';
                progressText.textContent = '破坏文件中...';
                
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const arrayBuffer = e.target.result;
                    const uint8Array = new Uint8Array(arrayBuffer);
                    
                    // 根据选择的破坏强度修改文件数据
                    const level = corruptionLevel.value;
                    let corruptionPercentage;
                    
                    switch(level) {
                        case 'low':
                            corruptionPercentage = 0.1; // 10% 的数据被破坏
                            break;
                        case 'medium':
                            corruptionPercentage = 0.5; // 50% 的数据被破坏
                            break;
                        case 'high':
                            corruptionPercentage = 0.9; // 90% 的数据被破坏
                            break;
                    }
                    
                    // 破坏文件数据
                    const bytesToCorrupt = Math.floor(uint8Array.length * corruptionPercentage);
                    
                    // 模拟破坏进度
                    let progress = 0;
                    const progressInterval = setInterval(() => {
                        progress += 5;
                        progressBar.style.width = progress + '%';
                        
                        if (progress >= 100) {
                            clearInterval(progressInterval);
                            
                            // 实际破坏文件
                            for (let i = 0; i < bytesToCorrupt; i++) {
                                const randomIndex = Math.floor(Math.random() * uint8Array.length);
                                uint8Array[randomIndex] = Math.floor(Math.random() * 256);
                            }
                            
                            // 创建被破坏的文件
                            corruptedFile = new Blob([uint8Array], { type: file.type });
                            
                            // 计算被破坏文件的MD5
                            progressText.textContent = '计算被破坏文件的MD5...';
                            
                            setTimeout(() => {
                                const corruptedArrayBuffer = new Uint8Array(corruptedFile).buffer;
                                const corruptedFileHash = arrayBufferToMD5(corruptedArrayBuffer);
                                
                                // 显示结果
                                originalSize.textContent = formatFileSize(file.size);
                                originalHash.textContent = originalFileHash;
                                corruptedSize.textContent = formatFileSize(corruptedFile.size);
                                corruptedHash.textContent = corruptedFileHash;
                                
                                result.classList.add('active');
                                progressContainer.classList.remove('active');
                                corruptBtn.textContent = '破坏文件';
                                corruptBtn.disabled = false;
                            }, 500);
                        }
                    }, 30);
                };
                
                reader.readAsArrayBuffer(file);
            }
            
            // 下载被破坏的文件
            downloadBtn.addEventListener('click', () => {
                if (!corruptedFile) return;
                
                const url = URL.createObjectURL(corruptedFile);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'corrupted_' + selectedFile.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
            
            // 格式化文件大小显示
            function formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
        });
    </script>
</body>
</html>